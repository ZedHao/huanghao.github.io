<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NK一哥黄大脸</title>
  
  <subtitle>黄大脸是个小可爱</subtitle>
  <link href="https://zedhao.github.io/huanghao.github.io/atom.xml" rel="self"/>
  
  <link href="https://zedhao.github.io/huanghao.github.io/"/>
  <updated>2020-11-18T08:26:40.367Z</updated>
  <id>https://zedhao.github.io/huanghao.github.io/</id>
  
  <author>
    <name>huanghao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>articl31</title>
    <link href="https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/"/>
    <id>https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/</id>
    <published>2020-11-18T08:26:40.000Z</published>
    <updated>2020-11-18T08:26:40.367Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>articl31</title>
    <link href="https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/"/>
    <id>https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/</id>
    <published>2020-11-18T08:26:30.000Z</published>
    <updated>2020-11-18T08:26:30.945Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>articl31</title>
    <link href="https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/"/>
    <id>https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/</id>
    <published>2020-11-18T08:25:15.000Z</published>
    <updated>2020-11-18T08:25:15.828Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>article title</title>
    <link href="https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/"/>
    <id>https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/</id>
    <published>2020-11-18T08:19:14.000Z</published>
    <updated>2020-11-18T08:19:14.574Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>article title</title>
    <link href="https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/"/>
    <id>https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/</id>
    <published>2020-11-18T08:13:08.000Z</published>
    <updated>2020-11-18T08:13:08.338Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/"/>
    <id>https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/</id>
    <published>2020-11-18T03:59:38.029Z</published>
    <updated>2020-11-18T03:59:38.029Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h1><p>Innodb有多个内存块，<br><img src="https://img-blog.csdn.net/20180612011119133" alt="image"><br><img src="https://note.youdao.com/yws/res/8987/07266E65D3C044DF8119F138A2485B18" alt="image"></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>（1）内存根据分工以及存储文件的不同分为==缓冲池、重做日志缓冲、额外内存池：==</p><p>缓冲池：InnoDB引擎是基于磁盘存储的，磁盘io慢，若在缓冲池中，称该页被命中，直接读取缓冲池中的页。否则，读取磁盘上的页，由此提高了读取的速度。</p><p>数据库修改数据操作时，首先修改在缓冲池的页，然后再异步刷新到磁盘上，从而提高改数据的速度。缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。</p><p>重做日志缓冲：InnoDB首先将重做日志信息放到这个缓冲区，然后按照一定频率将其刷新到重做日志文件。默认1秒钟刷新一次，因此重做日志缓冲一般不需要很大，默认8M。</p><p>日志在下列3种情况下会刷新重做日志缓冲：</p><ul><li>（1）每秒将重做日志缓冲刷新到重做日志文件</li><li></li><li>（2）每个事务提交时会将重做日志缓冲刷新到重做日志文件</li><li></li><li>（3）当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。</li></ul><p>额外的内存池：在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请。</p><h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><p>（2）后台线程根据功能不同分==为master Thread、IO Thread、Purge Thread、Page Cleaner== Thread:</p><p>Master Thread【每秒和每十秒】:==负责将缓冲池中的数据异步刷新到磁盘==，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO夜的回收等。</p><p>IO Thread:在InnoDB存储引擎中大量使用异步 IO处理IO请求以提高数据库的性能，IO Thread负责这些IO请求的回调处理。IO Thread 有4类，分别为write、read、insert buffer、log IO thread。</p><p>Purge Thread：由于回收不再需要的undo页。</p><p>Page Cleaner Thread:将缓冲池中脏页（即被修改过于磁盘中数据不一致的页）刷新到磁盘中。</p><h1 id="InnoDB的三大特性"><a href="#InnoDB的三大特性" class="headerlink" title="InnoDB的三大特性"></a>InnoDB的三大特性</h1><h2 id="插入缓冲【针对非聚集索引】"><a href="#插入缓冲【针对非聚集索引】" class="headerlink" title="插入缓冲【针对非聚集索引】"></a>插入缓冲【针对非聚集索引】</h2><p>对于==非聚集索引的插入和更新操作==，Innodb存储引擎并不是直接插入到索引页中，而是的Insert Buffer。==然后再以一定的频率进行insertbuffer和辅助索引叶子节点的merge。着通常将多个随机插入合并到一个操作中。大大提高了非聚集索引插入的性能。==</p><p>条件：索引不是非聚集索引且不是unique</p><h2 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h2><h2 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h2><p>当数据库正在从内存向磁盘写一个数据页时，数据库宕机，从而导致这个页只写了部分数据，这就是部分写失效，它会导致数据丢失。这时是无法通过重做日志恢复的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力。</p><p><img src="https://img-blog.csdn.net/20130612080041468" alt="image"><br>两次写需要额外添加两个部分：</p><ul><li>1）内存中的两次写缓冲（doublewrite buffer），大小为2MB</li><li>2）磁盘上共享表空间中连续的128页，大小也为2MB</li></ul><p>其原理是这样的：</p><ul><li>1）当刷新缓冲池脏页时，并不直接写到数据文件中，而是先拷贝至内存中的两次写缓冲区。</li><li>2）接着从两次写缓冲区分两次写入磁盘共享表空间中，每次写入1MB</li><li>3）待第2步完成后，再将两次写缓冲区写入数据文件</li></ul><p>这样就可以解决上文提到的部分写失效的问题，因为在磁盘共享表空间中已有数据页副本拷贝，如果数据库在页写入数据文件的过程中宕机，在实例恢复时，可以从共享表空间中找到该页副本，将其拷贝覆盖原有的数据页，再应用重做日志即可。</p><h2 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h2><p>nnodb 存储引擎会监控对表上各索引页的查询，如果观察到建立hash索引可以带来速度的提升。则建立hash索引，称之为自适应hash索引（AHI).</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;InnoDB体系架构&quot;&gt;&lt;a href=&quot;#InnoDB体系架构&quot; class=&quot;headerlink&quot; title=&quot;InnoDB体系架构&quot;&gt;&lt;/a&gt;InnoDB体系架构&lt;/h1&gt;&lt;p&gt;Innodb有多个内存块，&lt;br&gt;&lt;img src</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/"/>
    <id>https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/</id>
    <published>2020-11-18T03:59:38.029Z</published>
    <updated>2020-11-18T03:59:38.029Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h1><p>Innodb有多个内存块，<br><img src="https://img-blog.csdn.net/20180612011119133" alt="image"><br><img src="https://note.youdao.com/yws/res/8987/07266E65D3C044DF8119F138A2485B18" alt="image"></p><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>（1）内存根据分工以及存储文件的不同分为==缓冲池、重做日志缓冲、额外内存池：==</p><p>缓冲池：InnoDB引擎是基于磁盘存储的，磁盘io慢，若在缓冲池中，称该页被命中，直接读取缓冲池中的页。否则，读取磁盘上的页，由此提高了读取的速度。</p><p>数据库修改数据操作时，首先修改在缓冲池的页，然后再异步刷新到磁盘上，从而提高改数据的速度。缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等。</p><p>重做日志缓冲：InnoDB首先将重做日志信息放到这个缓冲区，然后按照一定频率将其刷新到重做日志文件。默认1秒钟刷新一次，因此重做日志缓冲一般不需要很大，默认8M。</p><p>日志在下列3种情况下会刷新重做日志缓冲：</p><ul><li>（1）每秒将重做日志缓冲刷新到重做日志文件</li><li></li><li>（2）每个事务提交时会将重做日志缓冲刷新到重做日志文件</li><li></li><li>（3）当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。</li></ul><p>额外的内存池：在InnoDB存储引擎中，对内存的管理是通过一种称为内存堆的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请。</p><h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><p>（2）后台线程根据功能不同分==为master Thread、IO Thread、Purge Thread、Page Cleaner== Thread:</p><p>Master Thread【每秒和每十秒】:==负责将缓冲池中的数据异步刷新到磁盘==，保证数据的一致性，包括脏页的刷新、合并插入缓冲、UNDO夜的回收等。</p><p>IO Thread:在InnoDB存储引擎中大量使用异步 IO处理IO请求以提高数据库的性能，IO Thread负责这些IO请求的回调处理。IO Thread 有4类，分别为write、read、insert buffer、log IO thread。</p><p>Purge Thread：由于回收不再需要的undo页。</p><p>Page Cleaner Thread:将缓冲池中脏页（即被修改过于磁盘中数据不一致的页）刷新到磁盘中。</p><h1 id="InnoDB的三大特性"><a href="#InnoDB的三大特性" class="headerlink" title="InnoDB的三大特性"></a>InnoDB的三大特性</h1><h2 id="插入缓冲【针对非聚集索引】"><a href="#插入缓冲【针对非聚集索引】" class="headerlink" title="插入缓冲【针对非聚集索引】"></a>插入缓冲【针对非聚集索引】</h2><p>对于==非聚集索引的插入和更新操作==，Innodb存储引擎并不是直接插入到索引页中，而是的Insert Buffer。==然后再以一定的频率进行insertbuffer和辅助索引叶子节点的merge。着通常将多个随机插入合并到一个操作中。大大提高了非聚集索引插入的性能。==</p><p>条件：索引不是非聚集索引且不是unique</p><h2 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h2><h2 id="两次写"><a href="#两次写" class="headerlink" title="两次写"></a>两次写</h2><p>当数据库正在从内存向磁盘写一个数据页时，数据库宕机，从而导致这个页只写了部分数据，这就是部分写失效，它会导致数据丢失。这时是无法通过重做日志恢复的，因为重做日志记录的是对页的物理修改，如果页本身已经损坏，重做日志也无能为力。</p><p><img src="https://img-blog.csdn.net/20130612080041468" alt="image"><br>两次写需要额外添加两个部分：</p><ul><li>1）内存中的两次写缓冲（doublewrite buffer），大小为2MB</li><li>2）磁盘上共享表空间中连续的128页，大小也为2MB</li></ul><p>其原理是这样的：</p><ul><li>1）当刷新缓冲池脏页时，并不直接写到数据文件中，而是先拷贝至内存中的两次写缓冲区。</li><li>2）接着从两次写缓冲区分两次写入磁盘共享表空间中，每次写入1MB</li><li>3）待第2步完成后，再将两次写缓冲区写入数据文件</li></ul><p>这样就可以解决上文提到的部分写失效的问题，因为在磁盘共享表空间中已有数据页副本拷贝，如果数据库在页写入数据文件的过程中宕机，在实例恢复时，可以从共享表空间中找到该页副本，将其拷贝覆盖原有的数据页，再应用重做日志即可。</p><h2 id="自适应哈希索引"><a href="#自适应哈希索引" class="headerlink" title="自适应哈希索引"></a>自适应哈希索引</h2><p>nnodb 存储引擎会监控对表上各索引页的查询，如果观察到建立hash索引可以带来速度的提升。则建立hash索引，称之为自适应hash索引（AHI).</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;InnoDB体系架构&quot;&gt;&lt;a href=&quot;#InnoDB体系架构&quot; class=&quot;headerlink&quot; title=&quot;InnoDB体系架构&quot;&gt;&lt;/a&gt;InnoDB体系架构&lt;/h1&gt;&lt;p&gt;Innodb有多个内存块，&lt;br&gt;&lt;img src</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>My First Post</title>
    <link href="https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/"/>
    <id>https://zedhao.github.io/huanghao.github.io/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT-6.828%E8%AF%BE%E7%A8%8B/</id>
    <published>2020-11-17T11:06:56.000Z</published>
    <updated>2020-11-17T11:06:56.060Z</updated>
    
    
    
    
    
  </entry>
  
</feed>
