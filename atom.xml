<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NK一哥黄大脸</title>
  
  <subtitle>黄大脸是个小可爱</subtitle>
  <link href="https://zedhao.github.io/huanghao.github.io/atom.xml" rel="self"/>
  
  <link href="https://zedhao.github.io/huanghao.github.io/"/>
  <updated>2020-11-19T16:00:28.862Z</updated>
  <id>https://zedhao.github.io/huanghao.github.io/</id>
  
  <author>
    <name>huanghao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E6%89%80%E8%B0%93%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E6%89%80%E8%B0%93%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/</id>
    <published>2020-11-19T16:00:28.862Z</published>
    <updated>2020-11-19T16:00:28.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h1><p>学过计算机的人都知道 ASCII 码，总共有 128 个，用一个字节的低 7 位表示，0<del>31 是控制字符如换行回车删除等；32</del>126 是打印字符，可以通过键盘输入并且能够显示出来。 </p><h1 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO-8859-1"></a>ISO-8859-1</h1><p>128 个字符显然是不够用的，于是 ISO 组织在 ASCII 码基础上又制定了一些列标准用来扩展 ASCII 编码，它们是 ISO-8859-1~ISO-8859-15，其中 ISO-8859-1 涵盖了大多数西欧语言字符，所有应用的最广泛。ISO-8859-1 仍然是单字节编码，它总共能表示 256 个字符。 GB2312<br>它的全称是《信息交换用汉字编码字符集 基本集》，它是双字节编码，总的编码范围是 A1-F7，其中从 A1-A9 是符号区，总共包含 682 个符号，从 B0-F7 是汉字区，包含 6763 个汉字。</p><h1 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h1><p>全称叫《汉字内码扩展规范》，是国家技术监督局为 windows95 所制定的新的汉字内码规范，它的出现是为了扩展 GB2312，加入更多的汉字，它的编码范围是 8140~FEFE（去掉 XX7F）总共有 23940 个码位，它能表示 21003 个汉字，它的编码是和 GB2312 兼容的，也就是说用 GB2312 编码的汉字可以用 GBK 来解码，并且不会有乱码。 </p><h1 id="GB18030"><a href="#GB18030" class="headerlink" title="GB18030"></a>GB18030</h1><p>全称是《信息交换用汉字编码字符集》，是我国的强制标准，它可能是单字节、双字节或者四字节编码，它的编码与 GB2312 编码兼容，这个虽然是国家标准，但是实际应用系统中使用的并不广泛。 </p><h1 id="UTF-16"><a href="#UTF-16" class="headerlink" title="UTF-16"></a>UTF-16</h1><p>说到 UTF 必须要提到 Unicode（Universal Code 统一码），ISO 试图想创建一个全新的超语言字典，世界上所有的语言都可以通过这本字典来相互翻译。可想而知这个字典是多么的复杂，关于 Unicode 的详细规范可以参考相应文档。Unicode 是 Java 和 XML 的基础，下面详细介绍 Unicode 在计算机中的存储形式。<br>UTF-16 具体定义了 Unicode 字符在计算机中存取方法。UTF-16 用两个字节来表示 Unicode 转化格式，这个是定长的表示方法，不论什么字符都可以用两个字节表示，两个字节是 16 个 bit，所以叫 UTF-16。UTF-16 表示字符非常方便，每两个字节表示一个字符，这个在字符串操作时就大大简化了操作，这也是 Java 以 UTF-16 作为内存的字符存储格式的一个很重要的原因。 </p><h1 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h1><p>UTF-16 统一采用两个字节表示一个字符，虽然在表示上非常简单方便，但是也有其缺点，有很大一部分字符用一个字节就可以表示的现在要两个字节表示，存储空间放大了一倍，在现在的网络带宽还非常有限的今天，这样会增大网络传输的流量，而且也没必要。而 UTF-8 采用了一种变长技术，每个编码区域有不同的字码长度。不同类型的字符可以是由 1~6 个字节组成。<br>UTF-8 有以下编码规则：<br>如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASCII 字符（00 - 7F）。可见，所有 ASCII 编码已经是 UTF-8 了。<br>如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。<br>如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节<br>Java 中需要编码的场景<br>前面描述了常见的几种编码格式，下面将介绍 Java 中如何处理对编码的支持，什么场合中需要编码。<br>I/O 操作中存在的编码<br>我们知道涉及到编码的地方一般都在字符到字节或者字节到字符的转换上，而需要这种转换的场景主要是在 I/O 的时候，这个 I/O 包括磁盘 I/O 和网络 I/O，关于网络 I/O 部分在后面将主要以 Web 应用为例介绍。下图是 Java 中处理 I/O 问题的接口： </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ASCII-码&quot;&gt;&lt;a href=&quot;#ASCII-码&quot; class=&quot;headerlink&quot; title=&quot;ASCII 码&quot;&gt;&lt;/a&gt;ASCII 码&lt;/h1&gt;&lt;p&gt;学过计算机的人都知道 ASCII 码，总共有 128 个，用一个字节的低 7 位表示，0&lt;del&gt;3</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2020-11-19T16:00:28.861Z</published>
    <updated>2020-11-19T16:00:28.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全部变量"><a href="#全部变量" class="headerlink" title="全部变量"></a>全部变量</h1><p>如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文件里调用该变量。</p><h1 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h1><p>局部变量的作用域可以通过代码块（用大括号括起来的部分）判断</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">下面的例子同样有三个不同的 x 变量，每个声明在不同的词法域，一个在函数体词法域，一个在 for 隐式的初始化词法域，一个在 for 循环体词法域；只有两个块是显式创建的：</span><br><span class="line">纯文本复制</span><br><span class="line">func main() &#123;</span><br><span class="line">    x :&#x3D; &quot;hello&quot;</span><br><span class="line">    for _, x :&#x3D; range x &#123;</span><br><span class="line">        x :&#x3D; x + &#39;A&#39; - &#39;a&#39;</span><br><span class="line">        fmt.Printf(&quot;%c&quot;, x) &#x2F;&#x2F; &quot;HELLO&quot; (每次迭代一个字母)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;全部变量&quot;&gt;&lt;a href=&quot;#全部变量&quot; class=&quot;headerlink&quot; title=&quot;全部变量&quot;&gt;&lt;/a&gt;全部变量&lt;/h1&gt;&lt;p&gt;如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包甚至外部包（被导出后）使用，不管你声明在哪个源文件里或在哪个源文</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80%E7%B1%BB%E6%A6%82%E8%AE%BA/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80%E7%B1%BB%E6%A6%82%E8%AE%BA/</id>
    <published>2020-11-19T16:00:28.861Z</published>
    <updated>2020-11-19T16:00:28.862Z</updated>
    
    <content type="html"><![CDATA[<p>函数简单的说就是从A(定义域)到B(值域)的一个映射过程</p><h1 id="面向过程编程"><a href="#面向过程编程" class="headerlink" title="面向过程编程"></a>面向过程编程</h1><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><pre><code>任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</code></pre><h1 id="面向消息编程等"><a href="#面向消息编程等" class="headerlink" title="面向消息编程等"></a>面向消息编程等</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;函数简单的说就是从A(定义域)到B(值域)的一个映射过程&lt;/p&gt;
&lt;h1 id=&quot;面向过程编程&quot;&gt;&lt;a href=&quot;#面向过程编程&quot; class=&quot;headerlink&quot; title=&quot;面向过程编程&quot;&gt;&lt;/a&gt;面向过程编程&lt;/h1&gt;&lt;h1 id=&quot;面向对象编程&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93/</id>
    <published>2020-11-19T16:00:28.861Z</published>
    <updated>2020-11-19T16:00:28.861Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="联合体"><a href="#联合体" class="headerlink" title="联合体"></a>联合体</h1><p>用途：使几个不同类型的变量共占一段内存(相互覆盖)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">union abc&#123;  </span><br><span class="line">          int i;  </span><br><span class="line">          char m;  </span><br><span class="line">         &#125;;  </span><br></pre></td></tr></table></figure><ol><li>在联合体abc中，整型量i和字符m公用同一内存位置。</li><li>当一个联合被说明时，编译程序自动地产生一个变量，其长度为联合中最大的变量长度。</li><li></li></ol><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>  是一种构造数据类型<br>用途：把不同类型的数据组合成一个整体——-自定义数据类型</p><p>结构体变量所占内存长度是各成员占的内存长度的总和。</p><p>共同体变量所占内存长度是各最长的成员占的内存长度。</p><p>共同体每次只能存放哪个的一种！！</p><p>共同体变量中起作用的成员是最后一次存放的成员，在存入新的成员后原有的成员失去了作用！</p><h1 id="Struct与Union主要有以下区别"><a href="#Struct与Union主要有以下区别" class="headerlink" title="Struct与Union主要有以下区别:"></a>Struct与Union主要有以下区别:</h1><ol><li><p>struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员, 而struct的所有成员都存在。在struct中，各成员都占有自己的内存空间，它们是同时存在的。一个struct变量的总长度等于所有成员长度之和。在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在。Union变量的长度等于最长的成员的长度。</p></li><li><p>对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于struct的不同成员赋值是互不影响的。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;联合体&quot;&gt;&lt;a href=&quot;#联合体&quot; class=&quot;headerlink&quot; title=&quot;联合体&quot;&gt;&lt;/a&gt;联合体&lt;/h1&gt;&lt;p&gt;用途：使几个不同类型的变量共占一段内存(相互覆盖)&lt;/p&gt;
&lt;figure class=&quot;highligh</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%80%A7%E8%83%BD%E8%B0%83%E6%A0%91+%E9%83%A8%E7%BD%B2+%E6%B5%8B%E8%AF%95/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%80%A7%E8%83%BD%E8%B0%83%E6%A0%91+%E9%83%A8%E7%BD%B2+%E6%B5%8B%E8%AF%95/</id>
    <published>2020-11-19T16:00:28.860Z</published>
    <updated>2020-11-19T16:00:28.860Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="php-ini文件"><a href="#php-ini文件" class="headerlink" title="php.ini文件"></a>php.ini文件</h1><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><p>php.ini文件中的memory_limit设置单个php进程可以使用的系统内存最大值<br>分配原则<br>1.一共能分给php多少内存？（ngnix，MYSQL，memcache也要耗内存）<br>2.单个php进程平均耗多少？<br>3.能负担多少PHP-FPM内存？</p><h1 id="zend-OPcache（操作码缓存）"><a href="#zend-OPcache（操作码缓存）" class="headerlink" title="zend OPcache（操作码缓存）"></a>zend OPcache（操作码缓存）</h1><h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h1 id="最长执行时间-max-execution-time"><a href="#最长执行时间-max-execution-time" class="headerlink" title="最长执行时间(max_execution_time)"></a>最长执行时间(max_execution_time)</h1><h1 id="处理会话（缓存存会话-可扩展）"><a href="#处理会话（缓存存会话-可扩展）" class="headerlink" title="处理会话（缓存存会话 可扩展）"></a>处理会话（缓存存会话 可扩展）</h1><h1 id="缓存输出"><a href="#缓存输出" class="headerlink" title="缓存输出"></a>缓存输出</h1><h1 id="测试百科"><a href="#测试百科" class="headerlink" title="测试百科"></a>测试百科</h1><p>分类：</p><h2 id="单元测试（PHPUnit）搭配Xdebug（代码覆盖率）"><a href="#单元测试（PHPUnit）搭配Xdebug（代码覆盖率）" class="headerlink" title="单元测试（PHPUnit）搭配Xdebug（代码覆盖率）"></a>单元测试（PHPUnit）搭配Xdebug（代码覆盖率）</h2><h2 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h2><h1 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h1><h2 id="测试驱动开发（TDD）（小步向前）"><a href="#测试驱动开发（TDD）（小步向前）" class="headerlink" title="测试驱动开发（TDD）（小步向前）"></a>测试驱动开发（TDD）（小步向前）</h2><h2 id="行为驱动开发（BDD）"><a href="#行为驱动开发（BDD）" class="headerlink" title="行为驱动开发（BDD）"></a>行为驱动开发（BDD）</h2><h1 id="使用Travis-CI持续测试（自动化非常赞）"><a href="#使用Travis-CI持续测试（自动化非常赞）" class="headerlink" title="使用Travis CI持续测试（自动化非常赞）"></a>使用Travis CI持续测试（自动化非常赞）</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;php-ini文件&quot;&gt;&lt;a href=&quot;#php-ini文件&quot; class=&quot;headerlink&quot; title=&quot;php.ini文件&quot;&gt;&lt;/a&gt;php.ini文件&lt;/h1&gt;&lt;h1 id=&quot;内存&quot;&gt;&lt;a href=&quot;#内存&quot; class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2020-11-19T16:00:28.860Z</published>
    <updated>2020-11-19T16:00:28.861Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一般文件上传的原理"><a href="#一般文件上传的原理" class="headerlink" title="一般文件上传的原理"></a>一般文件上传的原理</h1><h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一.概述"></a>一.概述</h2><p> Struts/Spring MVC 文件上传实现都是基于Commons-fileupload，但背后的原理，大多数估计没有关注，最近阅读Commons-fileupload源码也发现，只有基础才是最重要的，万变不离其宗，在it领域不然会被漫天的新技术，冲昏了头，不知所措，下面开始。</p><h2 id="二-HTTP报文"><a href="#二-HTTP报文" class="headerlink" title="二.HTTP报文"></a>二.HTTP报文</h2><p>1.要想理解文件上传，先要对HTTP报文有一个基本的了解<br>2.HTTP报文是简单的格式化数据块，每条报文都包含来自客户端（如浏览器）的请求，或者来自服务器的响应<br>3.HTTP报文由3部分组成<br>起始行                  - 对报文的描述，所有的HTTP报文都以一个起始行作为开始，即报文的第一行就是起始行<br>首部                     - 可以有0或多个首部字段，每个首部 字段都包含一个名字和一个值，首部字段后是\r\n，首部以一个空行\r\n结束<br>实体的主体部分   - 首部恐婚之后就是可选的报文实体，实体的主体是HTTP报文的负荷，传输的内容就在实体的主体中</p><p><img src="https://img-blog.csdn.net/20170904123625516?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlwaW5nYW5x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p><p><img src="https://img-blog.csdn.net/20170905214936101?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlwaW5nYW5x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p><p><img src="https://img-blog.csdn.net/20170905215154085?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGlwaW5nYW5x/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>1.TCP为HTTP提供了一条可靠的比特传输管道。从TCP一端填入的字节会从另一端以原有的顺序、正确的传送出来，TCP提供了：</p><p>无差错的数据传输<br>按序传输 - 数据总是按照发送的顺序到达<br>未分段的数据流 - 可以在任何时刻以任意尺寸将数据发送出去<br>2.HTTP要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP连接按序传输，TCP收到数据流后，会将数据流砍成被称作段的小数据块，并将段封装在IP分组中，通过因特网传输。所有这些工作都是由TCP/IP软件完成的，HTTP程序员什么也看不见</p><p>3.只要建立了TCP连接，客户端与服务器之间的报文交换就不会丢失，不会被破坏，也不会在接收时出现错序了。</p><h1 id="php的文件上传"><a href="#php的文件上传" class="headerlink" title="php的文件上传"></a>php的文件上传</h1><p>　　将客户端的文件上传到服务器，再将服务器的临时文件上传到指定目录</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一般文件上传的原理&quot;&gt;&lt;a href=&quot;#一般文件上传的原理&quot; class=&quot;headerlink&quot; title=&quot;一般文件上传的原理&quot;&gt;&lt;/a&gt;一般文件上传的原理&lt;/h1&gt;&lt;h2 id=&quot;一-概述&quot;&gt;&lt;a href=&quot;#一-概述&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B/</id>
    <published>2020-11-19T16:00:28.860Z</published>
    <updated>2020-11-19T16:00:28.860Z</updated>
    
    <content type="html"><![CDATA[<p>PHP 默认并不支持多线程，要使用多线程需要安装 pthread 扩展  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PHP 默认并不支持多线程，要使用多线程需要安装 pthread 扩展  &lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E7%9A%84%E5%BA%95%E5%B1%82+OpCache/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E7%9A%84%E5%BA%95%E5%B1%82+OpCache/</id>
    <published>2020-11-19T16:00:28.859Z</published>
    <updated>2020-11-19T16:00:28.860Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="php的理解"><a href="#php的理解" class="headerlink" title="php的理解"></a>php的理解</h1><p>PHP是一种适用于web开发的动态语言。具体点说，就是一个用C语言实现包含大量组件的软件框架。更狭义点看，可以把它认为是一个强大的UI框架。</p><h2 id="PHP代码的执行过程"><a href="#PHP代码的执行过程" class="headerlink" title="PHP代码的执行过程:"></a>PHP代码的执行过程:</h2><p><img src="https://images2018.cnblogs.com/blog/592892/201804/592892-20180414110927385-1112518846.png" alt="image"></p><ul><li>Parse。语法分析阶段。</li><li>Compile。编译产出opcode中间码。</li><li>Execute。运行，动态运行进行输出。<br>  由于PHP是个解释型语言执行的时候先得把程序读进来，然后由Zend引擎编译成opcode。最后Zend虚拟机顺次执行这些opcode（指令）完成操作。因此我们可 以把这个Opcode缓存起来，下次就能避免重新编译了。<h3 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言:"></a>编译型语言:</h3>对于C语言,C++, 编译成机器码(二进制)来运行.<br>java语言, 把.java编译成 .class,称为bytecode, 由jvm来运行. <h3 id="解释语言"><a href="#解释语言" class="headerlink" title="解释语言:"></a>解释语言:</h3>解释器解释执行. 典型的如 linux shell.<br>解释器逐行来执行命令.</li></ul><p>PHP稍有特殊之处,虽然是一个脚本语言,但不是靠解释器解释.<br>==而是 zend 虚拟机,屏蔽了操作系统的区别. ==<br>php代码编译成opcode, 由zend虚拟机来执行opcode.</p><p><img src="https://img-blog.csdn.net/20161203142152200" alt="image"></p><p>PHP变量的底层实现:<br>我们解压PHP的源码包, 看到如下的目录 </p><p> <img src="https://img-blog.csdn.net/20161203142245233" alt="image"><br>其中,<br>最核心的—Zend目录, 这是zend虚拟的实现. 包括栈,数据类型,编译器等,都在这实现.<br>最主要的main –PHP的一些内建函数,最主要函数都在这里放着.<br>最大的一个目录 ext – PHP的扩展.</p><p>PHP的大部分功能,都是以extenstion形式来完成的.<br>如果你开发了一个扩展,也放在ext目录下.</p><h1 id="PHP中有8种数据类型-为什么zval-gt-value-联合体中-只有5种"><a href="#PHP中有8种数据类型-为什么zval-gt-value-联合体中-只有5种" class="headerlink" title="PHP中有8种数据类型,为什么zval-&gt;value 联合体中,只有5种?"></a>PHP中有8种数据类型,为什么zval-&gt;value 联合体中,只有5种?</h1><p>答:<br>1: NULL,直接 zval-&gt;type = IS_NULL,就可以表示,不必设置 value的值.<br>2: BOOL型 , zval-&gt;type = IS_BOOL, 再设置 zval.value.lval = 1/0;<br>3: Resourc型 ,资源型 往往是服务器上打开的一个接口,如果 文件读取接口.<br>zval-&gt;type = IS_RESOURCE, zval-&gt;tyoe.lval = 服务器上打开的接口的编号</p><h1 id="PHP的设计理念及特点"><a href="#PHP的设计理念及特点" class="headerlink" title="PHP的设计理念及特点"></a>PHP的设计理念及特点</h1><ol><li>多进程模型：由于PHP是多进程模型，不同请求间互不干涉，这样保证了一个请求挂掉不会对全盘服务造成影响，当然，随着时代发展，PHP也早已支持多线程模型。</li><li>弱类型语言：和C/C++、Java、C#等语言不同，PHP是一门弱类型语言。一个变量的类型并不是一开始就确定不变，运行中才会确定并可能发生隐式或显式的类型转换，这种机制的灵活性在web开发中非常方便、高效，具体会在后面PHP变量中详述。</li><li>引擎(Zend)+组件(ext)的模式降低内部耦合。</li><li>中间层(sapi)隔绝web server和PHP。</li><li>语法简单灵活，没有太多规范。缺点导致风格混杂，但再差的程序员也不会写出太离谱危害全局的程序。<h1 id="php-四层体系"><a href="#php-四层体系" class="headerlink" title="php 四层体系"></a>php 四层体系</h1><img src="http://ww2.sinaimg.cn/large/7cc829d3gw1exyap8boh7j20ee0ep0tj.jpg" alt="image"><h2 id="Zend引擎【编译为可执行的opcode】："><a href="#Zend引擎【编译为可执行的opcode】：" class="headerlink" title="Zend引擎【编译为可执行的opcode】："></a>Zend引擎【编译为可执行的opcode】：</h2></li><li>Zend整体用纯C实现，是PHP的内核部分，它将PHP代码翻译（词法、语法解析等一系列编译过程）为可执行opcode的处理并实现相应的处理方法、实现了基本的数据结构（如hashtable、oo）、内存分配及管理、提供了相应的api方法供外部调用，是一切的核心，所有的外围功能均围绕Zend实现。<h2 id="Extensions【内置函数等基础组建扩展】："><a href="#Extensions【内置函数等基础组建扩展】：" class="headerlink" title="Extensions【内置函数等基础组建扩展】："></a>Extensions【内置函数等基础组建扩展】：</h2>围绕着Zend引擎，extensions通过组件式的方式提供各种基础服务，我们常见的各种内置函数（如array系列）、标准库等都是通过extension来实现，用户也可以根据需要实现自己的extension以达到功能扩展、性能优化等目的（如贴吧正在使用的PHP中间层、富文本解析就是extension的典型应用）。<h2 id="Sapi：Server-Application-Programming-Interface"><a href="#Sapi：Server-Application-Programming-Interface" class="headerlink" title="Sapi：Server Application Programming Interface"></a>Sapi：Server Application Programming Interface</h2>也就是服务端应用编程接口，Sapi通过一系列钩子函数，使得PHP可以和外围交互数据，这是PHP非常优雅和成功的一个设计，通过sapi成功的将PHP本身和上层应用解耦隔离，PHP可以不再考虑如何针对不同应用进行兼容，而应用本身也可以针对自己的特点实现不同的处理方式。<br>如前所述，Sapi通过通过一系列的接口，使得外部应用可以和PHP交换数据并可以根据不同应用特点实现特定的处理方法，我们常见的一些sapi有：</li></ol><h3 id="apache2handler【apache】："><a href="#apache2handler【apache】：" class="headerlink" title="apache2handler【apache】："></a>apache2handler【apache】：</h3><p>这是以apache作为webserver，采用mod_PHP模式运行时候的处理方式，也是现在应用最广泛的一种。</p><h3 id="cgi【ngnix】："><a href="#cgi【ngnix】：" class="headerlink" title="cgi【ngnix】："></a>cgi【ngnix】：</h3><p>这是webserver和PHP直接的另一种交互方式，也就是大名鼎鼎的fastcgi协议，在最近今年fastcgi+PHP得到越来越多的应用，也是异步webserver所唯一支持的方式。<br>cli：命令行调用的应用模式</p><h3 id="cli：命令行调用的应用模式-php-a"><a href="#cli：命令行调用的应用模式-php-a" class="headerlink" title="cli：命令行调用的应用模式 php -a"></a>cli：命令行调用的应用模式 php -a</h3><h2 id="上层应用："><a href="#上层应用：" class="headerlink" title="上层应用："></a>上层应用：</h2><p>这就是我们平时编写的PHP程序，通过不同的sapi方式得到各种各样的应用模式，如通过webserver实现web应用、在命令行下以脚本方式运行等等</p><h1 id="PHP的opcache"><a href="#PHP的opcache" class="headerlink" title="PHP的opcache"></a>PHP的opcache</h1><h2 id="什么是opcode缓存？"><a href="#什么是opcode缓存？" class="headerlink" title="什么是opcode缓存？"></a>什么是opcode缓存？</h2><p>当解释器完成对脚本代码的分析后，便将它们生成可以直接运行的中间代码，也称为操作码</p><p>（Operate Code，opcode）。Opcode cache的目地是避免重复编译，减少CPU和内存开销。</p><h2 id="为什么要使用Opcode缓存？"><a href="#为什么要使用Opcode缓存？" class="headerlink" title="为什么要使用Opcode缓存？"></a>为什么要使用Opcode缓存？</h2><p>本来的php生命周期<br><img src="https://img-blog.csdn.net/20140120175042625" alt="image"><br>加了OpCode缓存后<br><img src="https://img-blog.csdn.net/20140120175158765" alt="image"></p><h2 id="常用插件Optimizer-eAccelerator、xcache、APC"><a href="#常用插件Optimizer-eAccelerator、xcache、APC" class="headerlink" title="常用插件Optimizer+ eAccelerator、xcache、APC"></a>常用插件Optimizer+ eAccelerator、xcache、APC</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;php的理解&quot;&gt;&lt;a href=&quot;#php的理解&quot; class=&quot;headerlink&quot; title=&quot;php的理解&quot;&gt;&lt;/a&gt;php的理解&lt;/h1&gt;&lt;p&gt;PHP是一种适用于web开发的动态语言。具体点说，就是一个用C语言实现包含大量组件</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B[%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0]+%E8%BF%90%E7%AE%97%E7%AC%A6+%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%89/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B[%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0]+%E8%BF%90%E7%AE%97%E7%AC%A6+%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%89/</id>
    <published>2020-11-19T16:00:28.859Z</published>
    <updated>2020-11-19T16:00:28.859Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>PHP是弱语言类型，主要分为三类：</p><h3 id="1、标量类型：integer、string、float、boolean"><a href="#1、标量类型：integer、string、float、boolean" class="headerlink" title="1、标量类型：integer、string、float、boolean"></a>1、标量类型：integer、string、float、boolean</h3><h3 id="2、复合类型：array、object"><a href="#2、复合类型：array、object" class="headerlink" title="2、复合类型：array、object"></a>2、复合类型：array、object</h3><h3 id="3、特殊类型：resource、null"><a href="#3、特殊类型：resource、null" class="headerlink" title="3、特殊类型：resource、null"></a>3、特殊类型：resource、null</h3><h2 id="Resource-资源类型"><a href="#Resource-资源类型" class="headerlink" title="Resource 资源类型"></a>Resource 资源类型</h2><p>资源数据类型是PHP4引进的。资源是一种特殊的变量类型，保存了到外部资源的一个引用：如打开文件、数据库连接、图形画布区域等。<br>$fp = fopen(“test.txt”, “rw”);<br>var_dump($fp);<br>fclose($fp);<br>打印结果：resource(5) of type (stream)</p><p>资源ID</p><p>内核中将注册的资源变量存储在一个HashTable中，并把资源所在HashTable中的key作为资源ID。</p><p>所以，实际上PHP中的资源变量实际存储的是一个整型，通过这个ID找到HashTable中对应的资源。</p><p>由于 PHP4 Zend 引擎引进了资源计数系统，可以自动检测到一个资源不再被引用了（和 Java 一样）。这种情况下此资源使用的所有外部资源都会被垃圾回收系统释放。因此，很少需要用某些 free-result 函数来手工释放内存。</p><p>注意: 持久数据库连接比较特殊，它们不会被垃圾回收系统破坏。</p><h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>被赋值为 NULL。</p><p>尚未被赋值。</p><p>被 unset()。</p><p>因而 无法区分 $a; $b=NULL;<br>也就是说 变量未初始化 就是NULL</p><h2 id="Callback-Callable-类型"><a href="#Callback-Callable-类型" class="headerlink" title="Callback / Callable 类型"></a>Callback / Callable 类型</h2><p>一些函数如 call_user_func() 或 usort() 可以接受用户自定义的回调函数作为参数。回调函数不止可以是简单函数，还可以是对象的方法，包括静态类方法。</p><p>传递</p><p>一个 PHP 的函数以 string 类型传递其名称。可以使用任何内置或用户自定义函数，但除了语言结构例如： array() ， echo ， empty() ， eval() ， exit() ， isset() ， list() ， print 或 unset() 。</p><p>==一个已实例化的对象的方法被作为数组传递，下标 0 包含该对象，下标 1 包含方法名。==</p><p>==静态类方法也可不经实例化该类的对象而传递，只要在下标 0 中包含类名而不是对象。自 PHP 5.2.3 起，也可以传递 ‘ClassName::methodName’。==</p><p>除了普通的用户自定义函数外， create_function() 可以用来创建一个匿名回调函数。自 PHP 5.3.0 起也可传递 closure 给回调参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">&#x2F;&#x2F; An example callback function</span><br><span class="line">function  my_callback_function () &#123;</span><br><span class="line">    echo  &#39;hello world!&#39; ;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; An example callback method</span><br><span class="line">class  MyClass  &#123;</span><br><span class="line">    static function  myCallbackMethod () &#123;</span><br><span class="line">        echo  &#39;Hello World!&#39; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Type 1: Simple callback</span><br><span class="line">call_user_func ( &#39;my_callback_function&#39; ); </span><br><span class="line">&#x2F;&#x2F; Type 2: Static class method call</span><br><span class="line">call_user_func (array( &#39;MyClass&#39; ,  &#39;myCallbackMethod&#39; )); </span><br><span class="line">&#x2F;&#x2F; Type 3: Object method call</span><br><span class="line">$obj  &#x3D; new  MyClass ();</span><br><span class="line">call_user_func (array( $obj ,  &#39;myCallbackMethod&#39; ));</span><br><span class="line">&#x2F;&#x2F; Type 4: Static class method call (As of PHP 5.2.3)</span><br><span class="line">call_user_func ( &#39;MyClass::myCallbackMethod&#39; );</span><br><span class="line">&#x2F;&#x2F; Type 5: Relative static class method call (As of PHP 5.3.0)</span><br><span class="line">class  A  &#123;</span><br><span class="line">    public static function  who () &#123;</span><br><span class="line">        echo  &quot;A\n&quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class  B  extends  A  &#123;</span><br><span class="line">    public static function  who () &#123;</span><br><span class="line">        echo  &quot;B\n&quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">call_user_func (array( &#39;B&#39; ,  &#39;parent::who&#39; ));  &#x2F;&#x2F; A</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="本文档中使用的伪类型与变量"><a href="#本文档中使用的伪类型与变量" class="headerlink" title="本文档中使用的伪类型与变量"></a>本文档中使用的伪类型与变量</h2><p>本文档中使用的伪类型与变量</p><p>伪类型（pseudo -types）是PHP文档里用于指示参数可以使用的类型和值，<br>请注意，它们不是PHP语言里原生类型，<br>所以不能把伪类型用于自定义函数里面的类型约束（typehint）。</p><p>==mixed==</p><p>mixed说明一个参数可以接受多种不同的（但不一定是所有的）类型。</p><p>例如：gettype()可以接受所有的PHP类型，str_replace()可以接受字符串和数组，</p><p>==number==</p><p>number说明一个参数可以是integer或者float。</p><p>==callback==</p><p>本文档中在PHP5.4引入callable类型之前使用了callback伪类型，二者涵义完全相同，</p><p>==array|object==</p><p>array|object意思是参数既可以是array也可以是object，</p><p>==void==<br>void作为返回类型意味着函数的返回值是无用的，<br>void作为参数列表意味着函数不接受任何参数，</p><h2 id="类型转换的判别"><a href="#类型转换的判别" class="headerlink" title="类型转换的判别"></a>类型转换的判别</h2><h1 id="php中弱语言类型的底层实现"><a href="#php中弱语言类型的底层实现" class="headerlink" title="php中弱语言类型的底层实现"></a>php中弱语言类型的底层实现</h1><h2 id="变量存储结构"><a href="#变量存储结构" class="headerlink" title="变量存储结构"></a>变量存储结构</h2><p>变量的值存储到以下所示zval结构体中。 zval结构体定义在Zend/zend.h文件，其结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zval_struct zval;</span><br><span class="line">...</span><br><span class="line">struct _zval_struct &#123;</span><br><span class="line">    &#x2F;* Variable information *&#x2F;</span><br><span class="line">    zvalue_value value;     &#x2F;* value *&#x2F;</span><br><span class="line">    zend_uint refcount__gc;</span><br><span class="line">    zend_uchar type;    &#x2F;* active type *&#x2F;</span><br><span class="line">    zend_uchar is_ref__gc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>PHP使用这个结构来存储变量的所有数据。和其他编译性静态语言不同， PHP在存储变量时将PHP用户空间的变量类型也保存在同一个结构体中。这样我们就能通过这些信息获取到变量的类型。</p><p>zval结构体中有四个字段，其含义分别为：</p><p>属性名    含义    默认值<br>refcount__gc    表示引用计数    1<br>is_ref__gc    表示是否为引用    0<br>value    存储变量的值<br>type    变量具体的类型     </p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型:"></a>变量类型:</h2><p>zval结构体的type字段就是实现弱类型最关键的字段了，type的值可以为： IS_NULL、IS_BOOL、IS_LONG、IS_DOUBLE、IS_STRING、IS_ARRAY、IS_OBJECT和IS_RESOURCE 之一。 从字面上就很好理解，他们只是类型的唯一标示，根据类型的不同将不同的值存储到value字段。 除此之外，和他们定义在一起的类型还有IS_CONSTANT和IS_CONSTANT_ARRAY。</p><p>这和我们设计数据库时的做法类似，为了避免重复设计类似的表，使用一个标示字段来记录不同类型的数据。</p><h2 id="变量的值存储"><a href="#变量的值存储" class="headerlink" title="变量的值存储"></a>变量的值存储</h2><p>前面提到变量的值存储在zvalue_value联合体中，结构体定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">typedef union _zvalue_value &#123;</span><br><span class="line">    long lval;                  &#x2F;* long value *&#x2F;</span><br><span class="line">    double dval;                &#x2F;* double value *&#x2F;</span><br><span class="line">    struct &#123;</span><br><span class="line">        char *val;</span><br><span class="line">        int len;</span><br><span class="line">    &#125; str;</span><br><span class="line">    HashTable *ht;              &#x2F;* hash table value *&#x2F;</span><br><span class="line">    zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure><h3 id="字符串的类型"><a href="#字符串的类型" class="headerlink" title="字符串的类型"></a>字符串的类型</h3><p>标示和其他数据类型一样，不过在存储字符串时多了一个字符串长度的字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    char *val;</span><br><span class="line">    int len;</span><br><span class="line">&#125; str;</span><br></pre></td></tr></table></figure><h3 id="数组Array"><a href="#数组Array" class="headerlink" title="数组Array"></a>数组Array</h3><p>数组是PHP中最常用，也是最强大变量类型，它可以存储其他类型的数据，而且提供各种内置操作函数。数组的存储相对于其他变量要复杂一些， 数组的值存储在zvalue_value.ht字段中，它是一个HashTable类型的数据。 PHP的数组使用哈希表来存储关联数据。哈希表是一种高效的键值对存储结构。PHP的哈希表实现中使用了两个数据结构HashTable和Bucket。 PHP所有的工作都由哈希表实现，在下节HashTable中将进行哈希表基本概念的介绍以及PHP的哈希表实现。</p><h3 id="对象Object"><a href="#对象Object" class="headerlink" title="对象Object"></a>对象Object</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _zend_object_value &#123;</span><br><span class="line">    zend_object_handle handle;  &#x2F;&#x2F;  unsigned int类型，EG(objects_store).object_buckets的索引</span><br><span class="line">    zend_object_handlers *handlers;</span><br><span class="line">&#125; zend_object_value;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;p&gt;PHP是弱语言类型，主要分为三类：&lt;/p&gt;
&lt;h3 id=&quot;1、标量类型：integer、stri</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0+%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0+%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</id>
    <published>2020-11-19T16:00:28.859Z</published>
    <updated>2020-11-19T16:00:28.859Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$makefoo &#x3D; true;</span><br><span class="line"></span><br><span class="line">&#x2F;* 不能在此处调用foo()函数，</span><br><span class="line">   因为它还不存在，但可以调用bar()函数。*&#x2F;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">if ($makefoo) &#123;</span><br><span class="line">  function foo()</span><br><span class="line">  &#123;</span><br><span class="line">    echo &quot;I don&#39;t exist until program execution reaches me.\n&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 现在可以安全调用函数 foo()了，</span><br><span class="line">   因为 $makefoo 值为真 *&#x2F;</span><br><span class="line"></span><br><span class="line">if ($makefoo) foo();</span><br><span class="line"></span><br><span class="line">function bar()</span><br><span class="line">&#123;</span><br><span class="line">  echo &quot;I exist immediately upon program start.\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="函数参数-【三种类型传参-传递数组，引用传参，默认参数的值】"><a href="#函数参数-【三种类型传参-传递数组，引用传参，默认参数的值】" class="headerlink" title="函数参数 【三种类型传参 传递数组，引用传参，默认参数的值】"></a>函数参数 【三种类型传参 传递数组，引用传参，默认参数的值】</h2><h2 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function foo() &#123;</span><br><span class="line">    echo &quot;In foo()&lt;br &#x2F;&gt;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar($arg &#x3D; &#39;&#39;) &#123;</span><br><span class="line">    echo &quot;In bar(); argument was &#39;$arg&#39;.&lt;br &#x2F;&gt;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 echo 的包装函数</span><br><span class="line">function echoit($string)</span><br><span class="line">&#123;</span><br><span class="line">    echo $string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$func &#x3D; &#39;foo&#39;;</span><br><span class="line">$func();        &#x2F;&#x2F; This calls foo()</span><br><span class="line"></span><br><span class="line">$func &#x3D; &#39;bar&#39;;</span><br><span class="line">$func(&#39;test&#39;);  &#x2F;&#x2F; This calls bar()</span><br><span class="line"></span><br><span class="line">$func &#x3D; &#39;echoit&#39;;</span><br><span class="line">$func(&#39;test&#39;);  &#x2F;&#x2F; This calls echoit()</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="匿名函数-closures-闭包函数"><a href="#匿名函数-closures-闭包函数" class="headerlink" title="匿名函数[closures] 闭包函数"></a>匿名函数[closures] 闭包函数</h2><h3 id="匿名函数-变量赋值-从父作用域继承变量"><a href="#匿名函数-变量赋值-从父作用域继承变量" class="headerlink" title="匿名函数  变量赋值+ 从父作用域继承变量"></a>匿名函数  变量赋值+ 从父作用域继承变量</h3><p><a href="http://www.php.cn/php-weizijiaocheng-400799.html">http://www.php.cn/php-weizijiaocheng-400799.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo preg_replace_callback(&#39;~-([a-z])~&#39;, function ($match) &#123;</span><br><span class="line">&#x2F;&#x2F;例一</span><br><span class="line">&#x2F;&#x2F;在函数里定义一个匿名函数，并且调用它</span><br><span class="line">function printStr() &#123;</span><br><span class="line">  $func &#x3D; function( $str ) &#123;</span><br><span class="line">    echo $str;</span><br><span class="line">  &#125;;</span><br><span class="line">  $func( &#39;some string&#39; );</span><br><span class="line">&#125;</span><br><span class="line">printStr();</span><br><span class="line">&#x2F;&#x2F;例二</span><br><span class="line">&#x2F;&#x2F;在函数中把匿名函数返回，并且调用它</span><br><span class="line">function getPrintStrFunc() &#123;</span><br><span class="line">  $func &#x3D; function( $str ) &#123;</span><br><span class="line">    echo $str;</span><br><span class="line">  &#125;;</span><br><span class="line">  return $func;</span><br><span class="line">&#125;</span><br><span class="line">$printStrFunc &#x3D; getPrintStrFunc();</span><br><span class="line">$printStrFunc( &#39;some string&#39; );</span><br><span class="line">&#x2F;&#x2F;例三</span><br><span class="line">&#x2F;&#x2F;把匿名函数当做参数传递，并且调用它</span><br><span class="line">function callFunc( $func ) &#123;</span><br><span class="line">  $func( &#39;some string&#39; );</span><br><span class="line">&#125;</span><br><span class="line">$printStrFunc &#x3D; function( $str ) &#123;</span><br><span class="line">  echo $str;</span><br><span class="line">&#125;;</span><br><span class="line">callFunc( $printStrFunc );</span><br><span class="line">&#x2F;&#x2F;也可以直接将匿名函数进行传递。如果你了解js，这种写法可能会很熟悉</span><br><span class="line">callFunc( function( $str ) &#123;</span><br><span class="line">  echo $str;</span><br><span class="line">&#125; );</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="可以看做匿名函数"><a href="#可以看做匿名函数" class="headerlink" title="可以看做匿名函数"></a>可以看做匿名函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$numberPlusOne &#x3D; array_map(function ($number) &#123;</span><br><span class="line">    return $number +&#x3D; 1;</span><br><span class="line">&#125;, [1, 2, 3]);</span><br><span class="line"></span><br><span class="line">print_r($numberPlusOne);</span><br></pre></td></tr></table></figure><p>==附加状态==</p><p>PHP闭包不会像真正的javascrypt闭包那样自动封装应用的状态，我们必须手动调用闭包对象的 ==bindTo()== 方法或者==使用 use== 关键字，==把状态附加到PHP闭包上==。<br>==使用 use 关键字==</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Car ($name)&#123;</span><br><span class="line">  return function($statu)use($name)&#123;</span><br><span class="line">    return sprintf(&quot;Car %s is %s&quot;, $name, $statu); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 将车名封装在闭包中</span><br><span class="line">$car &#x3D; Car(&quot;bmw&quot;);</span><br><span class="line">&#x2F;&#x2F; 调用车的动作</span><br><span class="line">&#x2F;&#x2F; 输出--&gt; &quot;bmw is running&quot;</span><br><span class="line">echo $car(&quot;running&quot;);</span><br></pre></td></tr></table></figure><h3 id="闭包的好处"><a href="#闭包的好处" class="headerlink" title="闭包的好处"></a>闭包的好处</h3><p><a href="https://www.cnblogs.com/yjf512/archive/2012/10/29/2744702.html">link</a></p><h4 id="1-减少foreach的循环的代码"><a href="#1-减少foreach的循环的代码" class="headerlink" title="1 减少foreach的循环的代码"></a>1 减少foreach的循环的代码</h4><p>比如手册<a href="http://php.net/manual/en/functions.anonymous.php">http://php.net/manual/en/functions.anonymous.php</a> 中的例子Cart</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; 一个基本的购物车，包括一些已经添加的商品和每种商品的数量。</span><br><span class="line">&#x2F;&#x2F; 其中有一个方法用来计算购物车中所有商品的总价格。该方法使用了一个closure作为回调函数。</span><br><span class="line">class Cart</span><br><span class="line">&#123;</span><br><span class="line">    const PRICE_BUTTER  &#x3D; 1.00;</span><br><span class="line">    const PRICE_MILK    &#x3D; 3.00;</span><br><span class="line">    const PRICE_EGGS    &#x3D; 6.95;</span><br><span class="line"> </span><br><span class="line">    protected   $products &#x3D; array();</span><br><span class="line">     </span><br><span class="line">    public function add($product, $quantity)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;products[$product] &#x3D; $quantity;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public function getQuantity($product)</span><br><span class="line">    &#123;</span><br><span class="line">        return isset($this-&gt;products[$product]) ? $this-&gt;products[$product] :</span><br><span class="line">               FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public function getTotal($tax)</span><br><span class="line">    &#123;</span><br><span class="line">        $total &#x3D; 0.00;</span><br><span class="line">         </span><br><span class="line">        $callback &#x3D;</span><br><span class="line">            function ($quantity, $product) use ($tax, &amp;$total)</span><br><span class="line">            &#123;</span><br><span class="line">                $pricePerItem &#x3D; constant(__CLASS__ . &quot;::PRICE_&quot; .</span><br><span class="line">                    strtoupper($product));</span><br><span class="line">                $total +&#x3D; ($pricePerItem * $quantity) * ($tax + 1.0);</span><br><span class="line">            &#125;;</span><br><span class="line">         </span><br><span class="line">        array_walk($this-&gt;products, $callback); &#x2F;&#x2F;数组中的每个元素应用用户自定义函数：</span><br><span class="line">        return round($total, 2);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$my_cart &#x3D; new Cart;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 往购物车里添加条目</span><br><span class="line">$my_cart-&gt;add(&#39;butter&#39;, 1);</span><br><span class="line">$my_cart-&gt;add(&#39;milk&#39;, 3);</span><br><span class="line">$my_cart-&gt;add(&#39;eggs&#39;, 6);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 打出出总价格，其中有 5% 的销售税.</span><br><span class="line">print $my_cart-&gt;getTotal(0.05) . &quot;\n&quot;;</span><br><span class="line">&#x2F;&#x2F; The result is 54.29</span><br></pre></td></tr></table></figure><h4 id="2-减少函数的参数"><a href="#2-减少函数的参数" class="headerlink" title="2 减少函数的参数"></a>2 减少函数的参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function html ($code , $id&#x3D;&quot;&quot;, $class&#x3D;&quot;&quot;)&#123;</span><br><span class="line"> </span><br><span class="line">if ($id !&#x3D;&#x3D; &quot;&quot;) $id &#x3D; &quot; id &#x3D; \&quot;$id\&quot;&quot; ;</span><br><span class="line"> </span><br><span class="line">$class &#x3D; ($class !&#x3D;&#x3D; &quot;&quot;)? &quot; class &#x3D;\&quot;$class\&quot;&quot;:&quot;&gt;&quot;;</span><br><span class="line"> </span><br><span class="line">$open &#x3D; &quot;&lt;$code$id$class&quot;;</span><br><span class="line"> </span><br><span class="line">$close &#x3D; &quot;&lt;&#x2F;$code&gt;&quot;;</span><br><span class="line"> </span><br><span class="line">return function ($inner &#x3D; &quot;&quot;) use ($open, $close)&#123;</span><br><span class="line"> </span><br><span class="line">return &quot;$open$inner$close&quot;;&#125;;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是使用平时的方法，我们会把inner放到html函数参数中，这样不管是代码阅读还是使用都不如使用闭包</p><h4 id="3-解除递归函数"><a href="#3-解除递归函数" class="headerlink" title="3 解除递归函数"></a>3 解除递归函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $fib &#x3D; function($n) use(&amp;$fib) &#123;</span><br><span class="line">        if($n &#x3D;&#x3D; 0 || $n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">        return $fib($n - 1) + $fib($n - 2);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">   echo $fib(2) . &quot;\n&quot;; &#x2F;&#x2F; 2</span><br><span class="line">   $lie &#x3D; $fib;</span><br><span class="line">   $fib &#x3D; function()&#123;die(&#39;error&#39;);&#125;;&#x2F;&#x2F;rewrite $fib variable </span><br><span class="line">   echo $lie(5); &#x2F;&#x2F; error   because $fib is referenced by closure</span><br></pre></td></tr></table></figure><p>注意上题中的use使用了&amp;，这里不使用&amp;会出现错误fib(fib(n-1)是找不到function的（前面没有定义fib的类型）</p><p>所以想使用闭包解除循环函数的时候就需要使用</p><h4 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h4><p>如果你需要延迟绑定use里面的变量，你就需要使用引用(&amp;)，否则在定义的时候就会做一份拷贝放到use中 //理解use(&amp;$var)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$result &#x3D; 0; </span><br><span class="line"></span><br><span class="line">$one &#x3D;function() </span><br><span class="line">&#123; var_dump($result); &#125;; </span><br><span class="line"></span><br><span class="line">$two &#x3D;function()use ($result) </span><br><span class="line">&#123; var_dump($result); &#125;; </span><br><span class="line"></span><br><span class="line">$three &#x3D;function()use (&amp;$result) </span><br><span class="line">&#123; var_dump($result); &#125;; </span><br><span class="line"></span><br><span class="line">$result++; </span><br><span class="line"></span><br><span class="line">$one(); &#x2F;&#x2F; outputs NULL: $result is not in scope </span><br><span class="line">$two(); &#x2F;&#x2F; outputs int(0): $result was copied </span><br><span class="line">$three(); &#x2F;&#x2F; outputs int(1)</span><br></pre></td></tr></table></figure><h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="伪变量"><a href="#伪变量" class="headerlink" title="伪变量"></a>伪变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">  </span><br><span class="line">class human&#123;  </span><br><span class="line">      </span><br><span class="line">    public $name&#x3D;&quot;李四&quot;;  </span><br><span class="line">      </span><br><span class="line">    public function eat()&#123;  </span><br><span class="line">      </span><br><span class="line">      echo $this-&gt;name,&#39;在吃饭&#39;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public function test()&#123;  </span><br><span class="line">      </span><br><span class="line">      echo $name,&#39;在吃饭&#39;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">$li&#x3D;new human();  </span><br><span class="line">echo $li-&gt;name;&#x2F;&#x2F;李四  </span><br><span class="line">$li-&gt;eat();&#x2F;&#x2F;李四在吃饭</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="类的自动加载"><a href="#类的自动加载" class="headerlink" title="类的自动加载"></a>类的自动加载</h2><h3 id="自动加载怎么出现的"><a href="#自动加载怎么出现的" class="headerlink" title="自动加载怎么出现的"></a>自动加载怎么出现的</h3><p><a href="https://blog.csdn.net/weixin_37356656/article/details/78642520">https://blog.csdn.net/weixin_37356656/article/details/78642520</a><br>     少量的类的引用 有 require 即可<br>     __autoload()函数PHP在找不到类的时候会自动执行 但是PHP内部并没有定义这个函数，这个函数需要开发着自己定义，并且编写内部逻辑，</p><pre><code>如果项目比较大，加载每个文件都使用同样的规则显然是不现实的，那么我们可能就需要在__autoload()中编写复杂的规则逻辑来满足加载不同文件的需求。这同样会使得__autoload()函数变得复杂臃肿，难以维护管理。于是，SPL(Standard PHP Library 标准PHP类库)的自动加载机制就应时而生了。</code></pre><h3 id="自动加载的分类"><a href="#自动加载的分类" class="headerlink" title="自动加载的分类"></a>自动加载的分类</h3><h4 id="PHP自带的类的自动加载方式-autoload-到-spl-autoload-register"><a href="#PHP自带的类的自动加载方式-autoload-到-spl-autoload-register" class="headerlink" title="PHP自带的类的自动加载方式  __autoload()到 spl_autoload_register"></a>PHP自带的类的自动加载方式  __autoload()到 spl_autoload_register</h4><h5 id="autoload机制（惰性加载）的主要执行过程为："><a href="#autoload机制（惰性加载）的主要执行过程为：" class="headerlink" title="autoload机制（惰性加载）的主要执行过程为："></a>autoload机制（惰性加载）的主要执行过程为：</h5><p>检查执行器全局变量函数指针autoload_func是否是NULL；<br>如果 autoload_func==NULL ,则查找系统是否定义 __autoload() 函数，如果定义了，则执行并返回加载结果。如果没有定义，则报错并退出；<br>如果 autoload_func 不等于NULL，则直接执行 autoload_func 指向的函数加载类，此时并不检查 __autoload() 函数是否定义。</p><h5 id="spl-autoload-register（）"><a href="#spl-autoload-register（）" class="headerlink" title="spl_autoload_register（）"></a>spl_autoload_register（）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class A&#123;</span><br><span class="line">    public function test()&#123;</span><br><span class="line">        $b_object &#x3D; new B();</span><br><span class="line">        $b_object-&gt;echo_info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function __autoload($classname)&#123;</span><br><span class="line">    require $classname.&#39;.php&#39;;&#x2F;&#x2F;include &#39;b.php&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function my_autoload($classname)&#123;</span><br><span class="line">    require $classname.&#39;.php&#39;;&#x2F;&#x2F;include &#39;b.php&#39;;</span><br><span class="line">    echo &#39;my_autoload   &#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spl_autoload_register(&#39;my_autoload&#39;);</span><br><span class="line">$a_object &#x3D; new A();</span><br><span class="line">$a_object-&gt;test();</span><br><span class="line"></span><br><span class="line">结果：my_autoload  我是class B中的方法执行结果</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>可以看到，通过 spl_autoload_register（’my_autoload’），实现了 当程序执行找不到类B时，会执行 自定义的 my_autoload()函数，加载B类。实际上 spl_autoload_register（’my_autoload’） 的作用就是 把autoload_func 指针指向 my_autoload()。现在，整个PHP 自动加载过程就明白了。<br>因为SPL扩展内部自己定义了一个自动加载函数 spl_autoload(),实现了自动加载的功能，如果我们不定义自己的自动加载函数，并且程序里写了 spl_autoload_register（）（如果不传参数，必须是第一次执行才会有效）或者 spl_autoload_register（’spl_autoload’），那么autoload_func 指针就会指向内部函数 spl_autoload()。程序执行的时候如果找不到相应类就会执行该自动加载函数。</p><p>那么，SPL 是怎么实现autoload_func 指针指向不同的函数呢？<br> spl_autoload_functions() //打印autoload_functions列表<br>  spl_autoload_unregister() //注销自动加载函数<br>原来，在SPL内部定义了 一个函数 spl_autoload_call() 和 一个全局变量autoload_functions。autoload_functions本质上是一个HashTable，不过我们可以将其简单的看作一个链表，链表中的每一个元素都是一个函数指针,指向一个具有自动加载类功能的函数。</p><p>spl_autoload_call()的作用就是按顺序遍历 autoload_functions，使得autoload_func指向每个自动加载函数，如果加载成功就停止，如果不成功就继续遍历下个自动加载函数，直到加载成功或者遍历完所有的函数。</p><p>那么，autoload_functions 这个列表是谁来维护的呢？就是 spl_autoload_register() 这个函数。我们说的自动加载函数的注册，其实就是通过spl_autoload_register()把自动加载函数加入到 autoload_functions 列表。<br>相关SPL自动加载函数：<br>  spl_autoload_functions() //打印autoload_functions列表<br>  spl_autoload_unregister() //注销自动加载函数</p><h4 id="composer-自动加载"><a href="#composer-自动加载" class="headerlink" title="composer 自动加载"></a>composer 自动加载</h4><p>你有一个项目依赖于若干个库。<br>其中一些库依赖于其他库。<br>你声明你所依赖的东西。<br>Composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。</p><h4 id="PHP的Yaf框架下的自动加载方式"><a href="#PHP的Yaf框架下的自动加载方式" class="headerlink" title="PHP的Yaf框架下的自动加载方式"></a>PHP的Yaf框架下的自动加载方式</h4><h2 id="访问可见性"><a href="#访问可见性" class="headerlink" title="访问可见性"></a>访问可见性</h2><h3 id="public-protect-private"><a href="#public-protect-private" class="headerlink" title="public protect private"></a>public protect private</h3><p>public的权限最大，既可以让子类使用，也可以支持实例化之后的调用，<br>protected表示的是受保护的，访问的权限是只有在子类和本类中才可以被访问到<br>private 表示的是私有，只能够是在当前的类中可以被访问到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* Define MyClass</span><br><span class="line">*&#x2F;</span><br><span class="line">class MyClass</span><br><span class="line">&#123;</span><br><span class="line"> public $public &#x3D; &#39;Public&#39;;</span><br><span class="line"> protected $protected &#x3D; &#39;Protected&#39;;</span><br><span class="line"> private $private &#x3D; &#39;Private&#39;;</span><br><span class="line"> public function printHello()</span><br><span class="line"> &#123;</span><br><span class="line"> echo $this-&gt;public;</span><br><span class="line"> echo $this-&gt;protected;</span><br><span class="line"> echo $this-&gt;private;</span><br><span class="line"> &#125;</span><br><span class="line"> protected function pro_test()&#123;</span><br><span class="line"> var_dump(1);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">$obj &#x3D; new MyClass();</span><br><span class="line">echo $obj-&gt;public; &#x2F;&#x2F; 这行能被正常执行</span><br><span class="line">&#x2F;&#x2F;echo $obj-&gt;protected; &#x2F;&#x2F; 这行会产生一个致命错误</span><br><span class="line">&#x2F;&#x2F;echo $obj-&gt;private; &#x2F;&#x2F; 这行也会产生一个致命错误</span><br><span class="line">$obj-&gt;printHello(); &#x2F;&#x2F; 输出 Public、Protected 和 Private</span><br><span class="line">$obj-&gt;pro_test();&#x2F;&#x2F;直接报错</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注意 实例化对象 new 相当于外部调用</p><h2 id="对象继承-extend"><a href="#对象继承-extend" class="headerlink" title="对象继承 extend"></a>对象继承 extend</h2><p>extends</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extends是继承某个类，继承之后可以使用父类的方法，也可以重写父类的方法，</span><br></pre></td></tr></table></figure><p>  ==如果类被声明为final，则不能被继承==</p><h2 id="静态关键字-static"><a href="#静态关键字-static" class="headerlink" title="静态关键字 static"></a>静态关键字 static</h2><p> static的作用就是能够实现值或者方法在类中不需实例化的情况下调用，同时static修饰的变量具有与值存储的功能，<br><a href="https://www.cnblogs.com/yolo-bean/p/7739265.html">link</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class class1</span><br><span class="line">&#123;</span><br><span class="line">    public static function test()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class class2</span><br><span class="line">&#123;</span><br><span class="line">    public function test()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">静态方法调用</span><br><span class="line">class1::test(); </span><br><span class="line">非静态方法调用</span><br><span class="line">$c2 &#x3D; new class2(); </span><br><span class="line">$c2-&gt;test();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>静态是随着累的加载而加载的  也就是说类只要存在了，那么静态就存在了，而静态是优先于对象存在的  ，你要访问非静态的东西，也就是非静态的成员（包括变量和方法），非静态的东西还没存在你怎么访问的到</p><p><a href="https://blog.csdn.net/zealfory/article/details/78913084">https://blog.csdn.net/zealfory/article/details/78913084</a><br><a href="https://blog.csdn.net/qq_33774822/article/details/61197364">https://blog.csdn.net/qq_33774822/article/details/61197364</a></p><h2 id="abstract-抽象类"><a href="#abstract-抽象类" class="headerlink" title="abstract 抽象类"></a>abstract 抽象类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抽象方法是只有方法声明，而没有方法的实现内容。</span><br></pre></td></tr></table></figure><p>abstract有以下的这些特征：</p><ol><li><p>只要类中有至少一个方法使用了abstract关键字，那么这个类是abstract，要加上相应的关键字</p></li><li><p>抽象方法，只有方法的声明部分，没有方法体。</p></li></ol><p>但是在我看来，abstract在实际的应用中有这样的几种场景</p><ol><li><p>多人编程的时候规范公共部分的命名规则（不做任何说明，原理跟interface一样）</p></li><li><p>实现不让父级直接实例化使用</p></li></ol><p>==抽象类不能被实例化==，通常是将抽象方法做为子类方法重写使用的，且要把继承的抽象类里的方法都实现</p><h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface即PHP接口，并用关键字implements来实现接口中方法，且必须完全实现。 否则报错 类可以实现多个接口，用逗号来分隔多个接口的名称。</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">#### 抽象类和接口的区别</span><br><span class="line">接口是一个特殊的抽象类，也可以看作是一个模型的规范，接口与抽象类大致区别如下：</span><br><span class="line"></span><br><span class="line">1，一个子类如果implements一个接口，就必须实现接口中的所有方法（不管是否需要）；如果是继承一个抽象类，只需要实现需要的方法即可</span><br><span class="line"></span><br><span class="line">2，如果一个接口中定义的方法名改变了，那么所有市县次接口的子类需要同更新方法名，而抽象类中如果方法名改变了，其子类对应的方法名将不受影响，只是变成了一个新的方法而已</span><br><span class="line"></span><br><span class="line">3，抽象类只能单继承，当一个子类需要实现的功能需要集成多个父类，就必须适用接口</span><br><span class="line">### 性状 trait （类似多继承）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作用有两个：</span><br><span class="line">1. 表明类可以做什么（像是接口）</span><br><span class="line">2. 提供模块化实现（像是类）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><?phptrait Hello {    public function getHello()    {        echo "Hello";    }}trait World {    public function getWorld()    {        echo "World";    }}class HelloWorld {    use Hello, World;    public function sayHelloWorld()    {        echo "!";    }}$hw = new HelloWorld();$hw->getHello();$hw->getWorld();$hw->sayHelloWorld();?><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编写通用根类，实现基本功能，扩展根类</span><br><span class="line">DRY原则（DONNOT Repeat Yourself）</span><br><span class="line">## 匿名类和重载 可以遍历对象（php5）</span><br><span class="line"></span><br></pre></td></tr></table></figure><?php// PHP 7 之前的代码class Logger{    public function log($msg)    {        echo $msg;    }}$util->setLogger(new Logger());// 使用了 PHP 7+ 后的代码$util->setLogger(new class {    public function log($msg)    {        echo $msg;    }});<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">## 魔术方法 __（两个下划线）开头的类方法保留为魔术方法</span><br><span class="line">PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀</span><br><span class="line">_construct()， __destruct()，</span><br><span class="line">__call()， 你调用的方法不存在的时候，会解释器会调用__call方法</span><br><span class="line">__callStatic()， 当调用的静态方法不存在或权限不足时，会自动调用__callStatic方法。</span><br><span class="line">__get()，</span><br><span class="line">__set()， </span><br><span class="line">__isset()，</span><br><span class="line">__unset()， </span><br><span class="line">__sleep()， 可以用于清理对象</span><br><span class="line">__wakeup()， 例如重新建立数据库连接，或执行其它初始化操作。</span><br><span class="line">__toString()，</span><br><span class="line">__invoke()，以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用</span><br><span class="line">__set_state()， </span><br><span class="line">__clone()  克隆</span><br><span class="line">__debugInfo() 执行var_dump()方法的时候会调用__debugInfo()方法</span><br><span class="line">## final </span><br><span class="line">Final 关键字</span><br><span class="line">PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。</span><br><span class="line">## 对象复制 clone</span><br><span class="line"></span><br></pre></td></tr></table></figure><?phpclass a{    public $v = 1;}$obj = new a();// 1. clone方式// $copy_obj = clone $obj;// 2. 标识赋值方式// $copy_obj = $obj;// 3. 引用赋值方式// $copy_obj = &$obj;$copy_obj->v = 2;echo '原对象的v属性等于' . $obj1->v;echo '<br />';echo '复制对象的v属性等于' . $obj2->v;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## 类型约束 指定类型</span><br><span class="line">PHP 5 可以使用类型约束。函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组（PHP 5.1 起）或者 callable（PHP 5.4 起）。不过如果使用 NULL 作为参数的默认值，那么在调用函数的时候依然可以使用 NULL 作为实参。</span><br><span class="line"></span><br><span class="line">如果一个类或接口指定了类型约束，则其所有的子类或实现也都如此。</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;函数调用的参数与定义的参数类型不一致时，会抛出一个可捕获的致命错误。&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">类型约束不能用于标量类型如 int 或 string。Traits 也不允许。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><?php//如下面的类class MyClass{    /**     * 测试函数     * 第一个参数必须为 OtherClass 类的一个对象     */    public function test(OtherClass $otherclass) {        echo $otherclass->var;    }    /**     * 另一个测试函数     * 第一个参数必须为数组      */    public function test_array(array $input_array) {        print_r($input_array);    }}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 后期静态绑定 </span><br><span class="line"></span><br></pre></td></tr></table></figure><?phpclass A {    public static function foo() {        static::who();    }    public static function who() {        echo __CLASS__."\n";    }}class B extends A {    public static function test() {        A::foo();        parent::foo();        self::foo();    }    public static function who() {        echo __CLASS__."\n";    }}class C extends B {    public static function who() {        echo __CLASS__."\n";    }}C::test();?><p>以上例程会输出：<br>A<br>C<br>C</p><p>```</p><h2 id="对象和引用-amp-序列化和反序列化"><a href="#对象和引用-amp-序列化和反序列化" class="headerlink" title="对象和引用&amp;  序列化和反序列化"></a>对象和引用&amp;  序列化和反序列化</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;函数&quot;&gt;&lt;a href=&quot;#函数&quot; class=&quot;headerlink&quot; title=&quot;函数&quot;&gt;&lt;/a&gt;函数&lt;/h1&gt;&lt;h2 id=&quot;用户自定义函数&quot;&gt;&lt;a href=&quot;#用户自定义函数&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%B8%83%E3%80%81%E5%AE%89%E5%85%A8%E8%8C%83%E7%95%B4%EF%BC%88sql%E6%B3%A8%E5%85%A5%20xxs%20crsf%E7%AD%89%EF%BC%89/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%B8%83%E3%80%81%E5%AE%89%E5%85%A8%E8%8C%83%E7%95%B4%EF%BC%88sql%E6%B3%A8%E5%85%A5%20xxs%20crsf%E7%AD%89%EF%BC%89/</id>
    <published>2020-11-19T16:00:28.858Z</published>
    <updated>2020-11-19T16:00:28.859Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="数据库安全"><a href="#数据库安全" class="headerlink" title="数据库安全"></a>数据库安全</h1><h2 id="php-连接mysql的三种方式"><a href="#php-连接mysql的三种方式" class="headerlink" title="php 连接mysql的三种方式"></a>php 连接mysql的三种方式</h2><h3 id="PHP的MySQL扩展"><a href="#PHP的MySQL扩展" class="headerlink" title="PHP的MySQL扩展"></a>PHP的MySQL扩展</h3><p>太古老 高版本不支持<br>本扩展自 PHP 5.5.0 起已废弃，并在将来会被移除），PHP原生的方式去连接数据库，是面向过程的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$mysql_conf &#x3D; array(</span><br><span class="line">    &#39;host&#39;    &#x3D;&gt; &#39;127.0.0.1:3306&#39;, </span><br><span class="line">    &#39;db&#39;      &#x3D;&gt; &#39;test&#39;, </span><br><span class="line">    &#39;db_user&#39; &#x3D;&gt; &#39;root&#39;, </span><br><span class="line">    &#39;db_pwd&#39;  &#x3D;&gt; &#39;root&#39;, </span><br><span class="line">    );</span><br><span class="line">$mysql_conn &#x3D; @mysql_connect($mysql_conf[&#39;host&#39;], $mysql_conf[&#39;db_user&#39;], $mysql_conf[&#39;db_pwd&#39;]);</span><br><span class="line">if (!$mysql_conn) &#123;</span><br><span class="line">    die(&quot;could not connect to the database:\n&quot; . mysql_error());&#x2F;&#x2F;诊断连接错误</span><br><span class="line">&#125;</span><br><span class="line">mysql_query(&quot;set names &#39;utf8&#39;&quot;);&#x2F;&#x2F;编码转化</span><br><span class="line">$select_db &#x3D; mysql_select_db($mysql_conf[&#39;db&#39;]);</span><br><span class="line">if (!$select_db) &#123;</span><br><span class="line">    die(&quot;could not connect to the db:\n&quot; .  mysql_error());</span><br><span class="line">&#125;</span><br><span class="line">$sql &#x3D; &quot;select * from user;&quot;;</span><br><span class="line">$res &#x3D; mysql_query($sql);</span><br><span class="line">if (!$res) &#123;</span><br><span class="line">    die(&quot;could get the res:\n&quot; . mysql_error());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">while ($row &#x3D; mysql_fetch_assoc($res)) &#123;</span><br><span class="line">    print_r($row);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mysql_close($mysql_conn);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="PHP的mysqli扩展"><a href="#PHP的mysqli扩展" class="headerlink" title="PHP的mysqli扩展"></a>PHP的mysqli扩展</h3><p>优点：面向对象接口 、prepared语句支持、多语句执行支持、事务支持 、增强的调试能力、嵌入式服务支持 、预处理方式完全解决了sql注入的问题。<br>缺点：就是只支持mysql数据库。如果你要是不操作其他的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$mysql_conf &#x3D; array(</span><br><span class="line">    &#39;host&#39;    &#x3D;&gt; &#39;127.0.0.1:3306&#39;, </span><br><span class="line">    &#39;db&#39;      &#x3D;&gt; &#39;test&#39;, </span><br><span class="line">    &#39;db_user&#39; &#x3D;&gt; &#39;root&#39;, </span><br><span class="line">    &#39;db_pwd&#39;  &#x3D;&gt; &#39;joshua317&#39;, </span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">$mysqli &#x3D; @new mysqli($mysql_conf[&#39;host&#39;], $mysql_conf[&#39;db_user&#39;], $mysql_conf[&#39;db_pwd&#39;]);</span><br><span class="line">if ($mysqli-&gt;connect_errno) &#123;</span><br><span class="line">    die(&quot;could not connect to the database:\n&quot; . $mysqli-&gt;connect_error);&#x2F;&#x2F;诊断连接错误</span><br><span class="line">&#125;</span><br><span class="line">$mysqli-&gt;query(&quot;set names &#39;utf8&#39;;&quot;);&#x2F;&#x2F;编码转化</span><br><span class="line">$select_db &#x3D; $mysqli-&gt;select_db($mysql_conf[&#39;db&#39;]);</span><br><span class="line">if (!$select_db) &#123;</span><br><span class="line">    die(&quot;could not connect to the db:\n&quot; .  $mysqli-&gt;error);</span><br><span class="line">&#125;$sql &#x3D; &quot;select uid from user where name &#x3D; &#39;joshua&#39;;&quot;;</span><br><span class="line">$res &#x3D; $mysqli-&gt;query($sql);</span><br><span class="line">if (!$res) &#123;</span><br><span class="line">    die(&quot;sql error:\n&quot; . $mysqli-&gt;error);</span><br><span class="line">&#125;</span><br><span class="line"> while ($row &#x3D; $res-&gt;fetch_assoc()) &#123;</span><br><span class="line">        var_dump($row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">$res-&gt;free();</span><br><span class="line">$mysqli-&gt;close();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="PHP数据对象-PDO-【功能类似于JDBC、ODBC、DBI】-解决了sql注入的问题"><a href="#PHP数据对象-PDO-【功能类似于JDBC、ODBC、DBI】-解决了sql注入的问题" class="headerlink" title="PHP数据对象(PDO) 【功能类似于JDBC、ODBC、DBI】 解决了sql注入的问题"></a>PHP数据对象(PDO) 【功能类似于JDBC、ODBC、DBI】 解决了sql注入的问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$mysql_conf &#x3D; array(</span><br><span class="line">    &#39;host&#39;    &#x3D;&gt; &#39;127.0.0.1:3306&#39;, </span><br><span class="line">    &#39;db&#39;      &#x3D;&gt; &#39;test&#39;, </span><br><span class="line">    &#39;db_user&#39; &#x3D;&gt; &#39;root&#39;, </span><br><span class="line">    &#39;db_pwd&#39;  &#x3D;&gt; &#39;joshua317&#39;, </span><br><span class="line">    );</span><br><span class="line">$pdo &#x3D; new PDO(&quot;mysql:host&#x3D;&quot; . $mysql_conf[&#39;host&#39;] . &quot;;dbname&#x3D;&quot; . $mysql_conf[&#39;db&#39;], $mysql_conf[&#39;db_user&#39;], $mysql_conf[&#39;db_pwd&#39;]);&#x2F;&#x2F;创建一个pdo对象</span><br><span class="line">$pdo-&gt;exec(&quot;set names &#39;utf8&#39;&quot;);</span><br><span class="line">$sql &#x3D; &quot;select * from user where name &#x3D; ?&quot;;</span><br><span class="line">$stmt &#x3D; $pdo-&gt;prepare($sql);</span><br><span class="line">$stmt-&gt;bindValue(1, &#39;joshua&#39;, PDO::PARAM_STR);</span><br><span class="line">$rs &#x3D; $stmt-&gt;execute();</span><br><span class="line">if ($rs) &#123;</span><br><span class="line">    &#x2F;&#x2F; PDO::FETCH_ASSOC 关联数组形式</span><br><span class="line">    &#x2F;&#x2F; PDO::FETCH_NUM 数字索引数组形式</span><br><span class="line">    while ($row &#x3D; $stmt-&gt;fetch(PDO::FETCH_ASSOC)) &#123;</span><br><span class="line">        var_dump($row);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$pdo &#x3D; null;&#x2F;&#x2F;关闭连接</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="数据库安全采取的手段"><a href="#数据库安全采取的手段" class="headerlink" title="数据库安全采取的手段"></a>数据库安全采取的手段</h2><h3 id="预防SQL-注入"><a href="#预防SQL-注入" class="headerlink" title="预防SQL 注入"></a>预防SQL 注入</h3><h4 id="在服务器端配置"><a href="#在服务器端配置" class="headerlink" title="在服务器端配置"></a>在服务器端配置</h4><p>(1) 打开php的安全模式<br>但是默认的php.ini是没有打开安全模式的，我们把它打开：</p><p>safe_mode = on</p><p>(2) 用户组安全</p><p>当safe_mode打开时，safe_mode_gid被关闭，那么php脚本能够对文件进行访问，而且相同<br>safe_mode_gid = off</p><p>(3) 安全模式下执行程序主目录</p><p>(4) 安全模式下包含文件</p><p>如果要在安全模式下包含某些公共文件，那么就修改一下选项：</p><p>safe_mode_include_dir = D:/usr/www/include/</p><p>(5) 控制php脚本能访问的目录</p><p>使用open_basedir选项能够控制PHP脚本只能访问指定的目录，这样能够避免PHP脚本访问</p><p>不应该访问的文件，一定程度上限制了phpshell的危害，我们一般可以设置为只能访问网站目录：</p><p>open_basedir = D:/usr/www</p><p>(6) 关闭危险函数</p><p>如果你要禁止任何文件和目录的操作，那么可以关闭很多文件操作</p><p>disable_functions = chdir,chroot,dir,getcwd,opendir,readdir,scandir,fopen,unlink,delete,copy,mkdir, rmdir,rename,file,file_get_contents,fputs,fwrite,chgrp,chmod,chown</p><p>以上只是列了部分不叫常用的文件处理函数，你也可以把上面执行命令函数和这个函数结合，</p><p>就能够抵制大部分的phpshell了。</p><p>(7) 关闭PHP版本信息在http头中的泄漏</p><p>我们为了防止黑客获取服务器中php版本的信息，可以关闭该信息斜路在http头中：</p><p>expose_php = Off</p><p>(8) 关闭注册全局变量</p><p>在PHP中提交的变量，包括使用POST或者GET提交的变量，都将自动注册为全局变量，能够直接访问，</p><p>这是对服务器非常不安全的，所以我们不能让它注册为全局变量，就把注册全局变量选项关闭：</p><p>register_globals = Off</p><p>(9) 打开magic_quotes_gpc来防止SQL注入</p><p>SQL注入是非常危险的问题，小则网站后台被入侵，重则整个服务器沦陷，</p><p>所以一定要小心。php.ini中有一个设置：</p><p>magic_quotes_gpc = Off</p><p>这个默认是关闭的，如果它打开后将自动把用户提交对sql的查询进行转换，</p><p>比如把 ‘ 转为 &#39;等，这对防止sql注射有重大作用。所以我们推荐设置为：</p><p>magic_quotes_gpc = On</p><p>(10) 错误信息控制+错误日志</p><h4 id="php代码层面-addslashes-和-str-replace-mysql-escape-string-magic-quotes-gpc-打开"><a href="#php代码层面-addslashes-和-str-replace-mysql-escape-string-magic-quotes-gpc-打开" class="headerlink" title="php代码层面   addslashes() 和 str_replace()  mysql_escape_string()  magic_quotes_gpc 打开"></a>php代码层面   addslashes() 和 str_replace()  mysql_escape_string()  magic_quotes_gpc 打开</h4><p>中文防止SQL注入的检查。addslashes的问题在于黑客可以用0xbf27来代替单引</p><ul><li>addslashes() 是强行加\；</li><li>mysql_real_escape_string()  会判断字符集，但是对PHP版本有要求；</li><li>mysql_escape_string不考虑连接的当前字符集<h3 id="magic-quotes-gpc选项打开，在这种情况下所有的客户端GET和POST的数据都会自动进行addslashes处理"><a href="#magic-quotes-gpc选项打开，在这种情况下所有的客户端GET和POST的数据都会自动进行addslashes处理" class="headerlink" title="magic_quotes_gpc选项打开，在这种情况下所有的客户端GET和POST的数据都会自动进行addslashes处理"></a>magic_quotes_gpc选项打开，在这种情况下所有的客户端GET和POST的数据都会自动进行addslashes处理</h3><h4 id="散列加密-addslashes-pg-escape-string-MD5"><a href="#散列加密-addslashes-pg-escape-string-MD5" class="headerlink" title="散列加密  addslashes() == pg_escape_string MD5"></a>散列加密  addslashes() == pg_escape_string MD5</h4></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 存储密码散列  </span><br><span class="line">$query  &#x3D; sprintf(&quot;INSERT INTO users(name,pwd) VALUES(&#39;%s&#39;,&#39;%s&#39;);&quot;,</span><br><span class="line">            pg_escape_string($username), md5($password));</span><br><span class="line">$result &#x3D; pg_query($connection, $query);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 发送请求来验证用户密码</span><br><span class="line">$query &#x3D; sprintf(&quot;SELECT 1 FROM users WHERE name&#x3D;&#39;%s&#39; AND pwd&#x3D;&#39;%s&#39;;&quot;,</span><br><span class="line">            pg_escape_string($username), md5($password));</span><br><span class="line">$result &#x3D; pg_query($connection, $query);</span><br><span class="line"></span><br><span class="line">if (pg_num_rows($result) &gt; 0) &#123;</span><br><span class="line">    echo &#39;Welcome, $username!&#39;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    echo &#39;Authentication failed for $username.&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="预防xxs-跨站脚本攻击-Cross-Site-Scripting"><a href="#预防xxs-跨站脚本攻击-Cross-Site-Scripting" class="headerlink" title="预防xxs(跨站脚本攻击(Cross Site Scripting))"></a>预防xxs(跨站脚本攻击(Cross Site Scripting))</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="https://images2015.cnblogs.com/blog/1114374/201707/1114374-20170704220225331-622725464.png" alt="image"><br>XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。比如这些代码包括HTML代码和客户端脚本<br> HTML 注入，攻击者的输入没有经过后台的过滤直接进入到数据库，最终显示给来访的用户。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><h5 id="反射型【非持久型】-如弹窗"><a href="#反射型【非持久型】-如弹窗" class="headerlink" title="反射型【非持久型】 如弹窗"></a>反射型【非持久型】 如弹窗</h5><p>　　反射型XSS，也叫非持久型XSS，是指发生请求时，XSS代码出现在请求URL中，作为参数提交到服务器，服务器解析并响应。响应结果中包含XSS代码，最后浏览器解析并执行。从概念上可以看出，反射型XSS代码是首先出现在URL中的，然后需要服务端解析，最后需要浏览器解析之后XSS代码才能够攻击。</p><h5 id="存储型【持久型】-如盗身份"><a href="#存储型【持久型】-如盗身份" class="headerlink" title="存储型【持久型】 如盗身份　"></a>存储型【持久型】 如盗身份　</h5><h4 id="第三方跳转"><a href="#第三方跳转" class="headerlink" title="第三方跳转"></a>第三方跳转</h4><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>php防止XSS跨站脚本攻击的方法:是针对非法的HTML代码包括单双引号等，使用htmlspecialchars()函数 。<br>　　1、入参字符过滤<br>　　2、出参进行编码<br>　　3、入参长度限制<br>　　4、设置cookie httponly为true</p><h3 id="预防csrf-（Cross-site-request-forgery）跨站请求伪造"><a href="#预防csrf-（Cross-site-request-forgery）跨站请求伪造" class="headerlink" title="预防csrf(（Cross-site request forgery）跨站请求伪造)"></a>预防csrf(（Cross-site request forgery）跨站请求伪造)</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><img src="https://images2015.cnblogs.com/blog/1114374/201707/1114374-20170704221329987-250861756.png" alt="image"><br>登录受信任网站A，并在本地生成Cookie。<br>在不登出A的情况下，访问危险网站B。<br>看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：<br>1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。<br>2.你不能保证你关闭浏览器了后，你本地的Cookie立刻过期，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了……）<br>3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>客户端页面增加伪随机数。<br>(1).Cookie Hashing(所有表单都包含同一个伪随机值)：<br>    这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie</p><p>(2).验证码<br>　　这个方案的思路是：每次的用户提交都需要用户在表单中填写一个图片上的随机字符串</p><p>(3).One-Time Tokens(不同的表单包含一个不同的伪随机值)</p><p>(4).在 HTTP 头中自定义属性并验证</p><p>(5).在请求地址中添加 token 并验证</p><p>(6).验证 HTTP Referer 字段</p><h3 id="预防Ddos攻击"><a href="#预防Ddos攻击" class="headerlink" title="预防Ddos攻击"></a>预防Ddos攻击</h3><h1 id="以-CGI-模式安装-可能受到的攻击-解决办法"><a href="#以-CGI-模式安装-可能受到的攻击-解决办法" class="headerlink" title="以 CGI 模式安装 可能受到的攻击 解决办法"></a>以 CGI 模式安装 可能受到的攻击 解决办法</h1><h2 id="情形一：只运行公开的文件-–enable-force-cgi-redirect"><a href="#情形一：只运行公开的文件-–enable-force-cgi-redirect" class="headerlink" title="情形一：只运行公开的文件  –enable-force-cgi-redirect"></a>情形一：只运行公开的文件  –enable-force-cgi-redirect</h2><h2 id="情形二：使用-–enable-force-cgi-redirect-选项"><a href="#情形二：使用-–enable-force-cgi-redirect-选项" class="headerlink" title="情形二：使用 –enable-force-cgi-redirect 选项"></a>情形二：使用 –enable-force-cgi-redirect 选项</h2><h2 id="情形三：设置-doc-root-或-user-dir"><a href="#情形三：设置-doc-root-或-user-dir" class="headerlink" title="情形三：设置 doc_root 或 user_dir"></a>情形三：设置 doc_root 或 user_dir</h2><h2 id="情形四：PHP-解释器放在-web-目录以外"><a href="#情形四：PHP-解释器放在-web-目录以外" class="headerlink" title="情形四：PHP 解释器放在 web 目录以外"></a>情形四：PHP 解释器放在 web 目录以外</h2><h1 id="文件系统安全-Null-字符问题"><a href="#文件系统安全-Null-字符问题" class="headerlink" title="文件系统安全 Null 字符问题"></a>文件系统安全 Null 字符问题</h1><p>想要删除自己主目录中的一个文件。假设此情形是通过 web 界面来管理文件系统，因此 Apache 用户有权删除用户目录下的文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; 从用户目录中删除指定的文件</span><br><span class="line">$username &#x3D; $_POST[&#39;user_submitted_name&#39;];</span><br><span class="line">$userfile &#x3D; $_POST[&#39;user_submitted_filename&#39;];</span><br><span class="line">$homedir &#x3D; &quot;&#x2F;home&#x2F;$username&quot;;</span><br><span class="line">unlink (&quot;$homedir&#x2F;$userfile&quot;);</span><br><span class="line">echo &quot;The file has been deleted!&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h1 id="错误报告（利用log日志干坏事-php-ini）"><a href="#错误报告（利用log日志干坏事-php-ini）" class="headerlink" title="错误报告（利用log日志干坏事 php.ini）"></a>错误报告（利用log日志干坏事 php.ini）</h1><ol><li>第一个是彻底地检查所有函数，并尝试弥补大多数错误。</li><li>第二个是对在线系统彻底关闭错误报告。</li><li>第三个是使用 PHP 自定义的错误处理函数创建自己的错误处理机制。根据不同的安全策略，三种方法可能都适用。</li></ol><p>一个能提前阻止这个问题发生的方法就是利用 error_reporting() 来帮助使代码更安全并发现变量使用的危险之处。在发布程序之前，先打开 E_ALL 测试代码，可以帮你很快找到变量使用不当的地方。一旦准备正式发布，就应该把 error_reporting() 的参数设为 0 来彻底关闭错误报告或者把 php.ini 中的 display_errors 设为 off 来关闭所有的错误显示以将代码隔绝于探测。当然，如果要迟一些再这样做，就不要忘记打开 ini 文件内的 log_errors 选项，并通过 error_log 指定用于记录错误信息的文件。</p><h1 id="用户提交的数据-校验（防SQL注入和XSS攻击等）-addslashes"><a href="#用户提交的数据-校验（防SQL注入和XSS攻击等）-addslashes" class="headerlink" title="用户提交的数据 校验（防SQL注入和XSS攻击等） addslashes()"></a>用户提交的数据 校验（防SQL注入和XSS攻击等） addslashes()</h1><p>PHP 对所有的 GET、POST 和 COOKIE 数据自动运行 addslashes()。所以您不应对已转义过的字符串使用 addslashes()，因为这样会导致双层转义。遇到这种情况时可以使用函数 get_magic_quotes_gpc() 进行检测。</p><h1 id="隐藏-PHP"><a href="#隐藏-PHP" class="headerlink" title="隐藏 PHP"></a>隐藏 PHP</h1><p>在 php.ini 文件里设置 expose_php = off ，可以减少他们能获得的有用信息。</p><p>另一个策略就是让 web 服务器用 PHP 解析不同扩展名。无论是通过 .htaccess 文件还是 Apache 的配置文件，都可以设置能误导攻击者的文件扩展名：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;数据库安全&quot;&gt;&lt;a href=&quot;#数据库安全&quot; class=&quot;headerlink&quot; title=&quot;数据库安全&quot;&gt;&lt;/a&gt;数据库安全&lt;/h1&gt;&lt;h2 id=&quot;php-连接mysql的三种方式&quot;&gt;&lt;a href=&quot;#php-连接mysql的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%B8%89%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4+%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86+%E7%94%9F%E6%88%90%E5%99%A8+%E5%BC%95%E7%94%A8/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%B8%89%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4+%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86+%E7%94%9F%E6%88%90%E5%99%A8+%E5%BC%95%E7%94%A8/</id>
    <published>2020-11-19T16:00:28.858Z</published>
    <updated>2020-11-19T16:00:28.858Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>（类似操作系统的文件目录结构）</p><h2 id="为什么使用命名空间"><a href="#为什么使用命名空间" class="headerlink" title="为什么使用命名空间"></a>为什么使用命名空间</h2><ol><li>Symfony组件，管理HTTP请求和响应</li><li>好处：使用命名空间，把代码放在唯一厂商的命名空间中，不同模块的代码，可以使用相同的名称命名类，接口，函数</li><li>目的： ==便于大型项目协同开发，不冲突==</li></ol><h2 id="声明命名空间"><a href="#声明命名空间" class="headerlink" title="声明命名空间"></a>声明命名空间</h2><p> 命名空间在PHP文件的第一行声明  Zuoyebang 命名空间 WxMis子命名空间</p><ol><li><?php </li><li>namespace Zuoyebang\Wxmis;</li></ol><p>厂商命名空间 最重要的命名空间（最顶层命名空间，必须具有全局唯一性）</p><h2 id="导入和别名"><a href="#导入和别名" class="headerlink" title="导入和别名"></a>导入和别名</h2><p>命名空间之前   下划线变为文件系统的目录分隔符 （Zend式命名）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line"> $staff &#x3D; new \zuoyebang\wxmis (&#39;kpstaff&#39;,400);没别名</span><br><span class="line">use \zuoyebang\wxmis 使用别名</span><br><span class="line"> $staff &#x3D; new wxmis (&#39;kpstaff&#39;,400)</span><br><span class="line"> use  zuoyebang\wxmis as res 使用自定义别名</span><br><span class="line"> $staff &#x3D; new res (&#39;kpstaff&#39;,400)</span><br></pre></td></tr></table></figure><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function inverse($x) &#123;</span><br><span class="line">    if (!$x) &#123;</span><br><span class="line">        throw new Exception(&#39;Division by zero.&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 1&#x2F;$x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    echo inverse(5) . &quot;\n&quot;;</span><br><span class="line">    echo inverse(0) . &quot;\n&quot;;</span><br><span class="line">&#125; catch (Exception $e) &#123;</span><br><span class="line">    echo &#39;Caught exception: &#39;,  $e-&gt;getMessage(), &quot;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Continue execution</span><br><span class="line">echo &quot;Hello World\n&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h3 id="ERROR-几倍"><a href="#ERROR-几倍" class="headerlink" title="ERROR 几倍"></a>ERROR 几倍</h3><pre><code>Fatal Error:致命错误（脚本终止运行）    E_ERROR         // 致命的运行错误，错误无法恢复，暂停执行脚本    E_CORE_ERROR    // PHP启动时初始化过程中的致命错误    E_COMPILE_ERROR // 编译时致命性错，就像由Zend脚本引擎生成了一个E_ERROR    E_USER_ERROR    // 自定义错误消息。像用PHP函数trigger_error（错误类型设置为：E_USER_ERROR）Parse Error：编译时解析错误，语法错误（脚本终止运行）    E_PARSE  //编译时的语法解析错误Warning Error：警告错误（仅给出提示信息，脚本不终止运行）    E_WARNING         // 运行时警告 (非致命错误)。    E_CORE_WARNING    // PHP初始化启动过程中发生的警告 (非致命错误) 。    E_COMPILE_WARNING // 编译警告    E_USER_WARNING    // 用户产生的警告信息Notice Error：通知错误（仅给出通知信息，脚本不终止运行）    E_NOTICE      // 运行时通知。表示脚本遇到可能会表现为错误的情况.    E_USER_NOTICE // 用户产生的通知信息。</code></pre><h3 id="怎么做到异常捕捉的-register-shutdown-function，set-error-handler，set-exception-handler"><a href="#怎么做到异常捕捉的-register-shutdown-function，set-error-handler，set-exception-handler" class="headerlink" title="怎么做到异常捕捉的  register_shutdown_function，set_error_handler，set_exception_handler"></a>怎么做到异常捕捉的  register_shutdown_function，set_error_handler，set_exception_handler</h3><h4 id="set-error-handler-当程序出现错误的时候自动调用此方法，"><a href="#set-error-handler-当程序出现错误的时候自动调用此方法，" class="headerlink" title="set_error_handler() 　当程序出现错误的时候自动调用此方法，"></a>set_error_handler() 　当程序出现错误的时候自动调用此方法，</h4><h4 id="register-shutdown-function"><a href="#register-shutdown-function" class="headerlink" title="register_shutdown_function()"></a>register_shutdown_function()</h4><p>　　捕获PHP的错误：Fatal Error、ParsError等，这个方法是PHP脚本执行结束前最后一个调用的函数，比如脚本错误、die()、exit、异常、正常结束都会调用，多么牛逼的一个函数啊！通过这个函数就可以在脚本结束前判断这次执行是否有错误产生，这时就要借助于一个函数：error_get_last()；这个函数可以拿到本次执行产生的所有错误。error_get_last();返回的信息。</p><h4 id="set-exception-handler"><a href="#set-exception-handler" class="headerlink" title="set_exception_handler()"></a>set_exception_handler()</h4><p>　　<br>　　设置默认的异常处理程序，用在没有用try/catch块来捕获的异常，也就是说不管你抛出的异常有没有人捕获，如果没有人捕获就会进入到该方法中，并且在回调函数调用后异常会中止。看一下用法：　　</p><h1 id="生成器-（yield）读取大文件"><a href="#生成器-（yield）读取大文件" class="headerlink" title="生成器 （yield）读取大文件"></a>生成器 （yield）读取大文件</h1><p><a href="https://www.cnblogs.com/johnson108178/p/8007585.html">link</a><br>例子<br>生成器提供了一种更容易的方法来实现简单的对象迭代，相比较定义类实现 Iterator 接口的方式，性能开销和复杂性大大降低。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function createRange($number)&#123;</span><br><span class="line">    for($i&#x3D;0;$i&lt;$number;$i++)&#123;</span><br><span class="line">        yield time();  &#x2F;&#x2F;循环一个就返回一个</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$result &#x3D; createRange(10); &#x2F;&#x2F; 这里调用上面我们创建的函数</span><br><span class="line">foreach($result as $value)&#123;</span><br><span class="line">    sleep(1);</span><br><span class="line">    echo $value.&#39;&lt;br &#x2F;&gt;&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;命名空间&quot;&gt;&lt;a href=&quot;#命名空间&quot; class=&quot;headerlink&quot; title=&quot;命名空间&quot;&gt;&lt;/a&gt;命名空间&lt;/h1&gt;&lt;p&gt;（类似操作系统的文件目录结构）&lt;/p&gt;
&lt;h2 id=&quot;为什么使用命名空间&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E5%85%AB%E3%80%81php%E7%89%B9%E7%82%B9%EF%BC%88http%E8%AE%A4%E8%AF%81+cookie+%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0+%E6%95%B0%E6%8D%AE+%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E5%85%AB%E3%80%81php%E7%89%B9%E7%82%B9%EF%BC%88http%E8%AE%A4%E8%AF%81+cookie+%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0+%E6%95%B0%E6%8D%AE+%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89/</id>
    <published>2020-11-19T16:00:28.858Z</published>
    <updated>2020-11-19T16:00:28.858Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="垃圾回收机制GC-Garbage-Collection"><a href="#垃圾回收机制GC-Garbage-Collection" class="headerlink" title="垃圾回收机制GC[Garbage Collection]"></a>垃圾回收机制GC[Garbage Collection]</h1><h2 id="变量结构"><a href="#变量结构" class="headerlink" title="变量结构"></a>变量结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef union _zvalue_value &#123;  </span><br><span class="line">    long lval;                  &#x2F;* long value *&#x2F; </span><br><span class="line">    double dval;                &#x2F;* double value *&#x2F; </span><br><span class="line">    struct &#123;  </span><br><span class="line">        char *val;  </span><br><span class="line">        int len;  </span><br><span class="line">    &#125; str;  </span><br><span class="line">    HashTable *ht;              &#x2F;* hash table value *&#x2F; </span><br><span class="line">    zend_object_value obj;  </span><br><span class="line">&#125; zvalue_value;  </span><br><span class="line"> </span><br><span class="line">struct _zval_struct &#123;  </span><br><span class="line">    &#x2F;* Variable information 值 *&#x2F; </span><br><span class="line">    zvalue_value value;       </span><br><span class="line">&#x2F;* value *&#x2F; </span><br><span class="line">    zend_uint refcount__gc;  &#x2F;&#x2F;计数器，表示指向这个zval变量容器的变量个数。 </span><br><span class="line">    zend_uchar type;    &#x2F;* active type 类型 *&#x2F; </span><br><span class="line">    zend_uchar is_ref__gc;&#x2F;&#x2F;是个bool值，用来区分变量是否属于引用集合。</span><br><span class="line">&#125;; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="非数组存储例子"><a href="#非数组存储例子" class="headerlink" title="非数组存储例子"></a>非数组存储例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; 1;</span><br><span class="line">xdebug_debug_zval(&#39;a&#39;);</span><br><span class="line">echo PHP_EOL;</span><br><span class="line">$b &#x3D; $a;</span><br><span class="line">xdebug_debug_zval(&#39;a&#39;);</span><br><span class="line">echo PHP_EOL;</span><br><span class="line"> </span><br><span class="line">$c &#x3D; &amp;$a;</span><br><span class="line">xdebug_debug_zval(&#39;a&#39;);</span><br><span class="line">echo PHP_EOL;</span><br><span class="line"> </span><br><span class="line">xdebug_debug_zval(&#39;b&#39;);</span><br><span class="line">echo PHP_EOL;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>　　运行结果如下：</p><p>a:(refcount=1, is_ref=0),int 1</p><p>a:(refcount=2, is_ref=0),int 1</p><p>a:(refcount=2, is_ref=1),int 1</p><p>b:(refcount=1, is_ref=0),int 1</p><h2 id="数组存储例子"><a href="#数组存储例子" class="headerlink" title="数组存储例子"></a>数组存储例子</h2><p><img src="http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-simple-array.png" alt="image"><br>数组分配了三个zval容器：a   meaning  number</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="Reference-Counting-算法-5-2版本-环状引用内存泄漏"><a href="#Reference-Counting-算法-5-2版本-环状引用内存泄漏" class="headerlink" title="Reference Counting 算法 5.2版本 环状引用内存泄漏"></a>Reference Counting 算法 5.2版本 环状引用内存泄漏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a &#x3D; array( &#39;one&#39; );</span><br><span class="line">$a[] &#x3D;&amp; $a;</span><br><span class="line">xdebug_debug_zval( &#39;a&#39; );</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>a 和 1 的zval容器 是一样的。如下：<br><img src="http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-loop-array.png" alt="image"></p><p>在5.2及更早版本的PHP中，没有专门的垃圾回收器GC（Garbage Collection），引擎在判断一个变量空间是否能够被释放的时候是依据这个变量的zval的refcount的值，如果refcount为0，那么变量的空间可以被释放，否则就不释放，这是一种非常简单的GC实现。</p><p>现在unset ($a),那么array的refcount减1变为1.现在无任何变量指向这个zval，而且这个zval的计数器为1，不会回收。 成千上万的这种就会内存泄漏</p><p><img src="http://php.net/manual/zh/images/12f37b1c6963c1c5c18f30495416a197-leak-array.png" alt="image"></p><h3 id="Concurrent-Cycle-Collection-in-Reference-Counted-Systems-算法-5-3版本-解决了环状引用-控制内存泄漏的阙值"><a href="#Concurrent-Cycle-Collection-in-Reference-Counted-Systems-算法-5-3版本-解决了环状引用-控制内存泄漏的阙值" class="headerlink" title="Concurrent Cycle Collection in Reference Counted Systems 算法 5.3版本 解决了环状引用,控制内存泄漏的阙值"></a>Concurrent Cycle Collection in Reference Counted Systems 算法 5.3版本 解决了环状引用,控制内存泄漏的阙值</h3><p>在php5.3的GC中，针对的垃圾做了如下说明：</p><p>1：如果一个zval的refcount增加，那么此zval还在使用，肯定不是垃圾，不会进入缓冲区</p><p>2：如果一个zval的refcount减少到0， 那么zval会被立即释放掉，不属于GC要处理的垃圾对象，不会进入缓冲区。</p><p> 3：如果一个zval的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾，将其放入缓冲区。PHP5.3中的GC针对的就是这种zval进行的处理。</p><p>开启/关闭垃圾回收机制可以通过修改php配置实现，也可以在程序中使用gc_enable() 和 gc_disable()开启和关闭。</p><h1 id="用-PHP-进行-HTTP-认证"><a href="#用-PHP-进行-HTTP-认证" class="headerlink" title="用 PHP 进行 HTTP 认证"></a>用 PHP 进行 HTTP 认证</h1><p>以用 header() 函数来向客户端浏览器发送“Authentication Required”信息，使其弹出一个用户名／密码输入窗口。当用户输入用户名和密码后，包含有 URL 的 PHP 脚本将会加上预定义变量 PHP_AUTH_USER，PHP_AUTH_PW 和 AUTH_TYPE 被再次调用，这三个变量分别被设定为用户名，密码和认证类型。预定义变量保存在 $_SERVER 数组中。支持“Basic”和“Digest”（自 PHP 5.1.0 起）认证方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$_SERVER[&#39;PHP_AUTH_USER&#39;] &#x3D; &quot;test&quot;;</span><br><span class="line">$_SERVER[&#39;PHP_AUTH_PW&#39;] &#x3D; &quot;123456&quot;;</span><br><span class="line">&#x2F;&#x2F;*********************************</span><br><span class="line">&#x2F;&#x2F;用户账号</span><br><span class="line">$login &#x3D; &#39;test&#39;; </span><br><span class="line">$pass &#x3D; &#39;1234567&#39;; </span><br><span class="line">&#x2F;&#x2F;*********************************</span><br><span class="line"></span><br><span class="line">if(($_SERVER[&#39;PHP_AUTH_PW&#39;]!&#x3D; $pass || $_SERVER[&#39;PHP_AUTH_USER&#39;] !&#x3D; $login)|| !$_SERVER[&#39;PHP_AUTH_USER&#39;])</span><br><span class="line"> &#123; </span><br><span class="line">    header(&#39;WWW-Authenticate: Basic realm&#x3D;&quot;Test auth&quot;&#39;); </span><br><span class="line">    header(&#39;HTTP&#x2F;1.0 401 Unauthorized&#39;); </span><br><span class="line">    echo &#39;Auth failed&#39;; </span><br><span class="line">    exit; </span><br><span class="line">&#125; else&#123;</span><br><span class="line">    echo &quot;Auth success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">具体业务具体对待.....</span><br></pre></td></tr></table></figure><h1 id="cookie和session"><a href="#cookie和session" class="headerlink" title="cookie和session"></a>cookie和session</h1><p> setcookie() 和 setrawcookie() 函数</p><h1 id="处理-XForms-表单"><a href="#处理-XForms-表单" class="headerlink" title="处理 XForms 表单"></a>处理 XForms 表单</h1><h1 id="文件上传处理-post-put"><a href="#文件上传处理-post-put" class="headerlink" title="文件上传处理 post +put"></a>文件上传处理 post +put</h1><h1 id="使用远程文件"><a href="#使用远程文件" class="headerlink" title="使用远程文件"></a>使用远程文件</h1><p>只要在 php.ini 文件中激活了 allow_url_fopen 选项，就可以在大多数需要用文件名作为参数的函数中使用 HTTP 和 FTP 的 URL 来代替文件名。</p><h1 id="数据库持久连接"><a href="#数据库持久连接" class="headerlink" title="数据库持久连接"></a>数据库持久连接</h1><h1 id="安全模式-强级别校验"><a href="#安全模式-强级别校验" class="headerlink" title="安全模式 强级别校验"></a>安全模式 强级别校验</h1><h1 id="PHP-的命令行模式-php-a"><a href="#PHP-的命令行模式-php-a" class="headerlink" title="PHP 的命令行模式 php -a"></a>PHP 的命令行模式 php -a</h1><h1 id="DTrace-动态跟踪-性能调试"><a href="#DTrace-动态跟踪-性能调试" class="headerlink" title="DTrace 动态跟踪 性能调试"></a>DTrace 动态跟踪 性能调试</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;垃圾回收机制GC-Garbage-Collection&quot;&gt;&lt;a href=&quot;#垃圾回收机制GC-Garbage-Collection&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收机制GC[Garbage Collecti</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E5%85%AD%E3%80%81context%E7%9A%84%E9%80%89%E9%A1%B9%E5%92%8C%E5%8F%82%E6%95%B0+%E6%94%AF%E6%8C%81%E5%8D%8F%E8%AE%AE/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E5%85%AD%E3%80%81context%E7%9A%84%E9%80%89%E9%A1%B9%E5%92%8C%E5%8F%82%E6%95%B0+%E6%94%AF%E6%8C%81%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-11-19T16:00:28.858Z</published>
    <updated>2020-11-19T16:00:28.858Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="context的选项和参数"><a href="#context的选项和参数" class="headerlink" title="context的选项和参数"></a>context的选项和参数</h1><h2 id="套接字上下文选项-—-套接字上下文选项列表-工作在套接字上的封装协议，像-tcp-http-和-ftp"><a href="#套接字上下文选项-—-套接字上下文选项列表-工作在套接字上的封装协议，像-tcp-http-和-ftp" class="headerlink" title="套接字上下文选项 — 套接字上下文选项列表 工作在套接字上的封装协议，像 tcp, http 和 ftp."></a>套接字上下文选项 — 套接字上下文选项列表 工作在套接字上的封装协议，像 tcp, http 和 ftp.</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; connect to the internet using the &#39;192.168.0.100&#39; IP</span><br><span class="line">$opts &#x3D; array(</span><br><span class="line">    &#39;socket&#39; &#x3D;&gt; array(</span><br><span class="line">        &#39;bindto&#39; &#x3D;&gt; &#39;192.168.0.100:0&#39;,</span><br><span class="line">    ),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; connect to the internet using the &#39;192.168.0.100&#39; IP and port &#39;7000&#39;</span><br><span class="line">$opts &#x3D; array(</span><br><span class="line">    &#39;socket&#39; &#x3D;&gt; array(</span><br><span class="line">        &#39;bindto&#39; &#x3D;&gt; &#39;192.168.0.100:7000&#39;,</span><br><span class="line">    ),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; connect to the internet using port &#39;7000&#39;</span><br><span class="line">$opts &#x3D; array(</span><br><span class="line">    &#39;socket&#39; &#x3D;&gt; array(</span><br><span class="line">        &#39;bindto&#39; &#x3D;&gt; &#39;0:7000&#39;,</span><br><span class="line">    ),</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; create the context...</span><br><span class="line">$context &#x3D; stream_context_create($opts);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ...and use it to fetch the data</span><br><span class="line">echo file_get_contents(&#39;http:&#x2F;&#x2F;www.example.com&#39;, false, $context);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="HTTP-context-选项-—-HTTP-context-的选项列表-file-get-contents-stream-context-create"><a href="#HTTP-context-选项-—-HTTP-context-的选项列表-file-get-contents-stream-context-create" class="headerlink" title="HTTP context 选项 — HTTP context 的选项列表 file_get_contents  stream_context_create"></a>HTTP context 选项 — HTTP context 的选项列表 file_get_contents  stream_context_create</h2><h2 id="FTP-context-options-—-FTP-context-option-listing"><a href="#FTP-context-options-—-FTP-context-option-listing" class="headerlink" title="FTP context options — FTP context option listing"></a>FTP context options — FTP context option listing</h2><h2 id="SSL-上下文选项-—-SSL-上下文选项清单"><a href="#SSL-上下文选项-—-SSL-上下文选项清单" class="headerlink" title="SSL 上下文选项 — SSL 上下文选项清单"></a>SSL 上下文选项 — SSL 上下文选项清单</h2><h2 id="CURL-context-options-—-CURL-上下文选项列表"><a href="#CURL-context-options-—-CURL-上下文选项列表" class="headerlink" title="CURL context options — CURL 上下文选项列表"></a>CURL context options — CURL 上下文选项列表</h2><h2 id="Phar-上下文（context）选项-—-Phar-上下文（context）选项-类似jar-打包文件"><a href="#Phar-上下文（context）选项-—-Phar-上下文（context）选项-类似jar-打包文件" class="headerlink" title="Phar 上下文（context）选项 — Phar 上下文（context）选项 类似jar 打包文件"></a>Phar 上下文（context）选项 — Phar 上下文（context）选项 类似jar 打包文件</h2><h2 id="MongoDB-context-options-—-MongoDB-context-option-listing"><a href="#MongoDB-context-options-—-MongoDB-context-option-listing" class="headerlink" title="MongoDB context options — MongoDB context option listing"></a>MongoDB context options — MongoDB context option listing</h2><h2 id="Context-参数-—-Context-参数列表"><a href="#Context-参数-—-Context-参数列表" class="headerlink" title="Context 参数 — Context 参数列表"></a>Context 参数 — Context 参数列表</h2><h1 id="支持的协议"><a href="#支持的协议" class="headerlink" title="支持的协议"></a>支持的协议</h1><ol><li>file:// — 访问本地文件系统</li><li>http:// — 访问 HTTP(s) 网址</li><li>ftp:// — 访问 FTP(s) URLs</li><li>php:// — 访问各个输入/输出流（I/O streams）</li><li>zlib:// — 压缩流</li><li>data:// — 数据（RFC 2397）</li><li>glob:// — 查找匹配的文件路径模式</li><li>phar:// — PHP 归档</li><li>ssh2:// — Secure Shell 2</li><li>rar:// — RAR</li><li>ogg:// — 音频流</li><li>expect:// — 处理交互式的流</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;context的选项和参数&quot;&gt;&lt;a href=&quot;#context的选项和参数&quot; class=&quot;headerlink&quot; title=&quot;context的选项和参数&quot;&gt;&lt;/a&gt;context的选项和参数&lt;/h1&gt;&lt;h2 id=&quot;套接字上下文选项</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%BA%94%E3%80%81%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F+%E9%A2%84%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%BA%94%E3%80%81%E9%A2%84%E5%AE%9A%E4%B9%89%E5%8F%98%E9%87%8F+%E9%A2%84%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-11-19T16:00:28.857Z</published>
    <updated>2020-11-19T16:00:28.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h1><ol><li>超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量</li><li>$GLOBALS — 引用全局作用域中可用的全部变量</li><li>$_SERVER — 服务器和执行环境信息</li><li>$_GET — HTTP GET 变量</li><li>$_POST — HTTP POST 变量</li><li>$_FILES — HTTP 文件上传变量</li><li>$_REQUEST — HTTP Request 变量</li><li>$_SESSION — Session 变量</li><li>$_ENV — 环境变量</li><li>$_COOKIE — HTTP Cookies</li><li>$php_errormsg — 前一个错误信息</li><li>$HTTP_RAW_POST_DATA — 原生POST数据</li><li>$http_response_header — HTTP 响应头</li><li>$argc — 传递给脚本的参数数目</li><li>$argv — 传递给脚本的参数数组、</li></ol><h1 id="预定义接口"><a href="#预定义接口" class="headerlink" title="预定义接口"></a>预定义接口</h1><p><a href="https://blog.csdn.net/liqihang_dev/article/details/85114374">https://blog.csdn.net/liqihang_dev/article/details/85114374</a></p><h2 id="遍历-Traversable-接口-检测一个类是否可以使用-foreach-进行遍历的接口。"><a href="#遍历-Traversable-接口-检测一个类是否可以使用-foreach-进行遍历的接口。" class="headerlink" title="遍历 Traversable 接口  检测一个类是否可以使用 foreach 进行遍历的接口。"></a>遍历 Traversable 接口  检测一个类是否可以使用 foreach 进行遍历的接口。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#检测一个类的对象是否可以用foreach进行遍历，实现Iterator就可遍历了</span><br><span class="line">class man&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$p &#x3D; new man();</span><br><span class="line">var_dump($p instanceof  man); #false</span><br></pre></td></tr></table></figure><h2 id="迭代器-Iterator（迭代器）接口"><a href="#迭代器-Iterator（迭代器）接口" class="headerlink" title="迭代器 Iterator（迭代器）接口"></a>迭代器 Iterator（迭代器）接口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Iterator extends Traversable  </span><br><span class="line">&#123;  </span><br><span class="line">    &#x2F;&#x2F;返回当前索引游标指向的元素  </span><br><span class="line">    abstract public mixed current(void)  </span><br><span class="line">    &#x2F;&#x2F;返回当前索引游标指向的元素的键名  </span><br><span class="line">    abstract public scalar key(void)  </span><br><span class="line">    &#x2F;&#x2F;移动当前索引游标指向下一元素  </span><br><span class="line">    abstract public void next(void)  </span><br><span class="line">    &#x2F;&#x2F;重置索引游标的指向第一个元素  </span><br><span class="line">    abstract public void rewind(void)  </span><br><span class="line">    &#x2F;&#x2F;判断当前索引游标指向的是否是一个元素，常常在调用 rewind()或 next()使用  </span><br><span class="line">    abstract public boolean valid(void)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="聚合式迭代器-IteratorAggregate（聚合式迭代器）接口"><a href="#聚合式迭代器-IteratorAggregate（聚合式迭代器）接口" class="headerlink" title="聚合式迭代器 IteratorAggregate（聚合式迭代器）接口"></a>聚合式迭代器 IteratorAggregate（聚合式迭代器）接口</h2><h2 id="数组式访问-ArrayAccess（数组式访问）接口"><a href="#数组式访问-ArrayAccess（数组式访问）接口" class="headerlink" title="数组式访问 ArrayAccess（数组式访问）接口"></a>数组式访问 ArrayAccess（数组式访问）接口</h2><p>通常情况下，我们会看到this[‘name’]这样的用法，但是我们知道，$this是一个对象，是如何使用数组方式访问的？答案就是实现了数据组访问接口ArrayAccess，具体代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class Test implements ArrayAccess</span><br><span class="line">    &#123;</span><br><span class="line">        public $container;</span><br><span class="line"> </span><br><span class="line">        public function __construct()</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;container &#x3D; [</span><br><span class="line">                &#39;one&#39; &#x3D;&gt; 1,</span><br><span class="line">                &#39;two&#39; &#x3D;&gt; 2,</span><br><span class="line">                &#39;three&#39;  &#x3D;&gt; 3,</span><br><span class="line">            ];</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public function offsetExists($offset) </span><br><span class="line">        &#123;</span><br><span class="line">            return isset($this-&gt;container[$offset]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public function offsetGet($offset)</span><br><span class="line">        &#123;</span><br><span class="line">            return isset($this-&gt;container[$offset]) ? $this-&gt;container[$offset] : ;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public function offsetSet($offset, $value)</span><br><span class="line">        &#123;</span><br><span class="line">            if (is_null($offset)) &#123;</span><br><span class="line">                $this-&gt;container[] &#x3D; $value;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $this-&gt;container[$offset] &#x3D; $value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public function offsetUnset($offset)</span><br><span class="line">        &#123;</span><br><span class="line">            unset($this-&gt;container[$offset]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   $test &#x3D; new Test;</span><br><span class="line">   var_dump(isset($test[&#39;one&#39;]));</span><br><span class="line">   var_dump($test[&#39;two&#39;]);</span><br><span class="line">   unset($test[&#39;two&#39;]);</span><br><span class="line">   var_dump(isset($test[&#39;two&#39;]));</span><br><span class="line">   $test[&#39;two&#39;] &#x3D; 22;</span><br><span class="line">   var_dump($test[&#39;two&#39;]);</span><br><span class="line">   $test[] &#x3D; 4;</span><br><span class="line">   var_dump($test);</span><br><span class="line">   var_dump($test[0]);</span><br><span class="line"> </span><br><span class="line">   当然我们也有经典的一个做法就是把对象的属性当做数组来访问</span><br><span class="line"> </span><br><span class="line">   class Test implements ArrayAccess</span><br><span class="line">   &#123;</span><br><span class="line">        public $name;</span><br><span class="line"> </span><br><span class="line">        public function __construct()</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;name &#x3D; &#39;gabe&#39;;  </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public function offsetExists($offset)</span><br><span class="line">        &#123;</span><br><span class="line">            return isset($this-&gt;$offset);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public function offsetGet($offset)</span><br><span class="line">        &#123;</span><br><span class="line">            return isset($this-&gt;$offset) ? $this-&gt;$offset : ;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public function offsetSet($offset, $value)</span><br><span class="line">        &#123;</span><br><span class="line">            $this-&gt;$offset &#x3D; $value;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        public function offsetUnset($offset)</span><br><span class="line">        &#123;</span><br><span class="line">            unset($this-&gt;$offset);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">  $test &#x3D; new Test;</span><br><span class="line">  var_dump(isset($test[&#39;name&#39;]));</span><br><span class="line">  var_dump($test[&#39;name&#39;]);</span><br><span class="line">  var_dump($test[&#39;age&#39;]);</span><br><span class="line">  $test[1] &#x3D; &#39;22&#39;;</span><br><span class="line">  var_dump($test);</span><br><span class="line">  unset($test[&#39;name&#39;]);</span><br><span class="line">  var_dump(isset($test[&#39;name&#39;]));</span><br><span class="line">  var_dump($test);</span><br><span class="line">  $test[] &#x3D; &#39;hello world&#39;;</span><br><span class="line">  var_dump($test);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h2 id="Closure-用于代表-匿名函数-的类"><a href="#Closure-用于代表-匿名函数-的类" class="headerlink" title="Closure 用于代表 匿名函数 的类."></a>Closure 用于代表 匿名函数 的类.</h2><h2 id="生成器-Generator"><a href="#生成器-Generator" class="headerlink" title="生成器 Generator"></a>生成器 Generator</h2><p>Generator实现了Iterator，但是他无法被继承，同时也生成实例。既然实现了Iterator，所以正如上文所介绍，他也就有了和Iterator相同的功能:rewind-&gt;valid-&gt;current-&gt;key-&gt;next…，Generator的语法主要来自于关键字yield。yield就好比一次循环的中转站，记录本次的活动轨迹，返回一个Generator的实例。Generator的优点在于，当我们要使用到大数据的遍历，或者说大文件的读写，而我们的内存不够的情况下，能够极大的减少我们对于内存的消耗，因为传统的遍历会返回所有的数据，这个数据存在内存上，而yield只会返回当前的值，不过当我们在使用yield时，其实其中会有一个处理记忆体的过程，所以实际上这是一个用时间换空间的办法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;预定义变量&quot;&gt;&lt;a href=&quot;#预定义变量&quot; class=&quot;headerlink&quot; title=&quot;预定义变量&quot;&gt;&lt;/a&gt;预定义变量&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量&lt;/li&gt;
&lt;li&gt;$GLOBALS — 引</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E5%9B%9B%E3%80%81%E7%BB%84%E4%BB%B6/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E5%9B%9B%E3%80%81%E7%BB%84%E4%BB%B6/</id>
    <published>2020-11-19T16:00:28.857Z</published>
    <updated>2020-11-19T16:00:28.857Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="为什么使用组件"><a href="#为什么使用组件" class="headerlink" title="为什么使用组件"></a>为什么使用组件</h1><p>脱离大框架的束缚  不用重复造轮子</p><h1 id="组件是什么"><a href="#组件是什么" class="headerlink" title="组件是什么"></a>组件是什么</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组件是打包的代码，用于帮你解决PHP应用中某个具体的问题。组件中的类、接口和性状通常放在同一个命名空间中。</span><br></pre></td></tr></table></figure><h1 id="好的组件的特点"><a href="#好的组件的特点" class="headerlink" title="好的组件的特点"></a>好的组件的特点</h1><ol><li>作用单一</li><li>小型 </li><li>合作（和其他组件合作）</li><li>测试良好</li><li>文档完善</li></ol><h1 id="组件和框架对比"><a href="#组件和框架对比" class="headerlink" title="组件和框架对比"></a>组件和框架对比</h1><p>框架的好处：Symfony 和Drupal  Laravel<br>四大框架的对比： <a href="http://www.php.cn/php-weizijiaocheng-386709.html">link</a></p><h1 id="PHP架构、构件、组件、框架、中间件的区别"><a href="#PHP架构、构件、组件、框架、中间件的区别" class="headerlink" title="PHP架构、构件、组件、框架、中间件的区别"></a>PHP架构、构件、组件、框架、中间件的区别</h1><p><a href="http://tieba.baidu.com/p/541649759/">link</a></p><h1 id="如何使用PHP组件"><a href="#如何使用PHP组件" class="headerlink" title="如何使用PHP组件"></a>如何使用PHP组件</h1><p>Packagist 查找PHP组件<br>composer  安装PHP组件工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;使用composer自动加载器</span><br><span class="line">require &#39;vendor&#x2F;autoload.php&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;实例Guzzle Http客户端</span><br><span class="line">$client &#x3D; new GuzzleHttp\Client();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;打开并迭代处理CSV</span><br><span class="line">$csv &#x3D; League\Csv\Reader::createFromPath($argv[1]);</span><br><span class="line">foreach ($csv as $csvRow) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;发送HTTP GET请求</span><br><span class="line">        $httpResponse &#x3D; $client-&gt;get($csvRow[0]);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;检查HTTP响应的状态码</span><br><span class="line">        if($httpResponse-&gt;getStatusCode() &gt;&#x3D; 400) &#123;</span><br><span class="line">            throw new Exception();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (Exception $e) &#123;</span><br><span class="line">            &#x2F;&#x2F;把死链发给标准输出</span><br><span class="line">            echo $csvRow[0] . PHP_EOL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="怎么创建PHP组件"><a href="#怎么创建PHP组件" class="headerlink" title="怎么创建PHP组件"></a>怎么创建PHP组件</h2><ol><li>选择厂商名和包名</li><li>命名空间</li><li>文件系统的组织方式</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;为什么使用组件&quot;&gt;&lt;a href=&quot;#为什么使用组件&quot; class=&quot;headerlink&quot; title=&quot;为什么使用组件&quot;&gt;&lt;/a&gt;为什么使用组件&lt;/h1&gt;&lt;p&gt;脱离大框架的束缚  不用重复造轮子&lt;/p&gt;
&lt;h1 id=&quot;组件是什么&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/python/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/python/python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2020-11-19T16:00:28.853Z</published>
    <updated>2020-11-19T16:00:28.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="python的标识符"><a href="#python的标识符" class="headerlink" title="python的标识符"></a>python的标识符</h1><p>在 Python 里，标识符由==字母、数字、下划线==组成。</p><p>在 Python 中，所有标识符可以包括英文、数字以及下划线(_)，但不能以数字开头。</p><p>Python 中的标识符==是区分大小写==的。</p><p>以下划线开头的标识符是有特殊意义的。以==单下划线==开头 _foo 的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用 from xxx import * 而导入。</p><p>以==双下划线==开头的 <strong>foo 代表类的私有成员，以双下划线开头和结尾的 __foo</strong> 代表 Python 里特殊方法专用的标识，如 <strong>init</strong>() 代表类的构造函数。</p><h1 id="python的保留字符【都是小写】"><a href="#python的保留字符【都是小写】" class="headerlink" title="python的保留字符【都是小写】"></a>python的保留字符【都是小写】</h1><h1 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h1><p>行和缩进<br>学习 Python 与其他语言最大的区别就是，Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断。python 最具特色的就是用缩进来写模块。</p><h1 id="多行语句-显示"><a href="#多行语句-显示" class="headerlink" title="多行语句 \ 显示"></a>多行语句 \ 显示</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total &#x3D; item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure><p>[]{}() 不用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">days &#x3D; [&#39;Monday&#39;, &#39;Tuesday&#39;, &#39;Wednesday&#39;,</span><br><span class="line">        &#39;Thursday&#39;, &#39;Friday&#39;]</span><br></pre></td></tr></table></figure><h1 id="python的引号-‘’-“”-“””"><a href="#python的引号-‘’-“”-“””" class="headerlink" title="python的引号 ‘’ “” “””"></a>python的引号 ‘’ “” “””</h1><h1 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h1><p>Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;python的标识符&quot;&gt;&lt;a href=&quot;#python的标识符&quot; class=&quot;headerlink&quot; title=&quot;python的标识符&quot;&gt;&lt;/a&gt;python的标识符&lt;/h1&gt;&lt;p&gt;在 Python 里，标识符由==字母、数字、下划线==组成。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/python/python%20%E7%9A%84time%20datetime%20date/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/python/python%20%E7%9A%84time%20datetime%20date/</id>
    <published>2020-11-19T16:00:28.852Z</published>
    <updated>2020-11-19T16:00:28.852Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://blog.csdn.net/p9bl5bxp/article/details/54945920" alt="image"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://blog.csdn.net/p9bl5bxp/article/details/54945920&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/python/python2%20python3%20%E5%8C%BA%E5%88%AB/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/python/python2%20python3%20%E5%8C%BA%E5%88%AB/</id>
    <published>2020-11-19T16:00:28.852Z</published>
    <updated>2020-11-19T16:00:28.852Z</updated>
    
    <content type="html"><![CDATA[<p> 1.print不再是语句，而是函数，比如原来是 print ‘abc’ 现在是 print(‘abc’)但是 python2.6+ 可以使用 from <strong>future</strong> import print_function 来实现相同功能&gt;  </p><ol start="2"><li><p>在Python 3中，没有旧式类，只有新式类，也就是说不用再像这样 class Foobar(object): pass 显式地子类化object但是最好还是加上. 主要区别在于 old-style 是 classtype 类型而 new-style 是 type类型&gt;</p></li><li><p>原来1/2（两个整数相除）结果是0，现在是0.5了python 2+ 以上都可以使用 from <strong>future</strong> import division 实现改特性, 同时注意 // 取代了之前的 / 运算&gt;  </p></li><li><p>新的字符串格式化方法format取代%错误, 从 python2.6+ 开始已经在str和unicode中有该方法, 同时 python3依然支持 % 算符&gt; </p></li><li><p>xrange重命名为range同时更改的还有一系列内置函数及方法, 都返回迭代器对象, 而不是列表或者 元组, 比如 filter, map, dict.items 等&gt;  </p></li><li><p>!=取代  &lt;   &gt;  python2 也很少有人用  &lt;  &gt;  所以不算什么修改&gt;  </p></li><li><p>long重命名为int不完全对, python3 彻底废弃了 long+int 双整数实现的方法, 统一为 int , 支持高精度整数运算.&gt; </p></li><li><p>except Exception, e变成except (Exception) as e只有 python2.5 及以下版本不支持该语法. python2.6 是支持的. 不算新东西&gt;  10. exec变成函数类似 print() 的变化, 之前是语句</p><h1 id=""><a href="#" class="headerlink" title=""></a></h1></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 1.print不再是语句，而是函数，比如原来是 print ‘abc’ 现在是 print(‘abc’)但是 python2.6+ 可以使用 from &lt;strong&gt;future&lt;/strong&gt; import print_function 来实现相同功能&amp;gt;  &lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/python/python%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
    <id>https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/python/python%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-11-19T16:00:28.852Z</published>
    <updated>2020-11-19T16:00:28.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Numbers（数字）"><a href="#Numbers（数字）" class="headerlink" title="Numbers（数字）"></a>Numbers（数字）</h1><h1 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h1><h1 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h1><h1 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h1><h1 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Numbers（数字）&quot;&gt;&lt;a href=&quot;#Numbers（数字）&quot; class=&quot;headerlink&quot; title=&quot;Numbers（数字）&quot;&gt;&lt;/a&gt;Numbers（数字）&lt;/h1&gt;&lt;h1 id=&quot;String（字符串）&quot;&gt;&lt;a href=&quot;#String</summary>
      
    
    
    
    
  </entry>
  
</feed>
