<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="一剑光寒十九州" />
  

  
  
  
  
  
  
  <title>NK一哥黄大脸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一剑光寒十九州">
<meta property="og:type" content="website">
<meta property="og:title" content="NK一哥黄大脸">
<meta property="og:url" content="https://zedhao.github.io/huanghao.github.io/page/5/index.html">
<meta property="og:site_name" content="NK一哥黄大脸">
<meta property="og:description" content="一剑光寒十九州">
<meta property="og:locale">
<meta property="article:author" content="huanghao">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/huanghao.github.io/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/huanghao.github.io/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/huanghao.github.io/atom.xml" title="NK一哥黄大脸" type="application/atom+xml">
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/huanghao.github.io/" title="NK一哥黄大脸" rel="home">NK一哥黄大脸</a>
      </h1>
      
        <h2 <title>谦谦君子 温润如玉</title></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/archives">Archives</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/guestbook">guestbook</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-005.服务实现/存储/文件压缩" class="post-005.服务实现/存储/文件压缩 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/" data-id="ckhp0x7qu001q932ucwokchrp" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[toc]</p>
<h1 id="压缩算法"><a href="#压缩算法" class="headerlink" title="压缩算法"></a>压缩算法</h1><h2 id="哈夫曼"><a href="#哈夫曼" class="headerlink" title="哈夫曼"></a>哈夫曼</h2><h2 id="LZ77"><a href="#LZ77" class="headerlink" title="LZ77"></a>LZ77</h2>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/">
    <time datetime="2020-11-19T16:00:28.843Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-005.服务实现/存储/redis/redis设计与实现/单机数据库的实现/客户端+服务器" class="post-005.服务实现/存储/redis/redis设计与实现/单机数据库的实现/客户端+服务器 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%AE%A2%E6%88%B7%E7%AB%AF+%E6%9C%8D%E5%8A%A1%E5%99%A8/" data-id="ckhp0x7rm003h932u8vexa3k9" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[TOC]</p>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p><img src="91A6913BE94C441080B88AED607DA234" alt="image"></p>
<p><img src="EE3D36F228774F5BBBA1BE2649CB78CE" alt="image"></p>
<p>Redis 服务器状态 是一个 clients链表，保存了所有与服务器连接的客户端状态结构，查找指定的客户端通过遍历client链表完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct redisServer&#123;</span><br><span class="line">    &#x2F;&#x2F;一个保存所有client的链表</span><br><span class="line">    list *clients;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://images2015.cnblogs.com/blog/1135670/201707/1135670-20170712100233400-391675557.png" alt="image"></p>
<h2 id="客户端属性"><a href="#客户端属性" class="headerlink" title="客户端属性"></a>客户端属性</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef  struct redisClient&#123;</span><br><span class="line">    &#x2F;&#x2F;套接字描述符</span><br><span class="line">    int fd;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;名字</span><br><span class="line">    robj *name;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;标志，记录客户端角色，以及目前所处的状态</span><br><span class="line">    int flag;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;输入缓冲区 用于保存客户端发出的命令请求</span><br><span class="line">    sds querybuf;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;其他 如命令参数，参数个数，输出缓冲区，身份认证，时间</span><br><span class="line">&#125;redisClient;</span><br></pre></td></tr></table></figure>
<h2 id="客户端的创建与关闭"><a href="#客户端的创建与关闭" class="headerlink" title="客户端的创建与关闭"></a>客户端的创建与关闭</h2><p>当客户端与服务器通过网络建立连接时，服务器就会调用连接处理事件，为客户端创建相应的客户端状态，并将新的客户端状态添加到服务器状态结构clients链表的尾链。</p>
<p><img src="https://images2015.cnblogs.com/blog/1135670/201707/1135670-20170712141355509-526445345.png" alt="image"></p>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p><img src="https://images2015.cnblogs.com/blog/1135670/201707/1135670-20170712143302759-782172593.png" alt="image"></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%AE%A2%E6%88%B7%E7%AB%AF+%E6%9C%8D%E5%8A%A1%E5%99%A8/">
    <time datetime="2020-11-19T16:00:28.842Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-005.服务实现/存储/redis/redis设计与实现/多机数据库的实现/集群" class="post-005.服务实现/存储/redis/redis设计与实现/多机数据库的实现/集群 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E9%9B%86%E7%BE%A4/" data-id="ckhp0x7rn003j932u4mxa96r5" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[toc]<br>三、集群</p>
<p> 　　集群实现了分布式数据库解决方案</p>
<h1 id="集群的数据结构"><a href="#集群的数据结构" class="headerlink" title="集群的数据结构"></a>集群的数据结构</h1><p>clusterNode记录自己的状态,并为集群中的其他节点(包括主节点和从节点)都创建了一个相应的clusterNode结构,以此来记录其他节点的状态.</p>
<p><img src="https://images2018.cnblogs.com/blog/1240651/201803/1240651-20180329152840826-1126372871.png" alt="image"></p>
<p>clusterNode的link属性是一个clusterLink结构,该结构保存了连接节点所需的信息,比如套接字描述符,输入缓冲区,输出缓冲区.<br><img src="https://images2018.cnblogs.com/blog/1240651/201803/1240651-20180329153245268-1896750216.png" alt="image"><br>最后,每一个节点都保存这一个clusterState结构,这个结构记录了在当前节点的视角下集群目前的状态:<br><img src="https://images2018.cnblogs.com/blog/1240651/201803/1240651-20180329153805919-122645473.png" alt="image"></p>
<p><img src="https://images2018.cnblogs.com/blog/1240651/201803/1240651-20180329161206363-522633503.png" alt="image"></p>
<h1 id="1、节点：cluster-meet"><a href="#1、节点：cluster-meet" class="headerlink" title="1、节点：cluster meet "></a>1、节点：cluster meet <ip><port></h1><p>　　　　node节点发送上述命令到指定的ip:port节点，它们进行握手，成功后，将指定的ip:port节点添加到node的集群中。</p>
<h1 id="2、启动节点"><a href="#2、启动节点" class="headerlink" title="2、启动节点"></a>2、启动节点</h1><p>　　　　一个节点就是一个运行在集群模式下的redis服务器，根据cluster-enable来判断是否开启集群模式。</p>
<h1 id="3、配置槽位：通过分片方式来保存数据库中的键值对，集群的整个数据库被分为-0-16384个槽位"><a href="#3、配置槽位：通过分片方式来保存数据库中的键值对，集群的整个数据库被分为-0-16384个槽位" class="headerlink" title="3、配置槽位：通过分片方式来保存数据库中的键值对，集群的整个数据库被分为 0~16384个槽位"></a>3、配置槽位：通过分片方式来保存数据库中的键值对，集群的整个数据库被分为 0~16384个槽位</h1><p>clusterNode中的slots属性和numsolts属性记录了节点负责处理哪些槽,</p>
<p>CLUSTER ADDSLOTS命令接受一个或多个槽作为参数,并将输入的槽指派给接受该命令的节点负责.</p>
<p>　　　 cluster addslots &lt;一个或者多个槽位&gt;</p>
<p>　　　节点之间互相同步自己的槽位</p>
<p>　　　 数据库要处理的键属于哪个槽 -&gt;指派当前节点-&gt;没有的话，moved，下一个-&gt;直到找到为止</p>
<p>　　     键槽位算法：cluster keyslot <key></p>
<h1 id="4、重新分片"><a href="#4、重新分片" class="headerlink" title="4、重新分片"></a>4、重新分片</h1><p>　　　　moved  槽的负责权有一个节点转移到另一个节点<br>        ask   槽迁移过程中使用的临时措施<br><img src="https://images2018.cnblogs.com/blog/1240651/201804/1240651-20180421225244249-80507224.png" alt="image">  </p>
<p><img src="https://images2018.cnblogs.com/blog/1240651/201804/1240651-20180421225608218-1742228071.png" alt="image"><br>       clusterState结构中的importing_slots_from数组记录了当前节点正在从其他节点导入的槽；migrating_slots_to数组记录了当前节点正在迁移至其他节点的槽。</p>
<p>接收到ASK错误的客户端会根据错误提供的IP和端口号，然后首先向目标节点发送一个ASKING命令，之后再重新发送要执行的命令。</p>
<p>ASKING命令负责打开客户端的REDIS_ASKING标识，</p>
<p><img src="https://images2018.cnblogs.com/blog/1240651/201804/1240651-20180421230825219-1046434202.png" alt="image"></p>
<h1 id="5、复制故障转移"><a href="#5、复制故障转移" class="headerlink" title="5、复制故障转移"></a>5、复制故障转移</h1><p>　　　　集群分为主节点和从节点，主节点用于处理槽，子节点用于复制主节点   </p>
<p>　　　　在主节点下线时，代替主节点继续处理命令请求。</p>
<p>　　　　cluster replicate <node-id>  node-id 为主节点，接收此命令的节点为子节点<br>　　　　<br>　　　　3.5 复制与故障转移</p>
<h2 id="1-设置从节点"><a href="#1-设置从节点" class="headerlink" title="1 设置从节点"></a>1 设置从节点</h2><p>设置从节点:CLUSTER REPLICATE <node_id></p>
<p>从节点相关设置:</p>
<p>主节点相关设置:</p>
<h2 id="2-故障检测"><a href="#2-故障检测" class="headerlink" title="2 故障检测"></a>2 故障检测</h2><p>集群中的每个节点都会定期向其他节点发送PING消息,如果未在规定时间接收到PONG消息,那么就将该节点标记为疑似下线(PFAIL);</p>
<p>半数以上复杂处理槽的主节点都将某节点标识为疑似下线,则该节点将被标记为FAIL节点.</p>
<h2 id="3-故障转移"><a href="#3-故障转移" class="headerlink" title="3 故障转移"></a>3 故障转移</h2><h2 id="4-选举新的节点"><a href="#4-选举新的节点" class="headerlink" title="4 选举新的节点"></a>4 选举新的节点</h2><p>主节点才有投票权，这个过程与选领头Sentinel的方法非常相似。==两者都是基于Raft算法的领头选举方法实现的。==</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E9%9B%86%E7%BE%A4/">
    <time datetime="2020-11-19T16:00:28.842Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-005.服务实现/存储/redis/redis设计与实现/多机数据库的实现/sentinel哨兵策略 HA" class="post-005.服务实现/存储/redis/redis设计与实现/多机数据库的实现/sentinel哨兵策略 HA post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/sentinel%E5%93%A8%E5%85%B5%E7%AD%96%E7%95%A5%20HA/" data-id="ckhp0x7ro003k932uhb1j0yd2" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>Sentinel</p>
<p> 　　哨兵策略是redis高可用的解决方案（一个或者多个哨兵实例组成的哨兵系统），可以监视多个主服务器。<br><img src="https://images2015.cnblogs.com/blog/1053081/201612/1053081-20161230154322726-1942512342.png" alt="image"></p>
<pre><code>在Server1 掉线后：</code></pre>
<p>　<br>　<img src="https://images2015.cnblogs.com/blog/1053081/201612/1053081-20161230154348742-1055330295.png" alt="image"><br>　<br>　升级Server2 为新的主服务器：<br>　<br>　<img src="https://images2015.cnblogs.com/blog/1053081/201612/1053081-20161230154428320-1980223016.png" alt="image"><br>　　 (1)故障转移</p>
<p>监测到主服务器下线，选举主服务器下的一个从服务器升级为主服务器.<br>通知其他从服务器，更新主服务器地址.<br>监视下线服务器，并将下线的服务器升级为从服务器.</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/sentinel%E5%93%A8%E5%85%B5%E7%AD%96%E7%95%A5%20HA/">
    <time datetime="2020-11-19T16:00:28.842Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-005.服务实现/存储/redis/redis设计与实现/多机数据库的实现/复制" class="post-005.服务实现/存储/redis/redis设计与实现/多机数据库的实现/复制 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%A4%8D%E5%88%B6/" data-id="ckhp0x7ro003l932u7ycn7ptm" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[TOC]</p>
<h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>Redis中，用户通过执行slaveof命令或者设置slaveof选项，让一个服务器去复制另外一个服务器，被复制的服务器为主服务器，对主服务器进行复制的服务器称为从服务器。 </p>
<h1 id="旧版本复制功能分为"><a href="#旧版本复制功能分为" class="headerlink" title="旧版本复制功能分为"></a>旧版本复制功能分为</h1><p>1）同步：将从服务器的数据库状态更新至主服务器当前所处的数据库状态。2)命令传播：主服务器的数据库状态被修改，导致主从数据库的状态不一致，让主从服务器的数据库从新回到一致状态。<br>同步：从服务器对主服务器的同步操作需要通过向主服务器发送SYNC命令来完成。 </p>
<p><img src="https://img-blog.csdn.net/20170526110901667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjMyMTE5MDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<p><img src="https://img-blog.csdn.net/20170526110911657?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMjMyMTE5MDU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<p>命令传播:主服务器会将客户端对它执行的写命令，发送给从服务器，使主从服务器状态保持一致。<br>缺点：断线后重新复制，效率低下[从头开始复制]</p>
<p>新版本复制功能<br>使用PSYNC代替SYNC命令<br>PSYNC命令：完整重同步，部分同步。<br>完整重同步：类似SYNC的初始同步。<br>部分同步：处理断线后复制情况，将主从服务器断开期间执行的写命令发送给从服务器。通过复制偏移量、复制积压缓冲区、服务器运行ID</p>
<ul>
<li>　3、断点续传</li>
<li></li>
<li>　　　　psync 分为完全同步，部分同步</li>
<li></li>
<li>　1)复制偏移量</li>
<li></li>
<li>主服务器每次想从服务器创博N个字节数据时，同时将自己的复制偏移量加N.</li>
<li>从服务器接收N个字节数据，同时更新自己的偏移量加N.　　　　　　　</li>
<li>  2)复制积压缓冲区</li>
<li></li>
<li>主服务器将缓冲区命令发送给从服务器，同时更新复制积压缓冲区，标记命令字节的偏移量。</li>
<li>主服务器会根据这个积压偏移量，选择同步命令的方式。　　　　　　　　　　　　　　</li>
<li>　3)同步服务器ID</li>
<li>　根据ID和存储的ID对比选择不同的同步方式。</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%A4%9A%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E5%A4%8D%E5%88%B6/">
    <time datetime="2020-11-19T16:00:28.842Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-005.服务实现/存储/redis/redis设计与实现/单机数据库的实现/RESP协议" class="post-005.服务实现/存储/redis/redis设计与实现/单机数据库的实现/RESP协议 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/RESP%E5%8D%8F%E8%AE%AE/" data-id="ckhp0x7rl003e932u5zs98ma7" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h1><p>redis协议规范（Redis Protocol specification）。</p>
<p>redis协议在以下几点之间做出了折衷：</p>
<p>　　（1）简单的实现</p>
<p>　　（2）快速地被计算机解析</p>
<p>　　（3）简单得可以能被人工解析</p>
<p>　　（4）网络层，Redis在TCP端口6379上监听到来的连接（本质就是socket），客户端连接到来时，Redis服务器为此创建一个TCP连接。在客户端与服务器端之间传输的每个Redis命令或者数据==都以\r\n结尾。==
　　</p>
<h1 id="回复格式"><a href="#回复格式" class="headerlink" title="回复格式"></a>回复格式</h1><p>Redis用不同的回复类型回复命令。它可能从服务器发送的第一个字节开始校验回复类型：</p>
<p>　　（1）用单行回复，回复的第一个字节将是“+”</p>
<p>　　（2）错误消息，回复的第一个字节将是“-”</p>
<p>　　（3）整型数字，回复的第一个字节将是“:”</p>
<p>　　（4）批量回复，回复的第一个字节将是“$”</p>
<p>　　（5）多个批量回复，回复的第一个字节将是“*”</p>
<p>例子：状态回复（或者单行回复）</p>
<p>以“+”开始以“\r\n”结尾的单行字符串形式。例如：</p>
<p>“+OK\r\n”<br>客户端库将在“+”后面返回所有数据，正如上例中字符串“OK”一样。
　　
　　
　　
　　</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/RESP%E5%8D%8F%E8%AE%AE/">
    <time datetime="2020-11-19T16:00:28.841Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-005.服务实现/存储/redis/redis设计与实现/单机数据库的实现/RDB-AOF持久化" class="post-005.服务实现/存储/redis/redis设计与实现/单机数据库的实现/RDB-AOF持久化 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/RDB-AOF%E6%8C%81%E4%B9%85%E5%8C%96/" data-id="ckhp0x7rm003f932ueqwj4oyv" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[toc]<br>因为Redis 是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见</p>
<h1 id="RDB【保存的是二进制文件】"><a href="#RDB【保存的是二进制文件】" class="headerlink" title="RDB【保存的是二进制文件】"></a>RDB【保存的是二进制文件】</h1><p>为了解决这个问题，Redis提供了RDB持久化功能，这个功能可以将Redis 在内存中的数据库状态保存到磁盘里面，避免数据意外丢失</p>
<p>RDB持久化既可以手动执行，也可以根据服务器配置选项定期执行，该功能可以将某个时间点上的数据库状态保存到一个RDB文件中，如图10-2所示<br><img src="https://images2015.cnblogs.com/blog/1067264/201612/1067264-20161201171039865-192573692.png" alt="image"><br>RDB 持久化功能所生==成的RDB 文件是一个经过压缩的二进制文件==，通过该文件可以还原生成RDB 文件时的数据库状态，如图1 0-3所示</p>
<p>==因为RDB文件是保存在硬盘里面的，所以即使Redis服务器进程退出，甚至运行Redis服务器的计算机停机，但只要RDB文件仍然存在，Redis服务器就可以用它来还原数据库状态==</p>
<h2 id="RDB文件的创建与载入【save-BGSAVE】"><a href="#RDB文件的创建与载入【save-BGSAVE】" class="headerlink" title="RDB文件的创建与载入【save BGSAVE】"></a>RDB文件的创建与载入【save BGSAVE】</h2><p>有两个Redis命令可以用于生成RDB文件，一个是SAVE，另一个是BGSAVE</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">和SAVE命令直接阻塞服务器进程的做法不同，BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB 文件，服务器进程(父进程)继续处理命令请求</span><br></pre></td></tr></table></figure>
<h2 id="RDB-的自动载入"><a href="#RDB-的自动载入" class="headerlink" title="RDB 的自动载入"></a>RDB 的自动载入</h2><p>和使用SAVE命令或者BGSAVE命令创建RDB文件不同，==RDB 文件的载入工作是在服务启动时自动执行的==，所以Redis并没有专门用于载入RDB文件的命令，只要Redis服务器在启动时检测到RDB文件存在，它就会自动载入RDB文件</p>
<p>==为AOF文件的更新频率通常比RDB 文件的更新频率高，所以如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态==<br>只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB 文件来还原数据库状态服务器判断该用哪个文件来还原数据库状态的流程如图10-4 所示</p>
<p><img src="https://images2015.cnblogs.com/blog/1067264/201612/1067264-20161201172319287-676349921.png" alt="image"></p>
<h3 id="服务器在载入RDB-文件期间，会一直处于阻塞状态，直到载入工作完成为止"><a href="#服务器在载入RDB-文件期间，会一直处于阻塞状态，直到载入工作完成为止" class="headerlink" title="服务器在载入RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止"></a>服务器在载入RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止</h3><h3 id="自动间隔性保存"><a href="#自动间隔性保存" class="headerlink" title="自动间隔性保存"></a>自动间隔性保存</h3><h3 id="dirty计数器和lastsave属性"><a href="#dirty计数器和lastsave属性" class="headerlink" title="dirty计数器和lastsave属性"></a>dirty计数器和lastsave属性</h3><p>除了saveparams数组之外，服务器状态还维持着一个dirty计数器，以及一个lastsave属性:</p>
<p>dirty计数器记录距离上一次成功执行SAVE命令或者BGSAVE命令之后，服务器对数据库状态(服务器中的所有数据库)进行了多少次修改(包括写入、删除、更新等操作)。<br>lastsave属性是一个UNIX时间戳，记录了服务器上一次成功执行SAVE命令或者BGSAVE命令的时间。</p>
<p>当服务器成功执行一个数据库修改命令之后，程序就会对dirty计数器进行更新:命令修改了多少次数据库.dirty计数器的值就增加多少。<br>例如，如果我们为一个字符串键设置值:</p>
<h1 id="AOF【保存的是命令】"><a href="#AOF【保存的是命令】" class="headerlink" title="AOF【保存的是命令】"></a>AOF【保存的是命令】</h1><h2 id="AOF-配置"><a href="#AOF-配置" class="headerlink" title="AOF 配置"></a>AOF 配置</h2><p>为了打开 AOF 持久化的功能，我们只需要将 redis.conf 配置文件中的appendonly配置选项设置为yes即可。涉及 AOF 持久化的几个常用配置如下所示：</p>
<p><img src="https://img-blog.csdn.net/20170718000028777?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<p><img src="https://img-blog.csdn.net/20170718000048891?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGloYW8yMQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<h2 id="AOF-文件的生成过程具体包括命令追加，文件写入，文件同步三个步骤。"><a href="#AOF-文件的生成过程具体包括命令追加，文件写入，文件同步三个步骤。" class="headerlink" title="AOF 文件的生成过程具体包括命令追加，文件写入，文件同步三个步骤。"></a>AOF 文件的生成过程具体包括命令追加，文件写入，文件同步三个步骤。</h2><p>AOF 文件的生成过程具体包括命令追加，文件写入，文件同步三个步骤。<br>Redis 打开 AOF 持久化功能后，Redis 在执行完一个写命令后，都会将执行的写命令追回到 Redis 内部的缓冲区的末尾。这个过程是命令的追加过程。<br>接下来，缓冲区的写命令会被写入到 AOF 文件，这一过程是文件写入过程。对于操作系统来说，调用write函数并不会立刻将数据写入到硬盘，为了将数据真正写入硬盘，还需要调用fsync函数，调用fsync函数即是文件同步的过程。只有经过文件同步过程，AOF 文件才在硬盘中真正保存了 Redis 的写命令。appendfsync 配置选项正是用来配置将写命令同步到文件的频率的，各个选项的值的含义如表 1 所示。</p>
<p>==appendonly.aof以 Redis 协议格式 RESP 来保存写命令==<br>appendonly.aof保存的命令会在 Redis 下次重启时使用来还原 Redis 数据库。</p>
<h2 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h2><p>由于 Redis 会不断地将被执行的命令记录到 AOF 文件里面，所以随着 Redis 不断运行，AOF 文件的体积会越来越大。另外，如果 AOF 文件的体积很大，那么还原操作所需要的时间也会非常地长。<br>为了解决 AOF 文件越来越大的问题，用户可以向 Redis 发送 BGREWRITEAOF 命令，==这个命令会移除 AOF 文件中冗余的命令来重写 AOF 文件==，使 AOF 文件的体积变得尽可能地小。<br>BGREWRITEAOF 的工作原理和快照持久化命令 BGSAVE 的工作原理类似，Redis 会创建一个子进程来负责对 AOF 文件进行重写。 </p>
<h1 id="RDB和AOF对比"><a href="#RDB和AOF对比" class="headerlink" title="RDB和AOF对比"></a>RDB和AOF对比</h1><h2 id="RDB存在哪些优势呢？"><a href="#RDB存在哪些优势呢？" class="headerlink" title="RDB存在哪些优势呢？"></a>RDB存在哪些优势呢？</h2><p>1). 一旦采用该方式【紧凑】，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。</p>
<p>2). 对于灾难恢复而言，RDB是非常不错的选择</p>
<p>3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</p>
<p>4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p>
<h2 id="RDB又存在哪些劣势呢？"><a href="#RDB又存在哪些劣势呢？" class="headerlink" title="RDB又存在哪些劣势呢？"></a>RDB又存在哪些劣势呢？</h2><p>1). 数据的高可用性低。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p>
<p>2). 由于RDB是通过fork子进程，数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p>
<h2 id="AOF的优势有哪些呢？"><a href="#AOF的优势有哪些呢？" class="headerlink" title="AOF的优势有哪些呢？"></a>AOF的优势有哪些呢？</h2><p>1). 该机制可以带来更高的数据安全性，及时，迅速不怕宕机</p>
<p>2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</p>
<p>3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</p>
<p>4). AOF格式易读</p>
<h2 id="AOF的劣势有哪些呢？"><a href="#AOF的劣势有哪些呢？" class="headerlink" title="AOF的劣势有哪些呢？"></a>AOF的劣势有哪些呢？</h2><p>1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</p>
<p>2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</p>
<p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/RDB-AOF%E6%8C%81%E4%B9%85%E5%8C%96/">
    <time datetime="2020-11-19T16:00:28.841Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-005.服务实现/存储/redis/redis设计与实现/单机数据库的实现/redis事件" class="post-005.服务实现/存储/redis/redis设计与实现/单机数据库的实现/redis事件 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/redis%E4%BA%8B%E4%BB%B6/" data-id="ckhp0x7rm003g932udmko4v0k" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[TOC]<br>文件事件（file event）<br>Redis服务器通过套接字与客户端（或其他Redis服务器）连接，文件事件是服务器对套接字操作的抽象<br>服务器与客户端（或其他Redis服务器）通信产生文件事件，服务器通过监听并处理这些事件完成一系列网络通信操作</p>
<p>时间事件（time event）<br>Redis服务器中一些操作（如serverCron函数）需在给定时间点执行，时间事件是服务器对这类定时操作的抽象</p>
<h1 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h1><p><img src="https://img-blog.csdn.net/20170817185916894?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmluZzAzMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，会产生一个文件事件<br>因一个服务器通常会连接多个套接字，故多个文件事件可能会并发出现</p>
<h2 id="I-O多路复用程序"><a href="#I-O多路复用程序" class="headerlink" title="I/O多路复用程序"></a>I/O多路复用程序</h2><p>通过包装==select、epoll、evport和kqueue这些I/O多路复用函数库==实现<br>负责监听多个套接字，并向文件事件分派器传送产生了事件的套接字<br>I/O多路复用程序将产生事件的套接字放到一个队列中，通过该队列，以==有序（sequentially）、同步（synchronously）、每次一个的方式向文件事件分派器传送套接字==<br>上一个传送的套接字事件处理完毕后（关联的事件处理器执行完毕后），I/O多路复用程序才会向文件事件分派器传送下一个套接字</p>
<h2 id="文件事件分派器"><a href="#文件事件分派器" class="headerlink" title="文件事件分派器"></a>文件事件分派器</h2><p>接收I/O多路复用程序传来的套接字，根据套接字产生的事件类型，调用相应事件处理器<br>事件处理器<br>处理器是一个函数，定义某个事件发生时，服务器应执行的动作</p>
<h2 id="事件类型-AE-READABLE和AE-WRITABLE事件"><a href="#事件类型-AE-READABLE和AE-WRITABLE事件" class="headerlink" title="事件类型 AE_READABLE和AE_WRITABLE事件"></a>事件类型 AE_READABLE和AE_WRITABLE事件</h2><p>I/O多路复用程序可监听多个套接字的AE_READABLE和AE_WRITABLE事件</p>
<ul>
<li>·套接字变得可读（客户端对套接字执行write或close操作）或有新的可应答套接字（客户端对服务器监听套接字执行connect操作）出现时，套接字产生AE_READABLE事件</li>
<li>·套接字变得可写（客户端对套接字执行read操作）时，套接字产生AE_WRITABLE事件</li>
<li>注，Redis服务器优先处理同一个套接字的AE_READABLE事件，即，服务器先读套接字，后写套接字</li>
</ul>
<h1 id="事件处理器"><a href="#事件处理器" class="headerlink" title="事件处理器"></a>事件处理器</h1><h2 id="连接应答处理器"><a href="#连接应答处理器" class="headerlink" title="连接应答处理器"></a>连接应答处理器</h2><p>对连接服务器的各个客户端进行应答<br>Redis初始化时，将监听套接字的AE_READABLE事件与该处理器关联<br>客户端连接服务器时，产生AE_READABLE事件</p>
<h2 id="命令请求处理器"><a href="#命令请求处理器" class="headerlink" title="命令请求处理器"></a>命令请求处理器</h2><p>接收客户端传来的命令请求<br>客户端成功连接服务器后，Redis将该客户端套接字的AE_READABLE事件与该处理器关联<br>客户端向服务器发送命令请求时，产生AE_READABLE事件<br>客户端连接服务器过程中，该客户端套接字的AE_READABLE事件始终与该处理器关联</p>
<h2 id="命令回复处理器"><a href="#命令回复处理器" class="headerlink" title="命令回复处理器"></a>命令回复处理器</h2><p>向客户端返回命令执行结果<br>服务器有命令执行结果要传送给客户端时，将客户端套接字的AE_WRITABLE事件始终与该处理器关联<br>客户端准备好接收命令执行结果时，产生AE_WRITABLE事件<br>命令执行结果传送结束后，关联解除</p>
<h2 id="复制处理器"><a href="#复制处理器" class="headerlink" title="复制处理器"></a>复制处理器</h2><p>处理主服务器和从服务器复制操作</p>
<h1 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h1><h2 id="定时事件"><a href="#定时事件" class="headerlink" title="定时事件"></a>定时事件</h2><p>指定时间后执行一次<br>事件处理器返回AE_NOMORE，该事件达到一次后被删除</p>
<h2 id="周期事件"><a href="#周期事件" class="headerlink" title="周期事件"></a>周期事件</h2><p>每隔指定时间执行一次<br>事件处理器返回非AE_NOMORE整数值，根据该值更新when属性，让该事件在一段时间后再次到达</p>
<h2 id="时间事件3个属性"><a href="#时间事件3个属性" class="headerlink" title="时间事件3个属性"></a>时间事件3个属性</h2><ol>
<li>·id：全局唯一，递增分配</li>
<li>·when：毫秒精度UNIX时间戳，记录时间事件的到达时间</li>
<li>·timeProc：时间事件处理器，一个函数，时间事件到达时，服务器调用相应处理器处理事件</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>服务器==将所有时间事件放在一个无序链表（when属性无序，id有序）<br>当时间事件执行器运行时遍历整个链表，查找所有已到达的时间事件<br>然后调用相应事件处理器==</p>
<h2 id="serverCron函数主要工作（执行定期操作-定期对自身资源和状态-检查和调整）"><a href="#serverCron函数主要工作（执行定期操作-定期对自身资源和状态-检查和调整）" class="headerlink" title="serverCron函数主要工作（执行定期操作 定期对自身资源和状态 检查和调整）"></a>serverCron函数主要工作（执行定期操作 定期对自身资源和状态 检查和调整）</h2><p>·更新服务器各类统计信息，如时间、内存占用、数据库占用情况等<br>·清理数据库过期键值对<br>·关闭和清理连接失效客户端<br>·尝试进行AOF或RDB持久化操作<br>·若服务器是主服务器，则对从服务器进行定期同步<br>·若服务器处于集群模式，则对集群进行定期同步和连接测试</p>
<h2 id="文件事件和时间事件的调度和执行规则"><a href="#文件事件和时间事件的调度和执行规则" class="headerlink" title="文件事件和时间事件的调度和执行规则"></a>文件事件和时间事件的调度和执行规则</h2><ul>
<li><ol>
<li>aeApiPoll函数最大阻塞时间，由到达时间最接近当前时间的时间事件决定。该方法既可避免频繁轮询时间事件（忙等待），也可确保aeApiPoll函数不会阻塞过长时间</li>
</ol>
</li>
<li><ol start="2">
<li>因文件事件随机出现，若等待并处理完一次文件事件后仍未有任何时间事件到达，则服务器将再次等待并处理文件事件</li>
</ol>
</li>
<li><ol start="3">
<li>文件事件和时间事件的处理都是同步、有序、原子地执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，故，文件事件和时间事件的处理器都会尽可能的减少程序阻塞时间，并在有需要时主动让出执行权，从而降低造成事件饥饿的可能性</li>
</ol>
</li>
<li><ol start="4">
<li>因时间事件在文件事件后执行，且事件间不会出现抢占，故时间事件实际处理时间通常会比时间事件设定的到达时间稍晚一些</li>
</ol>
</li>
</ul>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/redis%E4%BA%8B%E4%BB%B6/">
    <time datetime="2020-11-19T16:00:28.841Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-005.服务实现/存储/redis/redis设计与实现/单机数据库的实现/数据库键过期和切换数据库" class="post-005.服务实现/存储/redis/redis设计与实现/单机数据库的实现/数据库键过期和切换数据库 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E8%BF%87%E6%9C%9F%E5%92%8C%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%BA%93/" data-id="ckhp0x7rn003i932u1fp2f4a2" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[TOC]</p>
<h1 id="redis-数据库保存在-redisServer-db里，数据库数量在-redisServer-dbnum中"><a href="#redis-数据库保存在-redisServer-db里，数据库数量在-redisServer-dbnum中" class="headerlink" title="redis 数据库保存在 redisServer.db里，数据库数量在 redisServer.dbnum中"></a>redis 数据库保存在 redisServer.db里，数据库数量在 redisServer.dbnum中</h1><h1 id="读写健空间的维护操作"><a href="#读写健空间的维护操作" class="headerlink" title="读写健空间的维护操作"></a>读写健空间的维护操作</h1><ol>
<li>在读取一个键后（读操作和写操作都要对键进行读取），服务器会根据键是否存在来更新服务器的键空间命中（hit）次数或键空间不命中（miss）次数，这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看。</li>
<li>在读取一个键后，服务器会更新键的LRU（最后一次使用）时间，这个值可以用于计算键的闲置时间，使用OBJECT idletime<key>命令可以查看键key的闲置时间。</li>
<li>如果服务器在读取一个键时发现该键已经过期，那么服务器会先删除这个过期键，然后才执行余下的其他操作。</li>
<li>如果有客户端使用WATCH命令监视了某个键，那么服务器在对被监视的键及进行修改之后，会将这个键标记为脏（dirty），从而让事务程序注意到这个键已经被修改过。</li>
<li>服务器每次修改一个键之后，都会对脏（dirty）键计数器的值增1，这个计数器会触发服务器的持久化以及复制操作。</li>
<li>如果服务器开启了数据库通知功能，那么在对键进行修改之后，服务器将按配置发送相应的数据库通知。</li>
</ol>
<h1 id="设置键的生存时间和过期时间【时间戳】"><a href="#设置键的生存时间和过期时间【时间戳】" class="headerlink" title="设置键的生存时间和过期时间【时间戳】"></a>设置键的生存时间和过期时间【时间戳】</h1><ul>
<li>EXPIRE <KEY> <TTL> : 将键的生存时间设为 ttl 秒</li>
<li>PEXPIRE <KEY> <TTL> :将键的生存时间设为 ttl 毫秒</li>
<li>EXPIREAT <KEY> <timestamp> :将键的过期时间设为 timestamp 所指定的秒数时间戳</li>
<li>PEXPIREAT <KEY> <timestamp>: 将键的过期时间设为 timestamp 所指定的毫秒数时间戳.<h2 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h2><h2 id="过期键的判定"><a href="#过期键的判定" class="headerlink" title="过期键的判定"></a>过期键的判定</h2></li>
</ul>
<p>通过过期字典，程序可以用以下步骤检查一个给定键是否过期:</p>
<ul>
<li>1 )检查给定键是否存在于过期字典:如果存在，那么取得键的过期时间。</li>
<li>2 )检查当前UNIX 时间戳是否大于键的过期时间: 如果是的话，那么键已经过期;否则的话，键未过期<h2 id="redis过期键的删除策略"><a href="#redis过期键的删除策略" class="headerlink" title="redis过期键的删除策略"></a>redis过期键的删除策略</h2></li>
</ul>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>的是不主动删除，当用户访问已经过期的对象的时候才删除，最大的优点是节省cpu的开销，不用另外的内存和TTL链表来维护删除信息，缺点就是如果数据到期了但是一直没有被访问的话就不会被删除，会占用内存空间。</p>
<h3 id="定时任务删除"><a href="#定时任务删除" class="headerlink" title="定时任务删除"></a>定时任务删除</h3><p><img src="https://img-blog.csdn.net/2018072910094364?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RyMTkxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"><br><img src="https://img-blog.csdn.net/2018072910094364?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RyMTkxMg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<p>过期占比配置可修改</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%8D%95%E6%9C%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%9E%E7%8E%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%AE%E8%BF%87%E6%9C%9F%E5%92%8C%E5%88%87%E6%8D%A2%E6%95%B0%E6%8D%AE%E5%BA%93/">
    <time datetime="2020-11-19T16:00:28.840Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-005.服务实现/存储/redis/redis设计与实现/独立功能的实现/事务+排序" class="post-005.服务实现/存储/redis/redis设计与实现/独立功能的实现/事务+排序 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/%E4%BA%8B%E5%8A%A1+%E6%8E%92%E5%BA%8F/" data-id="ckhp0x7rt003u932u9q4w3taz" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[TOC]<br>事务</p>
<h2 id="什么事redis的事务"><a href="#什么事redis的事务" class="headerlink" title="什么事redis的事务"></a>什么事redis的事务</h2><p>Redis 通过 MULTI 、 DISCARD 、 EXEC 和 WATCH 四个命令来实现事务功能，WATCH 比较特殊</p>
<p>==事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制， 并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。==</p>
<p>一个事务从开始到执行会经历以下三个阶段：</p>
<p>开始事务。<br>命令入队。<br>执行事务。<br>下文将分别介绍事务的这三个阶段。</p>
<h2 id="三个阶段"><a href="#三个阶段" class="headerlink" title="三个阶段"></a>三个阶段</h2><h3 id="开始事务"><a href="#开始事务" class="headerlink" title="开始事务"></a>开始事务</h3><p>这个命令唯一做的就是， 将客户端的 REDIS_MULTI 选项打开， 让客户端从非事务状态切换到事务状态。<br><img src="https://redisbook.readthedocs.io/en/latest/_images/graphviz-0ff9f2e58803dbb8c1c400e1f8191f77d4c2917e.svg" alt="image"></p>
<h3 id="命令入队"><a href="#命令入队" class="headerlink" title="命令入队"></a>命令入队</h3><p>当客户端处于非事务状态下时， 所有发送给服务器端的命令都会立即被服务器执行：</p>
<p>但是， 当客户端进入事务状态之后， 服务器在收到来自客户端的命令时， 不会立即执行命令， 而是将这些命令全部放进一个事务队列里， 然后返回 QUEUED ， 表示命令已入队：<br><img src="https://redisbook.readthedocs.io/en/latest/_images/graphviz-8a0f8eae0bb8180e877b799921dd690267c2d3b4.svg" alt="image"></p>
<h3 id="执行事务"><a href="#执行事务" class="headerlink" title="执行事务"></a>执行事务</h3><p>实并不是所有的命令都会被放进事务队列， 其中的例外就是 EXEC 、 DISCARD 、 MULTI 和 WATCH 这四个命令 —— 当这四个命令从客户端发送到服务器时， 它们会像客户端处于非事务状态一样， 直接被服务器执行：<br><img src="https://redisbook.readthedocs.io/en/latest/_images/graphviz-836c8a3dc33526a649d9ecf5b7b959d72b38cc7d.svg" alt="image"></p>
<p>以先进先出（FIFO）的方式执行事务队列中的命令： 最先入队的命令最先执行， 而最后入队的命令最后执行。</p>
<h2 id="事务状态下的-DISCARD-、-MULTI-和-WATCH-命令"><a href="#事务状态下的-DISCARD-、-MULTI-和-WATCH-命令" class="headerlink" title="事务状态下的 DISCARD 、 MULTI 和 WATCH 命令"></a>事务状态下的 DISCARD 、 MULTI 和 WATCH 命令</h2><p>除了 EXEC 之外， 服务器在客户端处于事务状态时， 不加入到事务队列而直接执行的另外三个命令是 DISCARD 、 MULTI 和 WATCH 。</p>
<p>DISCARD 命令用于取消一个事务， 它清空客户端的整个事务队列， 然后将客户端从事务状态调整回非事务状态， 最后返回字符串 OK 给客户端， 说明事务已被取消。</p>
<p>==Redis 的事务是不可嵌套的==， 当客户端已经处于事务状态， 而客户端又再向服务器发送 MULTI 时， 服务器只是简单地向客户端发送一个错误， 然后继续等待其他命令的入队。 MULTI 命令的发送不会造成整个事务失败， 也不会修改事务队列中已有的数据。</p>
<p>WATCH 只能在客户端进入事务状态之前执行， 在事务状态下发送 WATCH 命令会引发一个错误， 但它不会造成整个事务失败， 也不会修改事务队列中已有的数据（和前面处理 MULTI 的情况一样）。</p>
<p>带 WATCH 的事务<br>==WATCH 命令用于在事务开始之前监视任意数量的键： 当调用 EXEC 命令执行事务时， 如果任意一个被监视的键已经被其他客户端修改了， 那么整个事务不再执行， 直接返回失败。==</p>
<p>在时间 T4 ，客户端 B 修改了 name 键的值， 当客户端 A 在 T5 执行 EXEC 时，Redis 会发现 name 这个被监视的键已经被修改， 因此客户端 A 的事务不会被执行，而是直接返回失败。</p>
<h2 id="WATCH-命令的实现"><a href="#WATCH-命令的实现" class="headerlink" title="WATCH 命令的实现"></a>WATCH 命令的实现</h2><p>在每个代表数据库的 redis.h/redisDb 结构类型中， 都保存了一个 watched_keys 字典， 字典的键是这个数据库被监视的键， 而字典的值则是一个链表， 链表中保存了所有监视这个键的客户端。</p>
<p><img src="https://redisbook.readthedocs.io/en/latest/_images/graphviz-9aea81f33da1373550c590eb0b7ca0c2b3d38366.svg" alt="image"></p>
<p>其中， 键 key1 正在被 client2 、 client5 和 client1 三个客户端监视， 其他一些键也分别被其他别的客户端监视着。</p>
<p>WATCH 命令的作用， 就是将当前客户端和要监视的键在 watched_keys 中进行关联。</p>
<p><img src="https://redisbook.readthedocs.io/en/latest/_images/graphviz-fe5e31054c282a3cdd86656994fe1678a3d4f201.svg" alt="image"></p>
<p>通过 watched_keys 字典， 如果程序想检查某个键是否被监视， 那么它只要检查字典中是否存在这个键即可； 如果程序要获取监视某个键的所有客户端， 那么只要取出键的值（一个链表）， 然后对链表进行遍历即可。</p>
<h2 id="WATCH-的触发"><a href="#WATCH-的触发" class="headerlink" title="WATCH 的触发"></a>WATCH 的触发</h2><p>没<br>在任何对数据库键空间（key space）进行修改的命令成功执行之后 （比如 FLUSHDB 、 SET 、 DEL 、 LPUSH 、 SADD 、 ZREM ，诸如此类）， multi.c/touchWatchedKey 函数都会被调用 —— 它检查数据库的 watched_keys 字典， 看是否有客户端在监视已经被命令修改的键， 如果有的话， 程序将所有监视这个/这些被修改键的客户端的 REDIS_DIRTY_CAS 选项打开：</p>
<p><img src="https://redisbook.readthedocs.io/en/latest/_images/graphviz-e5c66122242aa10939b696dfeeb905343c5202bd.svg" alt="image"></p>
<p>如果某个客户端对 key1 进行了修改（比如执行 DEL key1 ）， 那么所有监视 key1 的客户端， 包括 client2 、 client5 和 client1 的 REDIS_DIRTY_CAS 选项都会被打开， 当客户端 client2 、 client5 和 client1 执行 EXEC 的时候， 它们的事务都会以失败告终。</p>
<p><img src="https://redisbook.readthedocs.io/en/latest/_images/graphviz-9aea81f33da1373550c590eb0b7ca0c2b3d38366.svg" alt="image"></p>
<h2 id="事务的-ACID-性质"><a href="#事务的-ACID-性质" class="headerlink" title="事务的 ACID 性质"></a>事务的 ACID 性质</h2><p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的安全性。</p>
<p>==Redis 事务保证了其中的一致性（C）和隔离性（I）==，但并不保证原子性（A）和持久性（D）。</p>
<p>以下四小节是关于这四个性质的详细讨论。</p>
<h2 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h2><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p>
<p>如果一个事务队列中的所有命令都被成功地执行，那么称这个事务执行成功。</p>
<p>另一方面，如果 Redis 服务器进程在执行事务的过程中被停止 —— 比如接到 KILL 信号、宿主机器停机，等等，那么事务执行失败。</p>
<p>==当事务失败时，Redis 也不会进行任何的重试或者回滚动作==</p>
<h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>Redis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。</p>
<h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>Redis 的一致性问题可以分为三部分来讨论：入队错误、执行错误、Redis 进程被终结。</p>
<h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>因为事务不过是用队列包裹起了一组 Redis 命令，并没有提供任何额外的持久性功能，所以事务的持久性由 Redis 所使用的持久化模式决定：</p>
<p>在单纯的内存模式下，事务肯定是不持久的。</p>
<p>在 RDB 模式下，服务器可能在事务执行之后、RDB 文件更新之前的这段时间失败，所以 RDB 模式下的 Redis 事务也是不持久的。</p>
<p>在 AOF 的“总是 SYNC ”模式下，事务的每条命令在执行成功之后，都会立即调用 fsync 或 fdatasync 将事务数据写入到 AOF 文件。但是，这种保存是由后台线程进行的，主线程不会阻塞直到保存成功，所以从命令执行成功到数据保存到硬盘之间，还是有一段非常小的间隔，所以这种模式下的事务也是不持久的。</p>
<p>其他 AOF 模式也和“总是 SYNC ”模式类似，所以它们都是不持久的。</p>
<h2 id="小结¶"><a href="#小结¶" class="headerlink" title="小结¶"></a>小结¶</h2><ol>
<li>事务提供了一种将多个命令打包，然后一次性、有序地执行的机制。</li>
<li>事务在执行过程中不会被中断，所有事务命令执行完之后，事务才能结束。</li>
<li>多个命令会被入队到事务队列中，然后按先进先出（FIFO）的顺序执行。</li>
<li>带 WATCH 命令的事务会将客户端和被监视的键在数据库的 watched_keys 字典中进行关联，当键被修改时，程序会将所有监视被修改键的客户端的 REDIS_DIRTY_CAS 选项打开。</li>
<li>只有在客户端的 REDIS_DIRTY_CAS 选项未被打开时，才能执行事务，否则事务直接返回失败。</li>
<li>Redis 的事务保证了 ACID 中的一致性（C）和隔离性（I），但并不保证原子性（A）和持久性（D）。</li>
</ol>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0/%E4%BA%8B%E5%8A%A1+%E6%8E%92%E5%BA%8F/">
    <time datetime="2020-11-19T16:00:28.840Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/huanghao.github.io/page/4/">&amp;laquo; Prev</a><a class="page-number" href="/huanghao.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/huanghao.github.io/page/3/">3</a><a class="page-number" href="/huanghao.github.io/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/huanghao.github.io/page/6/">6</a><a class="page-number" href="/huanghao.github.io/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/huanghao.github.io/page/15/">15</a><a class="extend next" rel="next" href="/huanghao.github.io/page/6/">Next &amp;raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E6%89%80%E8%B0%93%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E4%BD%9C%E7%94%A8%E5%9F%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80%E7%B1%BB%E6%A6%82%E8%AE%BA/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%80%A7%E8%83%BD%E8%B0%83%E6%A0%91+%E9%83%A8%E7%BD%B2+%E6%B5%8B%E8%AF%95/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 huanghao
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/huanghao.github.io/fancybox/jquery.fancybox.css">

  
<script src="/huanghao.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/huanghao.github.io/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>