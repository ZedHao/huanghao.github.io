<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="一剑光寒十九州" />
  

  
  
  
  
  
  
  <title>NK一哥黄大脸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一剑光寒十九州">
<meta property="og:type" content="website">
<meta property="og:title" content="NK一哥黄大脸">
<meta property="og:url" content="https://zedhao.github.io/huanghao.github.io/page/11/index.html">
<meta property="og:site_name" content="NK一哥黄大脸">
<meta property="og:description" content="一剑光寒十九州">
<meta property="og:locale">
<meta property="article:author" content="huanghao">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/huanghao.github.io/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/huanghao.github.io/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/huanghao.github.io/atom.xml" title="NK一哥黄大脸" type="application/atom+xml">
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/huanghao.github.io/" title="NK一哥黄大脸" rel="home">NK一哥黄大脸</a>
      </h1>
      
        <h2 <title>谦谦君子 温润如玉</title></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/archives">Archives</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/guestbook">guestbook</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-004.网络/计算机网络概念" class="post-004.网络/计算机网络概念 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/" data-id="ckhp0x7q3000e932ugpf1dz0r" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="分组交换协议"><a href="#分组交换协议" class="headerlink" title="分组交换协议"></a>分组交换协议</h1><p><img src="8C1F315AB7CB4153BBE636BEA80100B8" alt="image"></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/">
    <time datetime="2020-11-19T16:00:28.812Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-004.网络/网络层 IP协议等/DNS和ARP" class="post-004.网络/网络层 IP协议等/DNS和ARP post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%20IP%E5%8D%8F%E8%AE%AE%E7%AD%89/DNS%E5%92%8CARP/" data-id="ckhp0x7qr001l932u51hwdhb1" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="ARP-和-DNS"><a href="#ARP-和-DNS" class="headerlink" title="ARP 和 DNS"></a>ARP 和 DNS</h1><p>ARP是以目标IP地址为索引，来定位下一个应该接受数据分包的网络设备的对应的MAC地址，简单点说，ARP就是用来进行IP地址到MAC地址的对应。</p>
<p>ARP的工作原理：简单点说，ARP就是通过ARP请求与ARP响应两种包来确定MAC地址。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%20IP%E5%8D%8F%E8%AE%AE%E7%AD%89/DNS%E5%92%8CARP/">
    <time datetime="2020-11-19T16:00:28.811Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-004.网络/网络层 IP协议等/IP协议 子网掩码 MAC地址" class="post-004.网络/网络层 IP协议等/IP协议 子网掩码 MAC地址 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%20IP%E5%8D%8F%E8%AE%AE%E7%AD%89/IP%E5%8D%8F%E8%AE%AE%20%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%20MAC%E5%9C%B0%E5%9D%80/" data-id="ckhp0x7qs001m932ucvm2f4t4" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="ip协议的作用"><a href="#ip协议的作用" class="headerlink" title="ip协议的作用"></a>ip协议的作用</h1><p>网络层的主要作用是“实现终端节点之间的通信”，也就是点对点的通信。==IP协议主要负责将数据包发送给最终的目标计算机。==前面我们讲过链路层主要是负责数据在链路中进行传输，那么网络层和链路层有什么联系呢？</p>
<p>主要是子网的通信 例如北京发往东京的数据包，</p>
<h1 id="子网掩码【判断是同一网络还是不同网络】"><a href="#子网掩码【判断是同一网络还是不同网络】" class="headerlink" title="子网掩码【判断是同一网络还是不同网络】"></a>子网掩码【判断是同一网络还是不同网络】</h1><p><img src="494ED7FA0AFB42B5A0B617260EC9C5C2" alt="image"></p>
<p>从前有一个地主，有256间房子，地主家的门牌号码是“192.168.1”，那么他家第一间房子的门牌号码是192.168.1.0，第二间是192.168.1.1，…第256间的编号是192.168.1.255。地主老了，需要把256间房子分给4个儿子，平均分配，每个儿子可以分64间。</p>
<p>请来一位先生主持公道，先生这么来操作：192.168.1.0-192.168.1.63 分给大儿子192.168.1.64-192.168.1.127 分给二儿子192.168.1.128 -192.168.1.191 分给三儿子192.168.1.192-192.168.1.255</p>
<p>分给四儿子那如何来描述四个儿子的子网网段呢？192.168.1.0/26192.168.1.64/26192.168.1.128/26192.168.1.192/26/26是什么鬼？255.255.255.192的二进制是多少？</p>
<p>“11111111-11111111-11111111-11”大家数数一共多少个1？不用数了，是26个1，为了简化子网掩码的表示，用/26代替255.255.255.192。按位与运算我们来看大儿子的网段192.168.1.0/26是如何得到的？以大儿子的房间为例：192.168.1.0-192.168.1.63二进制表示：192.168.1.011000000.10101000.00000001.00000000192.168.1.6311000000.10101000.00000001.00111111首尾地址完全相同的是多少？11000000.10101000.00000001.00数数一共多少位？26位！</p>
<p>那么用这个“192.168.1.0/26”就可以表示大儿子所有房间。对照房间的门牌号码“192.168.1.199”，很显然属于四儿子的。一个主机192.168.1.199/26 能否和直连主机192.168.1.200/24 通信？可以的，因为都是四儿子的房间。</p>
<p>一个主机192.168.1.199/26 能否和直连主机192.168.1.1/24 通信？ 不可以，因为一个是大儿子的房间，一个是四儿子的房间，无法直连通信！</p>
<h1 id="mac地址-计算机的身份证"><a href="#mac地址-计算机的身份证" class="headerlink" title="mac地址 计算机的身份证"></a>mac地址 计算机的身份证</h1>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%B1%82%20IP%E5%8D%8F%E8%AE%AE%E7%AD%89/IP%E5%8D%8F%E8%AE%AE%20%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%20MAC%E5%9C%B0%E5%9D%80/">
    <time datetime="2020-11-19T16:00:28.811Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-004.网络/OSI 七+TCP-IP四" class="post-004.网络/OSI 七+TCP-IP四 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/OSI%20%E4%B8%83+TCP-IP%E5%9B%9B/" data-id="ckhp0x7q2000c932u41g48w3a" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[TOC]</p>
<h1 id="OSI七层-【用表会输网恋里】"><a href="#OSI七层-【用表会输网恋里】" class="headerlink" title="OSI七层 【用表会输网恋里】"></a>OSI七层 【用表会输网恋里】</h1><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b4250ba3ef12">https://www.jianshu.com/p/b4250ba3ef12</a><br><img src="E1869ED1870F4A72AE67DCE902DFCE87" alt="image"><br> <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a><br> <img src="https://upload-images.jianshu.io/upload_images/1293297-8d257b0c94af01a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/511/format/webp" alt="image"></p>
<p><img src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234824085-667046040.png" alt="image"></p>
<p><img src="https://images2015.cnblogs.com/blog/1099668/201702/1099668-20170212153338135-125492424.jpg" alt="image"></p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><pre><code>  应用程序收到&quot;传输层&quot;的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。

   &quot;应用层&quot;的作用，就是规定应用程序的数据格式。
    OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。
   ，等等。</code></pre>
<h2 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h2><pre><code>    表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</code></pre>
<h2 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h2><pre><code>    会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。      </code></pre>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><pre><code>    传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”
    。
    有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</code></pre>
<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>
<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><pre><code>   本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。

   这就导致了&quot;网络层&quot;的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做&quot;网络地址&quot;，简称&quot;网址&quot;。</code></pre>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><pre><code>    将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。
 数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。

    MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。

    这个没找到合适的例子</code></pre>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><pre><code>    实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。
     快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</code></pre>
<h1 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h1><pre><code>TCP/IP五层协议和OSI的七层协议对应关系如下。</code></pre>
<p><img src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234825491-384470376.png" alt="image"></p>
<p><img src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234826351-1957282396.png" alt="image"></p>
<p><img src="https://images2015.cnblogs.com/blog/705728/201604/705728-20160424234827195-1493107425.png" alt="image"></p>
<h1 id="TCP-IP协议与Http协议的区别"><a href="#TCP-IP协议与Http协议的区别" class="headerlink" title="TCP/IP协议与Http协议的区别"></a>TCP/IP协议与Http协议的区别</h1><p>TCP/IP协议与Http协议的区别<br>　TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：“我们在传输数据时，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”</p>
<pre><code>应用层    例如HTTP、SMTP、SNMP、FTP、Telnet、SIP、SSH、NFS、RTSP、XMPP、Whois、ENRP
表示层    例如XDR、ASN.1、SMB、AFP、NCP
会话层    例如ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets
传输层    例如TCP、UDP、RTP、SCTP、SPX、ATP、IL
网络层    例如IP、ICMP、IGMP、IPX、BGP、OSPF、RIP、IGRP、EIGRP、ARP、RARP、 X.25
数据链路层    例如以太网、令牌环、HDLC、帧中继、ISDN、ATM、IEEE 802.11、FDDI、PPP
物理层    例如线路、无线电、光纤、信鸽</code></pre>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/OSI%20%E4%B8%83+TCP-IP%E5%9B%9B/">
    <time datetime="2020-11-19T16:00:28.810Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-004.网络/传输层【端口】TCP、UDP等/传输层概览" class="post-004.网络/传输层【端口】TCP、UDP等/传输层概览 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E3%80%90%E7%AB%AF%E5%8F%A3%E3%80%91TCP%E3%80%81UDP%E7%AD%89/%E4%BC%A0%E8%BE%93%E5%B1%82%E6%A6%82%E8%A7%88/" data-id="ckhp0x7qm001c932u609ehw2y" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>传输层指的是端到端的通信，</p>
<h2 id="常用端口号"><a href="#常用端口号" class="headerlink" title="常用端口号"></a>常用端口号</h2><p>21 端口：21 端口主要用于FTP（File Transfer Protocol，文件传输协议）服务。</p>
<p>23 端口：23 端口主要用于Telnet（远程登录）服务，是Internet上普遍采用的登录和仿真程序,最初设计被用来方便管理员远程管理计算机,可现在真正将其发挥到极致的是”黑客”!</p>
<p>80 端口：80 端口是为HTTP<br>3306 mysql<br>（HyperText Transport Protocol，超文本传输协议）开放的，这是上网冲浪使用最多的协议，主要用于在WWW（World Wide Web，万维网）服务上传输信息的协议。</p>
<p>3389端口：远程桌面 (嘿嘿!3389入侵就是用的这个口)</p>
<h1 id="问题：我们知道IP协议能够把源主机A发送出的分组按照首部中的目的IP送交到目的主机B，那么为什么还需要运输层呢？"><a href="#问题：我们知道IP协议能够把源主机A发送出的分组按照首部中的目的IP送交到目的主机B，那么为什么还需要运输层呢？" class="headerlink" title="问题：我们知道IP协议能够把源主机A发送出的分组按照首部中的目的IP送交到目的主机B，那么为什么还需要运输层呢？"></a>问题：我们知道IP协议能够把源主机A发送出的分组按照首部中的目的IP送交到目的主机B，那么为什么还需要运输层呢？</h1><p>答：从IP层来说，通信的两端是两个主机。但真正进行通信的实体是在主机中的进程，IP协议虽然能讲分组送到主机，但这个分组还停留在网络层而没有交付主机中的应用进程。从运输层的角度看，通信的真正端点并不是主机，而是主机的进程。也就是说端到端通信是应用进程之间的通信</p>
<p><img src="https://img-blog.csdn.net/20180621174026297?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzY0OTk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<p>==网络层是为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。运输层还要对收到的报文进行差错检测。==</p>
<h1 id="分用和复用"><a href="#分用和复用" class="headerlink" title="分用和复用"></a>分用和复用</h1><p>应用层的所有应用进程都可以通过运输层再传送到IP层，这就是复用。</p>
<p>运输层从IP层收到数据报后必须交付给指明的应用进程，这叫做分用。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E3%80%90%E7%AB%AF%E5%8F%A3%E3%80%91TCP%E3%80%81UDP%E7%AD%89/%E4%BC%A0%E8%BE%93%E5%B1%82%E6%A6%82%E8%A7%88/">
    <time datetime="2020-11-19T16:00:28.810Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-004.网络/传输层【端口】TCP、UDP等/TCP UDP" class="post-004.网络/传输层【端口】TCP、UDP等/TCP UDP post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E3%80%90%E7%AB%AF%E5%8F%A3%E3%80%91TCP%E3%80%81UDP%E7%AD%89/TCP%20UDP/" data-id="ckhp0x7qn001d932u6fugaxbn" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP主要特点："><a href="#TCP主要特点：" class="headerlink" title="TCP主要特点："></a>TCP主要特点：</h2><p>1）面向连接</p>
<p>2）每一条TCP连接只能是点对点的。</p>
<p>3）TCP提供可靠交付服务。</p>
<p>4）提供==全双工通信==。</p>
<p>5）面向字节流。</p>
<p> </p>
<h2 id="TCP的连接"><a href="#TCP的连接" class="headerlink" title="TCP的连接"></a>TCP的连接</h2><p>TCP连接的端口是套接字。套接字是IP地址加端口号。</p>
<p>格式：socket = （IP地址：端口号）</p>
<p>每一条TCP连接唯一地被通信两端的两个套接字所确定。即：</p>
<p>TCP连接 ：：= {socket1, socket2} = {(ip1: port1), (ip2: port2)}</p>
<h2 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h2><p>大白话解释：</p>
<p>三次握手【类似开黑】：</p>
<ol>
<li>   客户端向服务器说，我要拿数据了，</li>
<li>   服务器回应说，我收到你请求了，你准备拿数据吧。</li>
<li>   客户端说：我把我要的数据起始点发给你，你发吧。</li>
</ol>
<p>　在三次握手之后，A和B都能确定这么一件事==： 我说的话，你能听到； 你说的话，我也能听到 ==<br>   如果是两次，客户端能确定服务器能收到，但是服务器不能确定客户端是否能收到</p>
<p>四次挥手：</p>
<ol>
<li><pre><code>  客户端给服务器说：我不要数据了</code></pre>
</li>
<li><pre><code>  服务器为了确认：我准备好了</code></pre>
</li>
<li><pre><code>  &#39;&#39;过了一会&#39;&#39;</code></pre>
</li>
<li><pre><code>  服务器：我准备切停数据了，</code></pre>
</li>
<li><pre><code>  客户端：好吧，你切吧 </code></pre>
</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/1293297-15fd6d0a3851bbc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/258/format/webp" alt="image"></p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="https://img-blog.csdn.net/20180621174506805?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MzY0OTk1/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"><br>1.B的TCP服务器进程先创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程就处于LISTEN状态，等待客户的连接请求。</p>
<p>2.A的TCP客户进程也是首先创建传输控制块TCB，然后向B发送连接请求报文段，这时首部中的同步位SYN=1，同时选择一个初始序号seq = x。TCP规定，SYN报文段不能携带数据（即SYN=1的报文段），但要消耗掉一个序号。这时，TCP客户端进入SYN-SENT（同步已发送）状态。</p>
<p>3.B收到连接请求报文后，如同意连接，则向A发送确认。在确认报文段中应把SYN和ACK都置1，确认号是ack=x+1，然后也为自己选择一个初始序号seq=y。请注意这个报文也不能携带数据，但是要消耗一个序号。这时TCP服务器进程进入SYN-RCVD（同步收到）状态。</p>
<p>4.TCP客户进程收到B的确认后，还要向B发送确认。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1.TCP的标准规定，ACK报文可以携带数据，但如果不携带数据则不消耗序号，在这种情况下，下一个报文的序号仍是seq=x+1.这时，TCP连接已经建立，A进入ESTABLISHED（已建立连接）状态。</p>
<p>5.当B收到A的确认后，也进入ESTABLISHED状态。</p>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p><img src="https://img-blog.csdn.net/20160926193227287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<ol>
<li>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</li>
<li>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li>
<li>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li>
<li>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li>
</ol>
<p>通俗理解：</p>
<ul>
<li>1，当主机甲确认发送完数据且知道乙已经接受完了，想要关闭发送数据口（当然确认信号还是可以发），就会发FIN给主机B.</li>
<li></li>
<li>2，主机乙收到甲发送的FIN，表示收到了，就会发送ACK回复。</li>
<li></li>
<li>3，但这是乙可能还在发送数据，没有想要关闭数据口的意思，所以FIN与ACK不是同时发送的，而是等到乙数据发送完了，才会发送FIN给主机A.</li>
<li></li>
<li>4，A收到B发来的FIN，知道B的数据也发送完了，回复ACK，A等待2MSL以后，没有收到B传来的任何消息，知道B已经收到自己的ACK了，A就关闭链接，B也关闭链接了。</li>
</ul>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>5.3用户数据报协议UDP</p>
<p>UDP只在IP数据报服务之上增加了复用分用以及差错检测的功能。</p>
<p>主要特点：</p>
<p>1）无连接的</p>
<p>2）尽最大努力交付</p>
<p>3）UDP是面向报文的。发送发的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</p>
<p>4）UDP没有拥塞控制。因此网络出现拥塞不会使源主机的发送速率降低。这对如IP电话、实时视频会议的实时应用很重要。这些应用要求源主机以恒定的速率发送数据。并且允许在网络发生拥塞时丢失一些数据，但不允许数据有太大时延。</p>
<p>5）UDP支持一对一、一对多、多对一、多对多的交互通信。</p>
<p>6）UDP的首部只有8字节，开销小。</p>
<h1 id="UDP-TCP-比较"><a href="#UDP-TCP-比较" class="headerlink" title="UDP TCP 比较"></a>UDP TCP 比较</h1>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E3%80%90%E7%AB%AF%E5%8F%A3%E3%80%91TCP%E3%80%81UDP%E7%AD%89/TCP%20UDP/">
    <time datetime="2020-11-19T16:00:28.810Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-004.网络/传输层【端口】TCP、UDP等/可靠传输的原理【拥塞算法】" class="post-004.网络/传输层【端口】TCP、UDP等/可靠传输的原理【拥塞算法】 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E3%80%90%E7%AB%AF%E5%8F%A3%E3%80%91TCP%E3%80%81UDP%E7%AD%89/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%90%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95%E3%80%91/" data-id="ckhp0x7qn001e932u69toc8gf" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h1><p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1985679805,1205607400&fm=173&s=E582FD1EC4A0490306D5D9D6020080B3&w=615&h=150&img.JPEG" alt="image"></p>
<p>为了实现可靠传输，可以使用一些可靠传输协议==，当出现差错时让发送方重传出现差错的数据==，同时在接收方来不及处理收到的数据时==，及时告诉发送方适当降低发送数据的速度==。</p>
<h1 id="拥塞算法"><a href="#拥塞算法" class="headerlink" title="拥塞算法"></a>拥塞算法</h1><p><img src="CB52D6BAF9464163B7FB6FC29FB708D8" alt="image"></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E4%BC%A0%E8%BE%93%E5%B1%82%E3%80%90%E7%AB%AF%E5%8F%A3%E3%80%91TCP%E3%80%81UDP%E7%AD%89/%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%90%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95%E3%80%91/">
    <time datetime="2020-11-19T16:00:28.809Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-004.网络/应用层 http https协议等/加密" class="post-004.网络/应用层 http https协议等/加密 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%20http%20https%E5%8D%8F%E8%AE%AE%E7%AD%89/%E5%8A%A0%E5%AF%86/" data-id="ckhp0x7qq001j932u3zlhaflv" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[toc]</p>
<h1 id="http-到https的演化过程"><a href="#http-到https的演化过程" class="headerlink" title="http 到https的演化过程"></a>http 到https的演化过程</h1><ol>
<li>A到B如何通信 [用一个密钥加密解密] 对称加密</li>
<li>A到BCDE如何通信,BCDE单独的密钥,对密钥进行非对称加密[4000000000000000000000000000001 = 1199481995446957 * 3334772856269093 前面是公钥后面是私钥], 私钥加密后的密文，只要是公钥，都可以解密，但是公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。</li>
<li>协商加密算法的时候,使用随机数来生成对称加密算法。这样就可以做到服务器和客户端每次交互都是新的加密算法、只有在交互的那一该才确定加密算法。</li>
<li>公钥如何安全发送,防止被调包 不能直接将服务器的公钥传递给客户端，而是第三方机构使用它的私钥对我们的公钥进行加密后，再传给客户端。客户端再使用第三方机构的公钥进行解密。</li>
<li>数字签名，解决同一机构颁发的不同证书被篡改问题<br><img src="https://images0.cnblogs.com/i/116165/201407/122142366922455.png" alt="image"></li>
</ol>
<p>　a. Alice生成一个密钥对：pk与sk，然后向Bob发布她的公钥pk<br>　　b. Bob接到pk后生成一个随机密钥k，然后用pk对k进行加密，得到密文E<br>　　c. Bob将E发送给Alice<br>　　d. Alice用私钥sk对E解密，即可得到k<br>　　e. Alice与Bob可以用k进行安全通信了
　　</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%20http%20https%E5%8D%8F%E8%AE%AE%E7%AD%89/%E5%8A%A0%E5%AF%86/">
    <time datetime="2020-11-19T16:00:28.809Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-004.网络/应用层 http https协议等/http基本概念和特点" class="post-004.网络/应用层 http https协议等/http基本概念和特点 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%20http%20https%E5%8D%8F%E8%AE%AE%E7%AD%89/http%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E7%82%B9/" data-id="ckhp0x7qp001h932u2v5e2kmb" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p>Http是一种Transfer（传输）协议。在一次传输中，重要的过程包括：传输的建立、请求的发起、响应的回传。所以深入学习这三个过程就是关键所在。</p>
<p>协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。</p>
<p><img src="https://images0.cnblogs.com/i/116165/201407/111703047392802.png" alt="image"></p>
<p>HTTP默认的端口号为80，HTTPS的端口号为443。</p>
<p>浏览网页是HTTP的主要应用，但是这并不代表HTTP就只能应用于网页的浏览。HTTP是一种协议，只要通信的双方都遵守这个协议，HTTP就能有用武之地。比如咱们常用的QQ，迅雷这些软件，都会使用HTTP协议(还包括其他的协议)。</p>
<h1 id="二、工作流程"><a href="#二、工作流程" class="headerlink" title="二、工作流程"></a>二、工作流程</h1><p>一次HTTP操作称为一个事务，其工作过程可分为四步：</p>
<ol>
<li>1）首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始。</li>
<li>2）建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</li>
<li>3）服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</li>
<li>4）客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。<br>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。</li>
</ol>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%20http%20https%E5%8D%8F%E8%AE%AE%E7%AD%89/http%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%89%B9%E7%82%B9/">
    <time datetime="2020-11-19T16:00:28.808Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-004.网络/应用层 http https协议等/状态码" class="post-004.网络/应用层 http https协议等/状态码 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%20http%20https%E5%8D%8F%E8%AE%AE%E7%AD%89/%E7%8A%B6%E6%80%81%E7%A0%81/" data-id="ckhp0x7qr001k932uhogq1q4d" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>1、状态行格式如下：</p>
<p>HTTP-Version Status-Code Reason-Phrase CRLF</p>
<p>其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。</p>
<p>状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：</p>
<p>1xx：指示信息–表示请求已接收，继续处理</p>
<p>2xx：成功–表示请求已被成功接收、理解、接受</p>
<p>3xx：重定向–要完成请求必须进行更进一步的操作</p>
<p>4xx：客户端错误–请求有语法错误或请求无法实现</p>
<p>5xx：服务器端错误–服务器未能实现合法的请求</p>
<p>常见状态代码、状态描述、说明：</p>
<p>200 OK      //客户端请求成功</p>
<p>400 Bad Request  //客户端请求有语法错误，不能被服务器所理解</p>
<p>401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </p>
<p>403 Forbidden  //服务器收到请求，但是拒绝提供服务</p>
<p>404 Not Found  //请求资源不存在，eg：输入了错误的URL</p>
<p>500 Internal Server Error //服务器发生不可预期的错误</p>
<p>503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</p>
<p>eg：HTTP/1.1 200 OK （CRLF）</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%20http%20https%E5%8D%8F%E8%AE%AE%E7%AD%89/%E7%8A%B6%E6%80%81%E7%A0%81/">
    <time datetime="2020-11-19T16:00:28.808Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/huanghao.github.io/page/10/">&amp;laquo; Prev</a><a class="page-number" href="/huanghao.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/huanghao.github.io/page/9/">9</a><a class="page-number" href="/huanghao.github.io/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/huanghao.github.io/page/12/">12</a><a class="page-number" href="/huanghao.github.io/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/huanghao.github.io/page/15/">15</a><a class="extend next" rel="next" href="/huanghao.github.io/page/12/">Next &amp;raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E6%89%80%E8%B0%93%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E4%BD%9C%E7%94%A8%E5%9F%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80%E7%B1%BB%E6%A6%82%E8%AE%BA/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%80%A7%E8%83%BD%E8%B0%83%E6%A0%91+%E9%83%A8%E7%BD%B2+%E6%B5%8B%E8%AF%95/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 huanghao
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/huanghao.github.io/fancybox/jquery.fancybox.css">

  
<script src="/huanghao.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/huanghao.github.io/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>