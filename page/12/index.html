<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="一剑光寒十九州" />
  

  
  
  
  
  
  
  <title>NK一哥黄大脸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一剑光寒十九州">
<meta property="og:type" content="website">
<meta property="og:title" content="NK一哥黄大脸">
<meta property="og:url" content="https://zedhao.github.io/huanghao.github.io/page/12/index.html">
<meta property="og:site_name" content="NK一哥黄大脸">
<meta property="og:description" content="一剑光寒十九州">
<meta property="og:locale">
<meta property="article:author" content="huanghao">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/huanghao.github.io/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/huanghao.github.io/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/huanghao.github.io/atom.xml" title="NK一哥黄大脸" type="application/atom+xml">
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/huanghao.github.io/" title="NK一哥黄大脸" rel="home">NK一哥黄大脸</a>
      </h1>
      
        <h2 <title>谦谦君子 温润如玉</title></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/archives">Archives</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/guestbook">guestbook</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-004.网络/应用层 http https协议等/session和cookie  token的" class="post-004.网络/应用层 http https协议等/session和cookie  token的 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%20http%20https%E5%8D%8F%E8%AE%AE%E7%AD%89/session%E5%92%8Ccookie%20%20token%E7%9A%84/" data-id="ckhp0x7qq001i932u8qy83l2p" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moyand/p/9047978.html">https://www.cnblogs.com/moyand/p/9047978.html</a></p>
<h2 id="cookie-是什么"><a href="#cookie-是什么" class="headerlink" title="cookie 是什么"></a>cookie 是什么</h2><p><img src="https://images2017.cnblogs.com/blog/1203274/201712/1203274-20171209110335937-33858862.png" alt="image"><br>==Cookie就是由服务器发给客户端的特殊信息，而这些信息以文本文件的方式存放在客户端，然后客户端每次向服务器发送请求的时候都会带上这些特殊的信息。==</p>
<p>当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；</p>
<h2 id="cookie的特性"><a href="#cookie的特性" class="headerlink" title="cookie的特性"></a>cookie的特性</h2><p>Cookie具有不可跨域名性<br>javascript修改伪造cookie，可以设置cookie的httponly属性为true<br><a target="_blank" rel="noopener" href="https://my.oschina.net/xianggao/blog/395675?fromerr=GC9KVenE">https://my.oschina.net/xianggao/blog/395675?fromerr=GC9KVenE</a></p>
<h1 id="session"><a href="#session" class="headerlink" title="session"></a>session</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/woshimrf/p/5317776.html">https://www.cnblogs.com/woshimrf/p/5317776.html</a></p>
<h2 id="常用的Session实现方式和机制。"><a href="#常用的Session实现方式和机制。" class="headerlink" title="常用的Session实现方式和机制。"></a>常用的Session实现方式和机制。</h2><p>四、理解session机制 </p>
<p>session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。 </p>
<p>当程序需要为某个客户端的请求创建一个session的时候，服务器首先检查这个客户端的请求里是否已包含了一个session标识 - 称为session id，如果已包含一个session id则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（如果检索不到，可能会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。 </p>
<p>第一种：就是依赖于Cookie的实现，就是上面我们所说的那种，在这里我就不赘述了。</p>
<p>第二种：URL重写。这种实现方式，是通过在请求的URL后面后缀JESSIONID=xxx这种方式将JESSIONID传递给客户端。</p>
<p>第三种：隐藏的表单域。就是在FORM表单中，设置一个隐藏域，将JESSIONID放置其中，一并发送给服务器端。</p>
<h2 id="session存在哪里"><a href="#session存在哪里" class="headerlink" title="session存在哪里"></a>session存在哪里</h2><p>sessionid是一个会话的key，浏览器第一次访问服务器会在服务器端生成一个session，有一个sessionid和它对应。tomcat生成的sessionid叫做jsessionid。</p>
<p>存储在服务器的内存中，也可以持久化到file，数据库，memcache，redis等。客户端只保存sessionid到cookie中，而不会保存session，session销毁只能通过invalidate或超时，关掉浏览器并不会关闭session。</p>
<h2 id="session共享"><a href="#session共享" class="headerlink" title="session共享"></a>session共享</h2><p>首先我们应该明白，为什么要实现共享，如果你的网站是存放在一个机器上，那么是不存在这个问题的，因为会话数据就在这台机器，但是如果你使用了负载均衡把请求分发到不同的机器呢？这个时候会话id在客户端是没有问题的，但是如果用户的两次请求到了两台不同的机器，而它的session数据可能存在其中一台机器，这个时候就会出现取不到session数据的情况，于是session的共享就成了一个问题。<br>　　1.支持通过配置文件修改session的存储介质为sql<br>　　2.php支持把会话数据存储到某台memcache服务器，你也可以<br>　　3.手工把session文件存放的目录改为nfs网络文件系统，从而实现文件的跨机器共享。 </p>
<h1 id="token"><a href="#token" class="headerlink" title="token"></a>token</h1><p>　1、很久很久以前，Web 基本上就是文档的浏览而已， 既然是浏览，作为服务器， 不需要记录谁在某一段时间里都浏览了什么文档，每次请求都是一个新的HTTP协议， 就是请求加响应，  尤其是我不用记住是谁刚刚发了HTTP请求，   </p>
<p>2、但是随着交互式Web应用的兴起，像在线购物网站，需要登录的网站等等，马上就面临一个问题，那就是要管理会话，必须记住哪些人登录系统，  哪些人往自己的购物车中放商品，  也就是说我必须把每个人区分开，这就是一个不小的挑战，因为HTTP请求是无状态的，所以想出的办法就是给大家发一个会话标识(session id), 说白了就是一个随机的字串，每个人收到的都不一样，  每次大家向我发起HTTP请求的时候，把这个字符串给一并捎过来， 这样我就能区分开谁是谁了 最初的session</p>
<p>3、这样大家很嗨皮了，可是服务器就不嗨皮了，每个人只需要保存自己的session id，而服务器要保存所有人的session id ！  如果访问服务器多了， 就得由成千上万，甚至几十万个。</p>
<p>4.后来不存session_id,用cpu计算换存储<br>比如说， 小F已经登录了系统， 我给他发一个令牌(token)， 里边包含了小F的 user id， 下一次小F 再次通过Http 请求访问我的时候， 把这个token 通过Http header 带过来不就可以了。<br>不过这和session id没有本质区别啊， 任何人都可以可以伪造，  所以我得想点儿办法， 让别人伪造不了。<br>那就对数据做一个签名吧， 比如说我用HMAC-SHA256 算法，加上一个只有我才知道的密钥，  对数据做一个签名， 把这个签名和数据一起作为token 就无法伪造token了。</p>
<h2 id="token的处理过程"><a href="#token的处理过程" class="headerlink" title="token的处理过程"></a>token的处理过程</h2><p>1.用户通过用户名和密码发送请求。</p>
<p>2.程序验证。</p>
<p>3.程序返回一个签名的token 给客户端。</p>
<p>4.客户端储存token,并且每次用于每次发送请求。</p>
<p>5.服务端验证token并返回数据。</p>
<p><img src="https://images2018.cnblogs.com/blog/1350514/201805/1350514-20180504123206667-444188772.png" alt="image"></p>
<p><img src="https://images2018.cnblogs.com/blog/1350514/201805/1350514-20180504123326596-1492094512.png" alt="image"></p>
<p><img src="https://images2018.cnblogs.com/blog/1350514/201805/1350514-20180504123850641-479661599.png" alt="image"></p>
<h1 id="cookie-session-token"><a href="#cookie-session-token" class="headerlink" title="cookie session token"></a>cookie session token</h1><p>举个简单例子就像人们去超市购物，去存包，第一个去的时候(客户第一次发送请求给服务器),超市会给你一个号码牌(此时服务器产生一个唯一的sessionID，并返回给客户端(通过cookie)),你可以在你自己的柜子里存东西(在服务器属于此客户的内存区域存数据),下次你再去的时候，拿着这个号码牌(请求request中携带cookie),超市就知道哪些东西是你的，然后给你取出来，如果你几天都没去取（session失效了，在服务器端配置）,你再去的时候东西就拿不到了<br>如果你把这个号码牌丢了(刚才的cookie失效了，比如你重启电脑，刚才存于内存中sessionID也就丢了)，再去拿东西，当然无法定位了，也就拿不到东西了<br>如果是新打开一个浏览器的情况，那就像是又一个人去超市存东西一样，你的东西跟他的东西是两码事，互不影响,他有他自己的sessionID,你有你自己的</p>
<p>cookie 是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。</p>
<p>cookie由服务器生成，发送给浏览器，浏览器把cookie以kv形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。</p>
<p>session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。</p>
<p>session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。</p>
<p>服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%20http%20https%E5%8D%8F%E8%AE%AE%E7%AD%89/session%E5%92%8Ccookie%20%20token%E7%9A%84/">
    <time datetime="2020-11-19T16:00:28.807Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-004.网络/应用层 http https协议等/HTTP 1.0 1.1 2.0" class="post-004.网络/应用层 http https协议等/HTTP 1.0 1.1 2.0 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%20http%20https%E5%8D%8F%E8%AE%AE%E7%AD%89/HTTP%201.0%201.1%202.0/" data-id="ckhp0x7qo001f932ugazq6gq2" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="http的历史"><a href="#http的历史" class="headerlink" title="http的历史"></a>http的历史</h1><p><img src="http://mmbiz.qpic.cn/mmbiz_png/cmOLumrNib1cfBOtIMQ6JfSibJdd6QkQribgQuEeJaevuN9LRgQ9WR85hRiaVISeia7SDz1aU9hAAgO33XFaJ3FhmhQ/0?wx_fmt=png" alt="image"></p>
<ol>
<li>HTTP1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接</li>
<li>节约带宽：<br>HTTP1.1支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果接受到100，才把body发送到服务器。当服务器返回401的时候，节约了带宽。</li>
<li>HOST域：<br>HTTP1.0没有HOST域</li>
<li>多路复用：<br>HTTP2.0使用多路复用的技术，做到同一个连接并发处理多个请求，并且并发请求的数量比HTTP1.1大了好几个数量级</li>
<li>数据压缩：<br>HTTP1.1不支持header数据的压缩，HTTP2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。</li>
<li>服务器推送：<br>在HTTP2.0中服务器可以对客户端的一个请求发送多个响应，并且可以缓存。</li>
</ol>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%20http%20https%E5%8D%8F%E8%AE%AE%E7%AD%89/HTTP%201.0%201.1%202.0/">
    <time datetime="2020-11-19T16:00:28.806Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-004.网络/应用层 http https协议等/https过程及原理" class="post-004.网络/应用层 http https协议等/https过程及原理 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%20http%20https%E5%8D%8F%E8%AE%AE%E7%AD%89/https%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86/" data-id="ckhp0x7qp001g932u96wwgeu8" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[TOC]</p>
<h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="加密算法分类"><a href="#加密算法分类" class="headerlink" title="加密算法分类"></a>加密算法分类</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>DES<br>3DES<br>AES</p>
<h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>因为 加密 和 解密 使用的是两个不同的密钥，所以这种算法称为 非对称加密算法。</p>
<p>例子：甲方生成 一对密钥 并将其中的一把作为 公钥 向其它人公开，得到该公钥的 乙方 使用该密钥对机密信息 进行加密 后再发送给甲方，甲方再使用自己保存的另一把 专用密钥 (私钥)，对 加密 后的信息 进行解密。<br><img src="https://user-gold-cdn.xitu.io/2018/7/13/16493f2bfa06e955?w=736&h=214&f=png&s=37513" alt="image"><br>RSA<br> 基于一个十分简单的数论事实：将两个大 素数 相乘十分容易，但想要对其乘积进行 因式分解 却极其困难，因此可以将 乘积 公开作为 加密密钥。<br>ECC</p>
<h3 id="散列（hash）算法"><a href="#散列（hash）算法" class="headerlink" title="散列（hash）算法"></a>散列（hash）算法</h3><p>SHA-1<br>SHA1 是和 MD5 一样流行的 消息摘要算法，然而 SHA1 比 MD5 的 安全性更强。对于长度小于 2 ^ 64 位的消息，SHA1 会产生一个 160 位的 消息摘要。基于 MD5、SHA1 的信息摘要特性以及 不可逆 (一般而言)，可以被应用在检查 文件完整性 以及 数字签名 等场景。</p>
<p>MD5<br>MD5 用的是 哈希函数，它的典型应用是对一段信息产生 信息摘要，以 防止被篡改。严格来说，MD5 不是一种 加密算法 而是 摘要算法。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 进制 表示为 32 个字符)。<br>==彩虹表 暴力破解==</p>
<h2 id="常见的签名加密算法"><a href="#常见的签名加密算法" class="headerlink" title="常见的签名加密算法"></a>常见的签名加密算法</h2><h3 id="MD5算法"><a href="#MD5算法" class="headerlink" title="MD5算法"></a>MD5算法</h3><h3 id="SHA1算法"><a href="#SHA1算法" class="headerlink" title="SHA1算法"></a>SHA1算法</h3><h3 id="HMAC算法"><a href="#HMAC算法" class="headerlink" title="HMAC算法"></a>HMAC算法</h3><h3 id="AES-DES-3DES算法"><a href="#AES-DES-3DES算法" class="headerlink" title="AES/DES/3DES算法"></a>AES/DES/3DES算法</h3><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><h3 id="ECC算法"><a href="#ECC算法" class="headerlink" title="ECC算法"></a>ECC算法</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tengxy_cloud/article/details/52808163">https://blog.csdn.net/tengxy_cloud/article/details/52808163</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangshitong/p/6478721.html">https://www.cnblogs.com/zhangshitong/p/6478721.html</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/andy-zhou/p/5360107.html">https://www.cnblogs.com/andy-zhou/p/5360107.html</a></p>
<h1 id="ssl证书"><a href="#ssl证书" class="headerlink" title="ssl证书"></a>ssl证书</h1><h2 id="ssl-用法过程"><a href="#ssl-用法过程" class="headerlink" title="ssl 用法过程"></a>ssl 用法过程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/tengxy_cloud/article/details/52808163">https://blog.csdn.net/tengxy_cloud/article/details/52808163</a><br><img src="https://mc.qcloudimg.com/static/img/d242c611c463a59c822038f2ded8b1bb/image.png" alt="image"><br>假设一个公司B company向证书机构xxx CA申请SSL证书，他会得到一张类似下面这张图的证书</p>
<p>B company得到这张证书后，会在与用户通信的过程中将证书发送给用户，用户首先会检测办法证书的机构，如果是大家都公认的证书机构，操作系统在出厂时会内置这个机构的机构信息和公钥，例如xxx CA，如果是一个不受信任的证书机构，应用程序（比如浏览器）会发出警告，如果是受信任的证书机构，应用程序会使用预置的xxx CA的公钥去解密最后的指纹内容和指纹算法，然后再把前面的证书内容用指纹算法计算后与指纹内容比对，由于指纹内容是由证书机构唯一的私钥加密的，因此只要比对成功说明证书是没有人被人修改过的。接下来用户就可以放心使用该公司的公钥了</p>
<h2 id="ssl-的产生过程"><a href="#ssl-的产生过程" class="headerlink" title="ssl 的产生过程"></a>ssl 的产生过程</h2><p>1.最简单的通信过程</p>
<p><img src="https://mc.qcloudimg.com/static/img/9afa58403a75f46ed35d74416ed43cd0/image.png" alt="image"><br>2.确认服务器身份 </p>
<p><img src="https://mc.qcloudimg.com/static/img/d49f649a1ba1e0fb72c539634cb43670/image.png" alt="image"><br>其中“（）”里的内容是服务器用私钥加密后的内容，一般服务器会将明文加密，浏览器在收到消息后首先会用公钥解密密文，由前面特性3可以知道，公钥和解密算法是可以解出明文的，如果解不出来说明对方不是目标服务器，确认服务器身份后，在向服务器发送数据的过程中，如果数据被黑客截获，我们的用户名和密码也会落入黑客之手，于是下一步我们需要对发送的数据进行加密。</p>
<h2 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a>验证流程</h2><p>1 客户端发起一个https的请求，把自身支持的一系列Cipher Suite（密钥算法套件，简称Cipher）发送给服务端</p>
<p>2  服务端，接收到客户端所有的Cipher后与自身支持的对比，如果不支持则连接断开，反之则会从中选出一种加密算法和HASH算法</p>
<p>   以证书的形式返回给客户端 证书中还包含了 公钥 颁证机构 网址 失效日期等等。</p>
<p>3 客户端收到服务端响应后会做以下几件事</p>
<pre><code>3.1 验证证书的合法性    </code></pre>
<p>　　  颁发证书的机构是否合法与是否过期，证书中包含的网站地址是否与正在访问的地址一致等</p>
<pre><code>    证书验证通过后，在浏览器的地址栏会加上一把小锁(每家浏览器验证通过后的提示不一样 不做讨论)</code></pre>
<p>   3.2 生成随机密码</p>
<pre><code>    如果证书验证通过，或者用户接受了不授信的证书，此时浏览器会生成一串随机数，然后用证书中的公钥加密。 　　　　　　

3.3 HASH握手信息

   用最开始约定好的HASH方式，把握手消息取HASH值，  然后用 随机数加密 “握手消息+握手消息HASH值(签名)”  并一起发送给服务端

   在这里之所以要取握手消息的HASH值，主要是把握手消息做一个签名，用于验证握手消息在传输过程中没有被篡改过。</code></pre>
<p>4  服务端拿到客户端传来的密文，用自己的私钥来解密握手消息取出随机数密码，再用随机数密码 解密 握手消息与HASH值，并与传过来的HASH值做对比确认是否一致。</p>
<pre><code>然后用随机密码加密一段握手消息(握手消息+握手消息的HASH值 )给客户端</code></pre>
<p>5  客户端用随机数解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密  </p>
<pre><code> 因为这串密钥只有客户端和服务端知道，所以即使中间请求被拦截也是没法解密数据的，以此保证了通信的安全</code></pre>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%20http%20https%E5%8D%8F%E8%AE%AE%E7%AD%89/https%E8%BF%87%E7%A8%8B%E5%8F%8A%E5%8E%9F%E7%90%86/">
    <time datetime="2020-11-19T16:00:28.806Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-004.网络/CDN" class="post-004.网络/CDN post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/CDN/" data-id="ckhp0x7q1000b932ufwa220xj" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/004.%E7%BD%91%E7%BB%9C/CDN/">
    <time datetime="2020-11-19T16:00:28.805Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-006.服务治理/服务监控/google SRE/前言" class="post-006.服务治理/服务监控/google SRE/前言 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/006.%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/google%20SRE/%E5%89%8D%E8%A8%80/" data-id="ckhp0x7rf002y932u9r873l89" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[toc]</p>
<h1 id="sre-解释-Site-Reliability-Engineer"><a href="#sre-解释-Site-Reliability-Engineer" class="headerlink" title="sre 解释[Site Reliability Engineer]"></a>sre 解释[Site Reliability Engineer]</h1><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章:"></a>第一章:</h1><h2 id="系统管理员模式"><a href="#系统管理员模式" class="headerlink" title="系统管理员模式"></a>系统管理员模式</h2><p>dev[开发] ops[运维]分离的弊端</p>
<ol>
<li>直接成本[人工处理,规模成线性增加]</li>
<li>间接成本[]</li>
</ol>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/006.%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7/google%20SRE/%E5%89%8D%E8%A8%80/">
    <time datetime="2020-11-19T16:00:28.804Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-006.服务治理/服务容灾/容灾" class="post-006.服务治理/服务容灾/容灾 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/006.%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E7%81%BE/%E5%AE%B9%E7%81%BE/" data-id="ckhp0x7qw001v932u6f9m2j9c" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[toc]</p>
<h1 id="容灾七等级"><a href="#容灾七等级" class="headerlink" title="容灾七等级"></a>容灾七等级</h1><p>国际标准SHARE 78将容灾系统定义成七个层次：<br>0级：无异地备份<br>1级：实现异地备份【地缘因素】<br>2级：热备份站点备份<br>3级：在线数据恢复<br>4级：定时数据备份<br>5级：实时数据备份<br>6级：零数据丢失<br><img src="AEB44B72018E48DA89263C94A3FA4CA1" alt="image"><br><img src="1250ECA5624B4309B9D9AAE46BC5EEAB" alt="image"><br>备份是容灾的基础，备份恢复需要时间，有真空期，容灾改变挂载即可</p>
<h1 id="容灾的”3R”（Redundance、Remote、Replication）"><a href="#容灾的”3R”（Redundance、Remote、Replication）" class="headerlink" title="容灾的”3R”（Redundance、Remote、Replication）"></a>容灾的”3R”（Redundance、Remote、Replication）</h1><h1 id="国际标准SHARE-78将容灾系统定义成七个层次："><a href="#国际标准SHARE-78将容灾系统定义成七个层次：" class="headerlink" title="国际标准SHARE 78将容灾系统定义成七个层次："></a>国际标准SHARE 78将容灾系统定义成七个层次：</h1><h1 id="RTO和RPO"><a href="#RTO和RPO" class="headerlink" title="RTO和RPO"></a>RTO和RPO</h1><ul>
<li> RecoveryTimeObjective，恢复时间目标</li>
<li>RecoveryPointObjective，恢复点目标</li>
</ul>
<h1 id="分清应用灾备和数据灾备"><a href="#分清应用灾备和数据灾备" class="headerlink" title="分清应用灾备和数据灾备"></a>分清应用灾备和数据灾备</h1><h1 id="两地三机房-异地双活-同城双活"><a href="#两地三机房-异地双活-同城双活" class="headerlink" title="两地三机房 异地双活 同城双活"></a>两地三机房 异地双活 同城双活</h1><p><img src="4A3C35A99AE4430C83E65A8D77CF6F3B" alt="image"></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/006.%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86/%E6%9C%8D%E5%8A%A1%E5%AE%B9%E7%81%BE/%E5%AE%B9%E7%81%BE/">
    <time datetime="2020-11-19T16:00:28.803Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/计算机组成【硬件】原理/计算机基本原理" class="post-003.操作系统+计算机原理（linux）/计算机组成【硬件】原理/计算机基本原理 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E3%80%90%E7%A1%AC%E4%BB%B6%E3%80%91%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" data-id="ckhp0x7qm001b932ualz11gnm" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="计算机发展历史"><a href="#计算机发展历史" class="headerlink" title="计算机发展历史"></a>计算机发展历史</h1><p> 步进计算器【机械齿轮加减乘除】</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E3%80%90%E7%A1%AC%E4%BB%B6%E3%80%91%E5%8E%9F%E7%90%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/">
    <time datetime="2020-11-19T16:00:28.802Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/计算机组成【硬件】原理/概论" class="post-003.操作系统+计算机原理（linux）/计算机组成【硬件】原理/概论 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E3%80%90%E7%A1%AC%E4%BB%B6%E3%80%91%E5%8E%9F%E7%90%86/%E6%A6%82%E8%AE%BA/" data-id="ckhp0x7ql001a932uhvw378uu" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="冯诺依曼-基本结构CISCO"><a href="#冯诺依曼-基本结构CISCO" class="headerlink" title="冯诺依曼 基本结构CISCO"></a>冯诺依曼 基本结构CISCO</h1><p>calculate【运算器】 IO【输入输出】  Save【存储器】 Control【控制器】<br><img src="29E9A90149AD4156ABBAC3FAF81FF773" alt="image"><br>运算器和控制器合称为CPU<br><img src="73DC3E0034C246B9A2039E2B4C233CE1" alt="image"><br><img src="BE2A362D9AF8410B86B16554411E73BD" alt="image"><br><img src="12508738ABF4434F9411471E3C7230CE" alt="image"><br>s</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E3%80%90%E7%A1%AC%E4%BB%B6%E3%80%91%E5%8E%9F%E7%90%86/%E6%A6%82%E8%AE%BA/">
    <time datetime="2020-11-19T16:00:28.801Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/30天自制操作系统/汇编+IPL" class="post-003.操作系统+计算机原理（linux）/30天自制操作系统/汇编+IPL post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B1%87%E7%BC%96+IPL/" data-id="ckhp0x7qg000z932u9lbneczj" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="汇编相关命令语法"><a href="#汇编相关命令语法" class="headerlink" title="汇编相关命令语法"></a>汇编相关命令语法</h1><p><img src="F85E13CF746D4A9B9BB1F8FB5559AB5A" alt="image"></p>
<p><img src="224A9FDD845D44818C4D98BB0D4338D1" alt="image"><br><img src="5DCCB4D687554CAEB1097544124EE90D" alt="image"></p>
<p><img src="45FE0E828C5D48C395DA0754877747FD" alt="image"></p>
<p><img src="176648628A8F42FA91AD4881447C47DE" alt="image"><br><img src="6D3989CFF7DC4F0996A6CDC67D317DF2" alt="image"></p>
<p><img src="468D6DD4A7D942EA8EAFDFCF855F1293" alt="image"></p>
<p><img src="1790380A28A34312AF2565CB19B38B7A" alt="image"></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B1%87%E7%BC%96+IPL/">
    <time datetime="2020-11-19T16:00:28.800Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/linux命令/linux系统结构" class="post-003.操作系统+计算机原理（linux）/linux命令/linux系统结构 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/linux%E5%91%BD%E4%BB%A4/linux%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/" data-id="ckhp0x7qh0011932u90y1a8gc" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="Linux系统一般有4个主要部分："><a href="#Linux系统一般有4个主要部分：" class="headerlink" title="Linux系统一般有4个主要部分："></a>Linux系统一般有4个主要部分：</h1><p>[TOC]<br>内核、shell、文件系统和应用程序。<br>==内核、shell和文件系统一起形成了基本的操作系统结构==，它<br>们使得用户可以运行程序、管理文件并使用系统。部分层次结构如图1-1所示。<br><img src="https://img-blog.csdn.net/20180524222515956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2thaV96b25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<h2 id="linux内核"><a href="#linux内核" class="headerlink" title="linux内核"></a>linux内核</h2><p>内核是操作系统的核心，具有很多最基本功能，它负责管理系统的==进程、内存、设备驱动程序、文件和网络系统==，决定着系统的性能和稳定性。</p>
<p>Linux 内核由如下几部分组成：内存管理、进程管理、设备驱动程序、文件系统和网络管理等。如图<br><img src="https://img-blog.csdn.net/20180524222558542?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2thaV96b25l/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>对任何一台计算机而言，其内存以及其它资源都是有限的。为了让有限的物理内存满足应用程序对内存的大需求量，Linux  采用了称为“虚拟内存”的内存管理方式。Linux  将内存划分为容易处理的“内存页”（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。</p>
<p>　   不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。<br>　　 为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。
　　</p>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><p> ==进程实际是某特定应用程序的一个运行实体== </p>
<p> 在 Linux  系统中，能够同时运行多个进程，Linux  通过在短的时间间隔内轮流运行这些进程而实现“多任务”。这一短的时间间隔称为“时间片”，让进程轮流运行的方法称为“进程调度” ，完成调度的程序称为调度程序。</p>
<p>进程调度控制进程对CPU的访问。当需要选择下一个进程运行时，由调度程序选择最值得运行的进程。可运行进程实际上是仅等待CPU资源的进程，如果某个进程在等待其它资源，则该进程是不可运行进程。Linux使用了比较简单的基于优先级的进程调度算法选择新的进程。 </p>
<p>通过多任务机制，每个进程可认为只有自己独占计算机，从而简化程序的编写。每个进程有自己单独的地址空间，并且只能由这一进程访问，这样，操作系统避免了进程之间的互相干扰以及“坏”程序对系统可能造成的危害。</p>
<p>为了完成某特定任务，有时需要综合两个程序的功能，例如一个程序输出文本，而另一个程序对文本进行排序。为此，操作系统还提供进程间的通讯机制来帮助完成这样的任务。Linux 中常见的进程间通讯机制有==信号、管道、共享内存、信号量和套接字==等。 </p>
<p>内核通过 SCI 提供了一个应用程序编程接口（API）来创建一个新进程（fork、exec 或 Portable Operating System Interface [POSⅨ] 函数），停止进程（kill、exit），并在它们之间进行通信和同步（signal 或者 POSⅨ 机制）。
　　 </p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p> DOS 等操作系统不同，Linux 操作系统中单独的文件系统并不是由驱动器号或驱动器名称（如 A:  或 C:  等）来标识的。相反，和 UNIX  操作系统一样，Linux 操作系统将独立的文件系统组合成了一个层次化的树形结构，并且由一个单独的实体代表这一文件系统。Linux  将新的文件系统通过一个称为“挂装”或“挂上”的操作将其挂装到某个目录上，从而让不同的文件系统结合成为一个整体。Linux  操作系统的一个重要特点是它支持许多不同类型的文件。由于 Linux  支持许多不同的文件系统，并且将它们组织成了一个统一的虚拟文件系统.</p>
<p> 虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 SCI 和内核所支持的文件系统之间提供了一个交换层。即VFS 在用户和文件系统之间提供了一个交换层。</p>
<p> <img src="https://img-blog.csdn.net/20170323214831848" alt="image"></p>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><h3 id="网络接口"><a href="#网络接口" class="headerlink" title="网络接口"></a>网络接口</h3><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>  shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。</p>
<h2 id="文件系统-1"><a href="#文件系统-1" class="headerlink" title="文件系统"></a>文件系统</h2><h2 id="应用程序。"><a href="#应用程序。" class="headerlink" title="应用程序。"></a>应用程序。</h2>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/linux%E5%91%BD%E4%BB%A4/linux%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/">
    <time datetime="2020-11-19T16:00:28.799Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/huanghao.github.io/page/11/">&amp;laquo; Prev</a><a class="page-number" href="/huanghao.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/huanghao.github.io/page/10/">10</a><a class="page-number" href="/huanghao.github.io/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/huanghao.github.io/page/13/">13</a><a class="page-number" href="/huanghao.github.io/page/14/">14</a><a class="page-number" href="/huanghao.github.io/page/15/">15</a><a class="extend next" rel="next" href="/huanghao.github.io/page/13/">Next &amp;raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E6%89%80%E8%B0%93%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E4%BD%9C%E7%94%A8%E5%9F%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80%E7%B1%BB%E6%A6%82%E8%AE%BA/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%80%A7%E8%83%BD%E8%B0%83%E6%A0%91+%E9%83%A8%E7%BD%B2+%E6%B5%8B%E8%AF%95/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 huanghao
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/huanghao.github.io/fancybox/jquery.fancybox.css">

  
<script src="/huanghao.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/huanghao.github.io/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>