<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="一剑光寒十九州" />
  

  
  
  
  
  
  
  <title>NK一哥黄大脸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一剑光寒十九州">
<meta property="og:type" content="website">
<meta property="og:title" content="NK一哥黄大脸">
<meta property="og:url" content="https://zedhao.github.io/huanghao.github.io/page/13/index.html">
<meta property="og:site_name" content="NK一哥黄大脸">
<meta property="og:description" content="一剑光寒十九州">
<meta property="og:locale">
<meta property="article:author" content="huanghao">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/huanghao.github.io/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/huanghao.github.io/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/huanghao.github.io/atom.xml" title="NK一哥黄大脸" type="application/atom+xml">
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/huanghao.github.io/" title="NK一哥黄大脸" rel="home">NK一哥黄大脸</a>
      </h1>
      
        <h2 <title>谦谦君子 温润如玉</title></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/archives">Archives</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/guestbook">guestbook</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-003.操作系统+计算机原理（linux）/linux命令/命令大全" class="post-003.操作系统+计算机原理（linux）/linux命令/命令大全 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/linux%E5%91%BD%E4%BB%A4/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/" data-id="ckhp0x7qi0013932u09ox948o" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>toc</p>
<h1 id="curl，telnet，ping，nslookup"><a href="#curl，telnet，ping，nslookup" class="headerlink" title="curl，telnet，ping，nslookup"></a>curl，telnet，ping，nslookup</h1><h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p>curl是一个利用URL规则在命令行下工作的文件传输工具</p>
<h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><p>telnet <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 80 检验端口连接</p>
<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><h2 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h2>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/linux%E5%91%BD%E4%BB%A4/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/">
    <time datetime="2020-11-19T16:00:28.798Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/linux命令/全权限 chown chmod su  sudo  chattr " class="post-003.操作系统+计算机原理（linux）/linux命令/全权限 chown chmod su  sudo  chattr  post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/linux%E5%91%BD%E4%BB%A4/%E5%85%A8%E6%9D%83%E9%99%90%20chown%20chmod%20su%20%20sudo%20%20chattr%20/" data-id="ckhp0x7qh0012932ubhy33r0j" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="su、su-与sudo命令简单使用"><a href="#su、su-与sudo命令简单使用" class="headerlink" title="su、su - 与sudo命令简单使用"></a>su、su - 与sudo命令简单使用</h1><h2 id="1-su"><a href="#1-su" class="headerlink" title=".1 su"></a>.1 su</h2><p>在不加任何参数，默认为切换到root用户，但没有转到root用户家目录下，也就是说这时虽然是切换为root用户了，但并没有改变root登录环境；用户默认的登录环境，可以在/etc/passwd 中查得到，包括家目录，SHELL定义参数</p>
<h2 id="1-2-su"><a href="#1-2-su" class="headerlink" title="1.2 su -"></a>1.2 su -</h2><p>表示默认切换到root用户，并且改变到root用户的环境；</p>
<h2 id="1-3-sudo"><a href="#1-3-sudo" class="headerlink" title="1.3 sudo"></a>1.3 sudo</h2><p>不安全su工具在多人参与的系统管理中，并不是最好的选择，su只适用于一两个人参与管理的系统，毕竟su并不能让普通用户受限的使用；超级用户root密码应该掌握在少数用户手中。如果某个用户需要使用root权限、则必须要把root密码告诉此用户。针对此出现了sudo作为折中。</p>
<p>注意： su、su -都是使用root用户密码的，sudo是输入自己用户的密码的</p>
<h1 id="2-chown、chmod命令"><a href="#2-chown、chmod命令" class="headerlink" title="2. chown、chmod命令"></a>2. chown、chmod命令</h1><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>用来更改某个目录或文件的用户名和用户组的</p>
<p>举个例子，一开是我们的某些文件用户名是root，而不是自己所以不具备写入文件的权限。<br><img src="6E10C8CB436E4360A5451797BCEF99FB" alt="image"></p>
<h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><h1 id="chattr-https-www-linuxprobe-com-linux-chattr-root-html"><a href="#chattr-https-www-linuxprobe-com-linux-chattr-root-html" class="headerlink" title="chattr  https://www.linuxprobe.com/linux-chattr-root.html"></a>chattr  <a target="_blank" rel="noopener" href="https://www.linuxprobe.com/linux-chattr-root.html">https://www.linuxprobe.com/linux-chattr-root.html</a></h1><p>有时候你发现用root权限都不能修改某个文件，大部分原因是曾经用chattr命令锁定该文件了。chattr命令的作用很大，其中一些功能是由Linux内核版本来支持的，不过现在生产绝大部分跑的linux系统都是2.6以上内核了。通过chattr命令修改属性能够提高系统的安全性，但是它并不适合所有的目录。chattr命令不能保护/、/dev、/tmp、/var目录。lsattr命令是显示chattr命令设置的文件属性。</p>
<p>这两个命令是用来查看和改变文件、目录属性的，与chmod这个命令相比，chmod只是改变文件的读写、执行权限，更底层的属性控制是由chattr来改变的。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/linux%E5%91%BD%E4%BB%A4/%E5%85%A8%E6%9D%83%E9%99%90%20chown%20chmod%20su%20%20sudo%20%20chattr%20/">
    <time datetime="2020-11-19T16:00:28.795Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/linux命令/linux内核OS/多路IO复用 异步非阻塞 epoll" class="post-003.操作系统+计算机原理（linux）/linux命令/linux内核OS/多路IO复用 异步非阻塞 epoll post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/linux%E5%91%BD%E4%BB%A4/linux%E5%86%85%E6%A0%B8OS/%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8%20%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%20epoll/" data-id="ckhp0x7rc002t932u1l2c9q2h" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>异步非阻塞<br>epoll<br>多路IO复用模型<br>多进程（单线程）<br>&amp; 多路IO复用模型<br>多路IO复用模型</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/linux%E5%91%BD%E4%BB%A4/linux%E5%86%85%E6%A0%B8OS/%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8%20%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%20epoll/">
    <time datetime="2020-11-19T16:00:28.795Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/linux命令/linux内核OS/五种I-O模型【同-异步】【非-阻塞】" class="post-003.操作系统+计算机原理（linux）/linux命令/linux内核OS/五种I-O模型【同-异步】【非-阻塞】 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/linux%E5%91%BD%E4%BB%A4/linux%E5%86%85%E6%A0%B8OS/%E4%BA%94%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B%E3%80%90%E5%90%8C-%E5%BC%82%E6%AD%A5%E3%80%91%E3%80%90%E9%9D%9E-%E9%98%BB%E5%A1%9E%E3%80%91/" data-id="ckhp0x7ra002r932u62ltf6hk" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[TOC]</p>
<h1 id="同异步，非阻塞-概念的理解："><a href="#同异步，非阻塞-概念的理解：" class="headerlink" title="[同异步，非阻塞]概念的理解："></a>[同异步，非阻塞]概念的理解：</h1><p>首先在网络编程的时候，我们常常见到同步/异步，阻塞/非阻塞四中调用方式：</p>
<h2 id="同步和异步主要针对C（client）端"><a href="#同步和异步主要针对C（client）端" class="headerlink" title="同步和异步主要针对C（client）端"></a>同步和异步主要针对C（client）端</h2><p>==同步：== </p>
<p>所谓的同步，就是在c端发出一个功能调用时，在没有得到结果之前，该调用步返回，也就是说必须一件一件事做，等前一件事完了之后才做后一件事。<br>如：普通的B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回，这期间客户端浏览器不能干任何事</p>
<p>==异步：==</p>
<p>与同步相对。当C端一个异步过程调用发出之后，调用者不能立即得到结果，实际处理这个调用的部件在完成后，通过状态，通知和回调来通知调用者。<br>如：请求通过事件触发-&gt;服务器处理（浏览器仍然可以做其他事情）-&gt;处理完毕</p>
<h2 id="阻塞和非阻塞主要针对S端（server）"><a href="#阻塞和非阻塞主要针对S端（server）" class="headerlink" title="阻塞和非阻塞主要针对S端（server）"></a>阻塞和非阻塞主要针对S端（server）</h2><p>==阻塞==</p>
<p>==阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态，cpu不会分配时间片，线程暂停运行）函数只有得到结果返回==</p>
<p>阻塞调用和同步调用的区别：对同步来说，很多时候当前线程还是激活的，只是逻辑上没有返回，如，在socket编程中调用recv函数，如果缓冲区没有数据，这个函数就会一直等待，直到有数据返回。而此前当前线程还有可能继续处理各种各样的消息。</p>
<p>阻塞的例子：比如去取A楼一层（假设是内核缓冲区）取快递，但是比不知道什么时候来，你有不能干别的事情，只能死等着但是可以睡觉（进程处于休眠状态)，因为你知道快递把货送来时一定会给比大电话</p>
<p>非阻塞：<br>==非阻塞与阻塞概念想对应，指在不能立即得到结果之前，该函数不会阻塞当前线程，而会立即返回。==</p>
<p>非阻塞的例子：还是等快递，如果用轮询的方式，每隔5分钟去A楼一层（内核缓冲区）去看快递来了没，没来，立即返回，如果快递来了，就放到A楼一层，等你去取。</p>
<p>==对象是否处于阻塞模式和函数是不是阻塞调用有很强的相关性，但不是一一对应的。阻塞对象上可以有非阻塞的调用方式，我们可以通过轮询状态，在适当的时候调用阻塞函数，就可以避免阻塞，而对于非阻塞对象，调用函数可以进入阻塞调用==</p>
<p>对于select： </p>
<h2 id="同步异步阻塞非阻塞经典解释"><a href="#同步异步阻塞非阻塞经典解释" class="headerlink" title="同步异步阻塞非阻塞经典解释"></a>同步异步阻塞非阻塞经典解释</h2><p>1：同步<br>我客户端（C端调用者）一个功能，该功能没有结束前，我死等结果。</p>
<p>2：异步，我（c端调用者）调用一个功能，不知道该功能结果，该功能有结果后通知我，即回调通知<br>==同步和异步主要针对c端，但是跟s端不是完全没关系，同步和异步必须s端配合才能实现，同步和异步由c端控制，但是s端是否为阻塞还是非阻塞，c端不关心==</p>
<p>3：阻塞，就是调用我（s端被调用者，函数），我（s端被调用者，函数）没有完全接受完数据或者没有得到结果之前，我不会返回。</p>
<p>4：非阻塞，就是调用我（s端被调用者，函数），我（s端被调用者，函数）立即返回，通过select通知调用者</p>
<h2 id="同步I-O和异步I-O"><a href="#同步I-O和异步I-O" class="headerlink" title="同步I/O和异步I/O"></a>同步I/O和异步I/O</h2><p>==同步I/O与异步I/O的区别在与数据访问的时候进程是否阻塞==<br>==阻塞I/O与非阻塞I/O的区别在与：应该程序的调用是否立即返回==</p>
<p>阻塞和非阻塞是指server端的进程访问的数据如果尚未就绪，进程是否需要等待，简单说这相当于函数内部的实现区别，也就是未就绪时时直接返回还是等待就绪。</p>
<p>就同步和异步是指client端访问数据的机制，同步一般指主动请求并等待I/O操作完毕的方式，当数据就绪后再读写额时候必须阻塞，异步则指主动请求数据后便可以继续处理其他任务，随后等待I/O，操作完毕的通知。</p>
<h1 id="Linux——一切皆文件"><a href="#Linux——一切皆文件" class="headerlink" title="Linux——一切皆文件"></a>Linux——一切皆文件</h1><p>==Linux将所有外部设备都看做文件，对文件的读写操作会调用内核提供的系统命令，返回一个file descriptor(fd，文件描述符)。==</p>
<p>Linux也把socket当成文件，称为socketfd(socket描述符).</p>
<p>描述符是一个数字，该数字指向内核中的一个结构体（该结构体包含文件路径，数据区等属性）</p>
<h1 id="五种I-O模型【将数据从内核空间拷贝到用户空间】"><a href="#五种I-O模型【将数据从内核空间拷贝到用户空间】" class="headerlink" title="五种I/O模型【将数据从内核空间拷贝到用户空间】"></a>五种I/O模型【将数据从内核空间拷贝到用户空间】</h1><ul>
<li>1)阻塞I/O </li>
<li>2)非阻塞I/O </li>
<li>3)I/O复用(select和poll) </li>
<li>4)信号驱动I/O（SIGIO） </li>
<li>5)异步I/O </li>
</ul>
<p>==前四中是同步，最后一种是异步。==<br>#<br>1.操作系统是一个运行在硬件之上的软件系统，操作系统控制IO（磁盘，网络（socket）），cpu，内存的绝对控制权限，这些操作都是在内核空间完成的。</p>
<p>2.操作系统对外提供一些接口，其他接口可以调用这些接口控制外设，而用户的这些代码运行在用户空间里面，而这里里面的一些指令不能操作内核控制的一些设备或者内存区间。</p>
<h2 id="阻塞I-O模型【请求等待应答】"><a href="#阻塞I-O模型【请求等待应答】" class="headerlink" title="阻塞I/O模型【请求等待应答】"></a>阻塞I/O模型【请求等待应答】</h2><p>在进程空间中调用recvfrom，该系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回，次期间将会一直等待。</p>
<p>进程从调用recvfrom方法开始到recvfrom方法返回的期间都是被阻塞的。</p>
<p>当调用recv()函数时，系统首先检查是否有准备好的数据，如果数据没有准备好，那么系统就处于等待状态，当数据准备好后，将数据从系统缓冲区复制到用户空间，然后函数返回。在套接应用程序中，当调用recv()函数时，未必用户空间就已经存在数据，那么此时recv()函数处于等待状态 </p>
<p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2534342328,3421389422&fm=173&s=E6F1E07E0B426C4F5AD455CA0000E0B2&w=380&h=241&img.JPEG" alt="image"></p>
<h2 id="非阻塞I-O模型-轮询式-【间隔请求应答（true-or-false）】："><a href="#非阻塞I-O模型-轮询式-【间隔请求应答（true-or-false）】：" class="headerlink" title="非阻塞I/O模型(轮询式)【间隔请求应答（true or false）】："></a>非阻塞I/O模型(轮询式)【间隔请求应答（true or false）】：</h2><p>调用recvfrom方法后，如果内核该缓冲区没有数据，就直接返回一个EWOULDBLOCK错误。</p>
<p>我们把一个套接口设置为非阻塞就是告诉内存，当所请求的I/O操作无法完成时，不要惊进程睡眠，而是返回一个错误，河阳I/O函数会不断的测试数据是否准备好，没有准备好，继续测试，直到数据准备好为止。==在测试的过程中会占用大量的CPU时间。 ==</p>
<p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2285714997,3468784484&fm=173&s=3BAC702201584DCA5ED555CA0000E0B5&w=640&h=360&img.JPEG" alt="image"></p>
<h2 id="I-O复用模型"><a href="#I-O复用模型" class="headerlink" title="I/O复用模型"></a>I/O复用模型</h2><p>I/O复用模型会调用select，poll函数，这几个函数也会使进程阻塞，但是和阻塞I/O不同的，这个函数可以同时阻塞多个I/O操作，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。</p>
<h3 id="select-poll-【扫描式】"><a href="#select-poll-【扫描式】" class="headerlink" title="(select/poll)【扫描式】"></a>(select/poll)【扫描式】</h3><p> 进程通过将一定数量的fd传递给select/poll函数。</p>
<p>select函数会被阻塞，select/poll函数侦测多个fd是否处于就绪状态。</p>
<p>select/poll是顺序扫描fd是否就绪的，而且支持的fd数量是有限。</p>
<h3 id="I-O复用模型-epoll"><a href="#I-O复用模型-epoll" class="headerlink" title="I/O复用模型(epoll)"></a>I/O复用模型(epoll)</h3><p>Linux提供了一个epoll函数，epoll函数使用事件驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，立即调用回调函数。</p>
<p><img src="https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1111632650,1470429700&fm=173&s=2F2C70221F0A404918DCF1CA0000C0B5&w=640&h=360&img.JPEG" alt="image"></p>
<h2 id="信号驱动I-O模型【两次调用，两次返回-e内核主动通知】"><a href="#信号驱动I-O模型【两次调用，两次返回-e内核主动通知】" class="headerlink" title="信号驱动I/O模型【两次调用，两次返回 e内核主动通知】"></a>信号驱动I/O模型【两次调用，两次返回 e内核主动通知】</h2><p>简介：两次调用，两次返回<br>首先允许套接口进行信号驱动I/O，并安装一个信号处理函数，进程继续运行并不阻塞。昂数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。<br>先开启套接口的信号驱动I/O功能，sigaction函数安装一个信号处理函数（sigaction函数立即返回，进程继续工作，它是非阻塞的）。</p>
<p>当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据。</p>
<p>先开启套接口的信号驱动I/O功能，sigaction函数安装一个信号处理函数（sigaction函数立即返回，进程继续工作，它是非阻塞的）。</p>
<p>当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据。</p>
<p><img src="https://ss1.baidu.com/6ONXsjip0QIZ8tyhnq/it/u=1373078707,4254225799&fm=173&s=7B2C3062835E79CA58FD55CA0000C0B1&w=640&h=360&img.JPEG" alt="image"></p>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p>调用系统函数通知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。</p>
<p><img src="https://img-blog.csdn.net/20170905135446181?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZjIwMTY5MTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="image"></p>
<h1 id="Linux-I-O模型的总结"><a href="#Linux-I-O模型的总结" class="headerlink" title="Linux I/O模型的总结"></a>Linux I/O模型的总结</h1><p>IO主要涉及两步操作：</p>
<p>==等待内核数据准备完成数据从内核复制到用户空间<br>I/O模式的改进就是不断减少在这两步所花的时间。==</p>
<p>、</p>
<p>阻塞I/O: 两个阶段阻塞</p>
<p>非阻塞I/O:待内核数据准备完成期间轮询（等同阻塞，也可以多个I/O一起轮询） ,数据从内核复制到用户空间阻塞</p>
<p>I/O复用:等待内核数据准备完成期间可以多个I/O轮询，数据从内核复制到用户空间阻塞</p>
<p>信号驱动I/O：数据从内核复制到用户空间期间线程阻塞</p>
<p>异步I/O：完全不阻塞</p>
<p>Linux信号驱动I/O与异步I/O的区别</p>
<p>信号驱动I/O：内核通知程序何时可以开始一个I/O操作；</p>
<p>异步I/O： 内核通知程序I/O操作何时已完成,也就是说数据准备和数据复制到用户空间都是系统完成的。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/linux%E5%91%BD%E4%BB%A4/linux%E5%86%85%E6%A0%B8OS/%E4%BA%94%E7%A7%8DI-O%E6%A8%A1%E5%9E%8B%E3%80%90%E5%90%8C-%E5%BC%82%E6%AD%A5%E3%80%91%E3%80%90%E9%9D%9E-%E9%98%BB%E5%A1%9E%E3%80%91/">
    <time datetime="2020-11-19T16:00:28.794Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/linux命令/linux内核OS/内存" class="post-003.操作系统+计算机原理（linux）/linux命令/linux内核OS/内存 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/linux%E5%91%BD%E4%BB%A4/linux%E5%86%85%E6%A0%B8OS/%E5%86%85%E5%AD%98/" data-id="ckhp0x7rb002s932uaofc96yd" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>Linux 操作系统和驱动程序运行在内核空间，应用程序运行在用户空间，两者不能简单地使用指针传递数据，因为Linux使用的虚拟内存机制，用户空间的数据可能被换出，当内核空间使用用户空间指针时，对应的数据可能不在内存中。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/linux%E5%91%BD%E4%BB%A4/linux%E5%86%85%E6%A0%B8OS/%E5%86%85%E5%AD%98/">
    <time datetime="2020-11-19T16:00:28.794Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/本科操作系统入门/中断" class="post-003.操作系统+计算机原理（linux）/本科操作系统入门/中断 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%B8%AD%E6%96%AD/" data-id="ckhp0x7qj0016932u24pp8p6z" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><img src="90E6B19C58124B7B8E5825A68DFBA4BA" alt="image"></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%B8%AD%E6%96%AD/">
    <time datetime="2020-11-19T16:00:28.793Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/本科操作系统入门/六、死锁" class="post-003.操作系统+计算机原理（linux）/本科操作系统入门/六、死锁 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E5%85%AD%E3%80%81%E6%AD%BB%E9%94%81/" data-id="ckhp0x7qk0018932u9a7med4x" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h1><p>　　在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p>
<h1 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h1><p>互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；</p>
<p>占有并等待：一个进程必须占有至少一个资源，并等待另一个资源，而该资源为其他进程所占有；</p>
<p>非抢占：进程不能被抢占，即资源只能被进程在完成任务后自愿释放</p>
<p>循环等待：若干进程之间形成一种头尾相接的环形等待资源关系</p>
<h1 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h1><p>　　<br>　　死锁预防的基本思想是 只要==确保死锁发生的四个必要条件中至少有一个不成立==，就能预防死锁的发生，具体方法包括：</p>
<h1 id="鸵鸟策略"><a href="#鸵鸟策略" class="headerlink" title="鸵鸟策略"></a>鸵鸟策略</h1><p>　　</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E5%85%AD%E3%80%81%E6%AD%BB%E9%94%81/">
    <time datetime="2020-11-19T16:00:28.793Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/本科操作系统入门/一、操作系统基本介绍" class="post-003.操作系统+计算机原理（linux）/本科操作系统入门/一、操作系统基本介绍 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/" data-id="ckhp0x7qj0015932u9rtgdgcy" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <h1 id="基础概念和作用"><a href="#基础概念和作用" class="headerlink" title="基础概念和作用"></a>基础概念和作用</h1><h2 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h2><p>操作系统为用户与计算机硬件系统之间的接口；<br>操作系统是计算机资源的管理者/分配者，服务的提供者；<br>操作系统可以扩展机器</p>
<h2 id="操作系统的功能"><a href="#操作系统的功能" class="headerlink" title="操作系统的功能"></a>操作系统的功能</h2><h3 id="1-处理机管理功能"><a href="#1-处理机管理功能" class="headerlink" title="1 处理机管理功能"></a>1 处理机管理功能</h3><p>进程控制；进程同步；进程通信；调度</p>
<h3 id="2-储存器管理功能"><a href="#2-储存器管理功能" class="headerlink" title="2 储存器管理功能"></a>2 储存器管理功能</h3><p>内存分配；内存保护；地址映射；内存扩充虚拟储存</p>
<h3 id="3-设备管理功能"><a href="#3-设备管理功能" class="headerlink" title="3 设备管理功能"></a>3 设备管理功能</h3><p>缓冲管理；设备分配；设备处理</p>
<h3 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4 文件管理"></a>4 文件管理</h3><p>文件储存空间的管理；目录管理；文件的读写管理和保护</p>
<h3 id="5-用户接口"><a href="#5-用户接口" class="headerlink" title="5 用户接口"></a>5 用户接口</h3><p>命令接口：终端或控制台；程序接口：系统调用；图形接口</p>
<h2 id="操作系统基本特征"><a href="#操作系统基本特征" class="headerlink" title="操作系统基本特征"></a>操作系统基本特征</h2><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>并发性是指宏观上在一段时间内能同时运行多个程序，而并行性则指同一时刻能运行多个指令。</p>
<p>并行需要硬件支持，如多流水线或者多处理器。</p>
<p>操作系统通过引入进程和线程，使得程序能够并发运行。</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>共享是指系统中的资源可以供多个并发的进程共同使用。</p>
<p>有两种共享方式：互斥共享和同时共享。</p>
<p>==互斥共享的资源称为临界资源，例如打印机等==，在同一时间只允许一个进程访问，否则会出现错误，需要用同步机制来实现对临界资源的访问。</p>
<h3 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h3><p>虚拟技术把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术==：时分复用技术和空分复用技术==，例如多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换，这样就好像有多个处理器进行处理。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步是指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>如果一个进程在用户态需要用到操作系统的一些功能，就需要使用系统调用从而陷入内核，由操作系统代为完成。</p>
<p>可以由系统调用请求的功能有设备管理、文件管理、进程管理、进程通信、存储器管理等。</p>
<h2 id="中断分类"><a href="#中断分类" class="headerlink" title="中断分类"></a>中断分类</h2><h3 id="外中断"><a href="#外中断" class="headerlink" title="外中断"></a>外中断</h3><p>由 CPU 执行指令以外的事件引起，如 I/O 结束中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求。此外还有时钟中断、控制台中断等。</p>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>
<h3 id="陷入"><a href="#陷入" class="headerlink" title="陷入"></a>陷入</h3><p>在用户程序中使用系统调用。</p>
<p>大内核和微内核</p>
<h3 id="大内核"><a href="#大内核" class="headerlink" title="大内核"></a>大内核</h3><p>大内核是将操作系统功能作为一个紧密结合的整体放到内核，由于各模块共享信息，因此有很高的性能。</p>
<h3 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h3><p>由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。但是需要频繁地在用户态和核心态之间进行切换，会有一定的性能损失。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%B8%80%E3%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/">
    <time datetime="2020-11-19T16:00:28.792Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/本科操作系统入门/二、进程线程" class="post-003.操作系统+计算机原理（linux）/本科操作系统入门/二、进程线程 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/" data-id="ckhp0x7qk0017932ug5wyg8lw" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[toc]</p>
<h1 id="进程和线程和协程"><a href="#进程和线程和协程" class="headerlink" title="进程和线程和协程"></a>进程和线程和协程</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>共享内存 协程 不用等待请求返回</p>
<h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><p>进程和线程以及它们的区别</p>
<ol>
<li>==进程是对运行时程序的封装==，是==系统进行资源调度和分配的的基本单位==，实现了操作系统的并发；</li>
<li>==线程是进程的子任务，是CPU调度和分派的基本单位==，用于保证程序的 实时性，实现进程内部的并发；</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</li>
<li>==进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存==</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/25532384/answer/81152571">https://www.zhihu.com/question/25532384/answer/81152571</a></p>
<p>线程作为进程的一部分，==扮演的角色就是怎么利用中央处理器去运行代码==。这其中牵扯到的最重要资源的是中央处理器和其中的寄存器，和线程的栈（stack）。这里想强调的是，线程关注的是中央处理器的运行，而不是内存等资源的管理。</p>
<p>==进程更倾向于内存管理的概念==</p>
<p>他在自己的区域掌控自己的资源 也不越界</p>
<p>==线程更倾向于cpu的运行==</p>
<p>当前的计算机的cpu总要跑在一个线程上 但是又无法做到同时跑在多个线程上</p>
<p>看似多线程可以同时运行 其实他们之间是通过时间片的切换来做到的</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="进程定义："><a href="#进程定义：" class="headerlink" title="进程定义："></a>进程定义：</h3><ol>
<li>进程是程序的一次执行；</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动；</li>
<li>进程是程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位</li>
<li>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位</li>
</ol>
<h3 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h3><p>==就绪、执行、阻塞==</p>
<p>阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU，缺少 CPU 会让进程从==运行态转换为就绪态==。</p>
<p>只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。</p>
<h3 id="进程间的通信五种方式"><a href="#进程间的通信五种方式" class="headerlink" title="进程间的通信五种方式"></a>进程间的通信五种方式</h3><h4 id="1-共享内存"><a href="#1-共享内存" class="headerlink" title="1 共享内存"></a>1 共享内存</h4><p>==即多个进程共享某块内存，共享内存是通信方式中最快的一种。==</p>
<p>操作系统建立一块共享内存，并将其映射到参与通信的每个进程的地址空间上，进程就可以直接对这块共享内存进行读写。</p>
<h4 id="2-消息队列"><a href="#2-消息队列" class="headerlink" title="2 消息队列:"></a>2 消息队列:</h4><p>类似于用链表的结构存储消息。<br><img src="https://img-blog.csdn.net/20180513164327588?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2I5eF9f/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"><br>它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p>
<h4 id="3-管道pipe通信"><a href="#3-管道pipe通信" class="headerlink" title="3 管道pipe通信"></a>3 管道pipe通信</h4><p>==即管道为空时读进程会阻塞，管道为满时写进程会阻塞，以此实现进程之间的通信==。一个进程的输入作为另一个进程的输出<br>生产者消费者模式，内存不共享</p>
<h5 id="普通管道："><a href="#普通管道：" class="headerlink" title="普通管道："></a>普通管道：</h5><p>  它是半双工的，即只能单向传输。<br>  它是有进程关系限制的，只能在父子进程之间使用。</p>
<h5 id="流管道"><a href="#流管道" class="headerlink" title="流管道:"></a>流管道:</h5><p>   相对于普通管道而言，它不止是单向传输，可以双向传输。</p>
<h5 id="命名管道-FIFO-："><a href="#命名管道-FIFO-：" class="headerlink" title="命名管道(FIFO)："></a>命名管道(FIFO)：</h5><p> 相对于普通管道而言，它没有进程关系限制，可以在无关进程之间进行数据交换。</p>
<h4 id="4-套接字"><a href="#4-套接字" class="headerlink" title="4 套接字"></a>4 套接字</h4><pre><code>与其它通信机制不同是，套接字可用于不同机器间的进程通信，即可用于网络之间的进程通信。</code></pre>
<p><img src="https://img-blog.csdn.net/20180513165052722?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2I5eF9f/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p>
<h4 id="5-信号量"><a href="#5-信号量" class="headerlink" title="5 信号量"></a>5 信号量</h4><p>   信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。它是一个计数器，用来控制多个进程对共享资源的访问，常作为一种锁机制，实现进程间的同步和互斥。(JUC的Semaphore的设计思想来源吧)</p>
<h3 id="进程控制与同步"><a href="#进程控制与同步" class="headerlink" title="进程控制与同步"></a>进程控制与同步</h3><h4 id="1-信号量的应用"><a href="#1-信号量的应用" class="headerlink" title="1 信号量的应用"></a>1 信号量的应用</h4><p>实现进程互斥；<br>实现前驱关系</p>
<h4 id="2-经典进程的同步问题"><a href="#2-经典进程的同步问题" class="headerlink" title="2 经典进程的同步问题"></a>2 经典进程的同步问题</h4><p>生产者-消费者问题？<br>哲学家进餐问题？<br>读者-写者问题</p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程定义"><a href="#线程定义" class="headerlink" title="线程定义"></a>线程定义</h3><p>==线程是程序中一个单一的顺序控制流程，是系统独立调度和分派CPU的基本单位==。==同一个进程的多个线程共享相同的：代码段、数据段、操作系统的资源，可并发执行==</p>
<h3 id="线程有几种状态？"><a href="#线程有几种状态？" class="headerlink" title="线程有几种状态？"></a>线程有几种状态？</h3><p>　　在 Java虚拟机 中，线程从最初的创建到最终的消亡，要经历若干个状态：创建(new)、就绪(runnable/start)、运行(running)、阻塞(blocked)、等待(waiting)、时间等待(time waiting) 和 消亡(dead/terminated)。在给定的时间点上，一个线程只能处于一种状态<br><img src="http://static.zybuluo.com/Rico123/ot7o6218591iwj9py999hs1u/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.jpg" alt="image"></p>
<h3 id="线程间的同步和通信"><a href="#线程间的同步和通信" class="headerlink" title="线程间的同步和通信"></a>线程间的同步和通信</h3><h4 id="1-互斥锁（mutex）"><a href="#1-互斥锁（mutex）" class="headerlink" title="1.互斥锁（mutex）"></a>1.互斥锁（mutex）</h4><p>互斥锁比较简单，用于实现线程间对资源互斥访问的机制。有两种状态，开锁和关锁状态。</p>
<p>当一个线程需要读/写一个共享数据时，线程首先应该为该数据段所设置的mutex执行关锁命令。首先判别mutex的状态，如果已经处于关锁状态，则访问该数据段的线程将被阻塞；如果mutex处于开锁状态，则将mutex关上之后进行读/写。</p>
<p>完成读/写之后将mutex设置成开锁状态，并唤醒阻塞在该互斥锁上的线程。</p>
<h4 id="2-条件变量"><a href="#2-条件变量" class="headerlink" title="2.条件变量"></a>2.条件变量</h4><p>只利用mutex来实现互斥访问可能会引起互斥锁。</p>
<p>每个条件变量通常都与一个互斥锁一起使用，在创建一个互斥锁的同时便联系一个条件变量。单纯的互斥锁用于短期锁定，主要是保证对临界区的互斥进入，条件变量则用于线程的长期等待，直至等待的资源成为可用的资源。</p>
<h4 id="3-信号量机制：分为私有信号量与公有信号量"><a href="#3-信号量机制：分为私有信号量与公有信号量" class="headerlink" title="3.信号量机制：分为私有信号量与公有信号量"></a>3.信号量机制：分为私有信号量与公有信号量</h4>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/">
    <time datetime="2020-11-19T16:00:28.792Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="post-003.操作系统+计算机原理（linux）/本科操作系统入门/三、内存管理" class="post-003.操作系统+计算机原理（linux）/本科操作系统入门/三、内存管理 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="ckhp0x7qi0014932u8x2rca2e" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[toc]<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peterYong/p/6556619.html">https://www.cnblogs.com/peterYong/p/6556619.html</a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>内存是计算机中最重要的资源之一,==通常情况下，物理内存无法容纳下所有的进程==。虽然物理内存的增长现在达到了N个GB，但比物理内存增长还快的是程序，所以无论物理内存如何增长，都赶不上程序增长的速度，所以操作系统如何有效的管理内存便显得尤为重要。本文讲述操作系统对于内存的管理的过去和现在，以及一些页替换的算法的介绍。</p>
<h1 id="内存管理的功能有："><a href="#内存管理的功能有：" class="headerlink" title="内存管理的功能有："></a>内存管理的功能有：</h1><ol>
<li>内存空间的分配与回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。</li>
<li>地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。</li>
<li>内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。</li>
<li>存储保护：保证各道作业在各自的存储空间内运行，.互不干扰。<h1 id="程序装入和链接"><a href="#程序装入和链接" class="headerlink" title="程序装入和链接"></a>程序装入和链接</h1>创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</li>
</ol>
<ul>
<li>编译：由编译程序将用户源代码编译成若干个目标模块。</li>
<li>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。</li>
<li>装入：由装入程序将装入模块装入内存运行。<br><img src="http://img.blog.csdn.net/20150922233833618" alt="image"></li>
</ul>
<h1 id="内存抽象"><a href="#内存抽象" class="headerlink" title="内存抽象"></a>内存抽象</h1><p> 在现代的操作系统中，同一时间运行多个进程是再正常不过的了==。为了解决直接操作内存带来的各种问题，引入的地址空间(Address Space),这允许每个进程拥有自己的地址。==这还需要硬件上存在两个寄存器，基址寄存器(base register)和界址寄存器(limit register),第一个寄存器保存进程的开始地址，第二个寄存器保存上界，防止内存溢出。</p>
<p> 在这种情况下，==任何操作虚拟地址的操作都会被转换为操作物理地址。而每一个进程所拥有的内存地址是完全不同的，因此也使得多进程成为可能。==</p>
<p>通常来说==，内存大小不可能容纳下所有并发执行的进程。因此，交换(Swapping)技术应运而生。==这个交换和前面所讲的交换大同小异,只是现在讲的交换在多进程条件下。交换的基本思想是，将闲置的进程交换出内存，暂存在硬盘中，待执行时再交换回内存，比如下面</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/CareySon/201204/201204251637369621.png" alt="image"><br>经过图，我们还发现一个问题，进程D和C之间的空间由于太小无法另任何进程使用，这也就是所谓的==外部碎片==。、</p>
<p>紧凑技术(Memory Compaction)解决，通过移动进程在内存中的地址，使得这些外部碎片空间被填满。</p>
<p>内存整理软件，原理是申请一块超大的内存，将所有进程置换出内存，然后再释放这块内存，从而使得从新加载进程，使得外部碎片被消除。</p>
<p>上面的理论都是基于进程所占的内存空间是固定的这个假设，但实际情况下，进程往往会动态增长，因此创建进程时分配的内存就是个问题了，如果分配多了，会产生内部碎片，浪费了内存，而分配少了会造成内存溢出。<br><img src="https://images.cnblogs.com/cnblogs_com/CareySon/201204/201204251637421262.png" alt="image"></p>
<h2 id="两种方法-得知内存的使用情况"><a href="#两种方法-得知内存的使用情况" class="headerlink" title="两种方法 得知内存的使用情况"></a>两种方法 得知内存的使用情况</h2><ul>
<li>一个解决方法是在进程创建的时候，比进程实际需要的多分配一点内存空间用于进程的增。</li>
<li>一种是直接多分配一点内存空间用于进程在内存中的增长，</li>
<li>另一种是将增长区分为数据段和栈（用于存放返回地址和局部变量）,如图3所示。<br>当允许进程动态增长时，操作系统必须对内存进行更有效的管理，操作系统使用如下两种方法之一来得知内存的使用情况，分别为1)位图(bitmap) 2)链表</li>
</ul>
<p><img src="https://images.cnblogs.com/cnblogs_com/CareySon/201204/201204251637498957.png" alt="image"><br>使用链表中的P表示进程，从0-2是进程，H表示空闲，从3-4表示是空闲。</p>
<h2 id="对进程创建时的空间进行分配算法"><a href="#对进程创建时的空间进行分配算法" class="headerlink" title="对进程创建时的空间进行分配算法"></a>对进程创建时的空间进行分配算法</h2><ol>
<li><pre><code> 临近适应算法(Next fit)---从当前位置开始，搜索第一个能满足进程要求的内存空间</code></pre>
</li>
<li><pre><code> 最佳适应算法(Best fit)---搜索整个链表，找到能满足进程要求最小内存的内存空间</code></pre>
</li>
<li><pre><code> 最大适应算法(Wrost fit)---找到当前内存中最大的空闲空间</code></pre>
</li>
<li><pre><code> 首次适应算法(First fit) ---从链表的第一个开始，找到第一个能满足进程要求的内存空间</code></pre>
</li>
</ol>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>虚拟内存是现代操作系统普遍使用的一种技术。前面所讲的抽象满足了多进程的要求，但很多情况下，现有内存无法满足仅仅一个大进程的内存要求(比如很多游戏，都是10G+的级别)。在早期的操作系统曾使用覆盖(overlays)来解决这个问题，将一个程序分为多个块，基本思想是先将块0加入内存，块0执行完后，将块1加入内存。依次往复，这个解决方案最大的问题是需要程序员去程序进行分块，这是一个费时费力让人痛苦不堪的过程。后来这个解决方案的修正版就是虚拟内存。</p>
<h2 id="虚拟内存基本思想"><a href="#虚拟内存基本思想" class="headerlink" title="虚拟内存基本思想"></a>虚拟内存基本思想</h2><p>每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一 页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。</p>
<p>当程序引用到一部分在物理内存中的地址空间时，由硬件立即执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。<br><img src="https://images.cnblogs.com/cnblogs_com/CareySon/201204/20120425163755141.png" alt="image"></p>
<h2 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h2><h3 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h3><p>由上图可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2），而如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生==缺页中断==，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。</p>
<p>而虚拟内存和物理内存的匹配是通过页表实现，页表存在MMU中，页表中每个项通常为32位，既4byte,除了存储虚拟地址和页框地址之外，还会存储一些标志位，比如是否缺页，是否修改过，写保护等。可以把MMU想象成一个接收虚拟地址项返回物理地址的方法。</p>
<h3 id="为什么需要页面置换"><a href="#为什么需要页面置换" class="headerlink" title="为什么需要页面置换"></a>为什么需要页面置换</h3><p>  因为在计算机系统中，读取少量数据硬盘通常需要几毫秒，而内存中仅仅需要几纳秒。一条CPU指令也通常是几纳秒，如果在执行CPU指令时，产生几次缺页中断，那性能可想而知，因此尽量减少从硬盘的读取无疑是大大的提升了性能。而前面知道，物理内存是极其有限的，当虚拟内存所求的页不在物理内存中时，将需要将物理内存中的页替换出去，选择哪些页替换出去就显得尤为重要，如果算法不好将未来需要使用的页替换出去，则以后使用时还需要替换进来，这无疑是降低效率的，让我们来看几种页面替换算法</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="OPT（Optimal-replacement）最优置换算法："><a href="#OPT（Optimal-replacement）最优置换算法：" class="headerlink" title="OPT（Optimal replacement）最优置换算法："></a>OPT（Optimal replacement）最优置换算法：</h4><p>理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法<br>最佳置换算法是将未来最久不使用的页替换出去，这听起来很简单，但是无法实现。但是这种算法可以作为衡量其它算法的基准。</p>
<h4 id="LRU（Least-recently-use-）最近最少使用算法"><a href="#LRU（Least-recently-use-）最近最少使用算法" class="headerlink" title="LRU（Least recently use ）最近最少使用算法"></a>LRU（Least recently use ）最近最少使用算法</h4><p>种算法给每个页一个标志位，R表示最近被访问过，M表示被修改过。定期对R进行清零。这个算法的思路是首先淘汰那些未被访问过R=0的页，其次是被访问过R=1,未被修改过M=0的页，最后是R=1,M=1的页。</p>
<h4 id="FIFO先进先出算法："><a href="#FIFO先进先出算法：" class="headerlink" title="FIFO先进先出算法："></a>FIFO先进先出算法：</h4><p>这种算法的思想是淘汰在内存中最久的页，这种算法的性能接近于随机淘汰。并不好。<br>在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；</p>
<h4 id="改进型FIFO算法-Second-Chance-Page-Replacement-Algorithm"><a href="#改进型FIFO算法-Second-Chance-Page-Replacement-Algorithm" class="headerlink" title="改进型FIFO算法(Second Chance Page Replacement Algorithm)"></a>改进型FIFO算法(Second Chance Page Replacement Algorithm)</h4><p>这种算法是在FIFO的基础上，为了避免置换出经常使用的页，增加一个标志位R，如果最近使用过将R置1，当页将会淘汰时，如果R为1，则不淘汰页，将R置0.而那些R=0的页将被淘汰时，直接淘汰。这种算法避免了经常被使用的页被淘汰。</p>
<h4 id="LFU（Least-frequently-use）最少使用次数算法：根据使用次数来判断；"><a href="#LFU（Least-frequently-use）最少使用次数算法：根据使用次数来判断；" class="headerlink" title="LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；"></a>LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；</h4><p>最久未使用算法(LRU Page Replacement Algorithm)</p>
<h4 id="时钟替换算法-Clock-Page-Replacement-Algorithm"><a href="#时钟替换算法-Clock-Page-Replacement-Algorithm" class="headerlink" title="时钟替换算法(Clock Page Replacement Algorithm)"></a>时钟替换算法(Clock Page Replacement Algorithm)</h4><p>虽然改进型FIFO算法避免置换出常用的页，但由于需要经常移动页，效率并不高。因此在改进型FIFO算法的基础上，将队列首位相连形成一个环路，当缺页中断产生时，从当前位置开始找R=0的页，而所经过的R=1的页被置0，并不需要移动页。如图6所示。<br><img src="https://images.cnblogs.com/cnblogs_com/CareySon/201204/201204251637589948.png" alt="image"></p>
<p><img src="EDA141F869784AFA85400793187C4CB4" alt="image"></p>
<h2 id="分页和分段有什么区别（内存管理）？"><a href="#分页和分段有什么区别（内存管理）？" class="headerlink" title="分页和分段有什么区别（内存管理）？"></a>分页和分段有什么区别（内存管理）？</h2><p>　　段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p>
<p>　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。</p>
<h2 id="两者的不同点："><a href="#两者的不同点：" class="headerlink" title="两者的不同点："></a>两者的不同点：</h2><p>目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</p>
<p>大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；</p>
<p>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</p>
<p>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</p>
<p>内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
    <time datetime="2020-11-19T16:00:28.791Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>






  
  
    <nav id="pagination">
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/huanghao.github.io/page/12/">&amp;laquo; Prev</a><a class="page-number" href="/huanghao.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/huanghao.github.io/page/11/">11</a><a class="page-number" href="/huanghao.github.io/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/huanghao.github.io/page/14/">14</a><a class="page-number" href="/huanghao.github.io/page/15/">15</a><a class="extend next" rel="next" href="/huanghao.github.io/page/14/">Next &amp;raquo;</a>
      </nav>
    </nav>
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E6%89%80%E8%B0%93%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E4%BD%9C%E7%94%A8%E5%9F%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80%E7%B1%BB%E6%A6%82%E8%AE%BA/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%80%A7%E8%83%BD%E8%B0%83%E6%A0%91+%E9%83%A8%E7%BD%B2+%E6%B5%8B%E8%AF%95/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 huanghao
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/huanghao.github.io/fancybox/jquery.fancybox.css">

  
<script src="/huanghao.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/huanghao.github.io/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>