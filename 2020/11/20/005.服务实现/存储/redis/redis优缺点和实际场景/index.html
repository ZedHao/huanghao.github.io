<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="一剑光寒十九州" />
  

  
  
  
  
  
  
  <title>NK一哥黄大脸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[TOC]https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xiaoxi&#x2F;p&#x2F;6517544.html  String: 字符串  Hash: 散列  List: 列表  Set: 集合  Sorted Set: 有序集合 五大类型string 类型list 类型hash类型我们可以将Redis中的Hash类型看成具有String Key和String Value的map容器。所以该类型非常适合于存">
<meta property="og:type" content="article">
<meta property="og:title" content="NK一哥黄大脸">
<meta property="og:url" content="https://zedhao.github.io/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF/index.html">
<meta property="og:site_name" content="NK一哥黄大脸">
<meta property="og:description" content="[TOC]https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xiaoxi&#x2F;p&#x2F;6517544.html  String: 字符串  Hash: 散列  List: 列表  Set: 集合  Sorted Set: 有序集合 五大类型string 类型list 类型hash类型我们可以将Redis中的Hash类型看成具有String Key和String Value的map容器。所以该类型非常适合于存">
<meta property="og:locale">
<meta property="og:image" content="https://images2015.cnblogs.com/blog/249993/201706/249993-20170614100608978-1918854040.jpg">
<meta property="og:image" content="https://img-blog.csdn.net/20180623151715786?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nd2Vpd2VpMjAyMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="article:published_time" content="2020-11-19T16:00:28.834Z">
<meta property="article:modified_time" content="2020-11-19T16:00:28.834Z">
<meta property="article:author" content="huanghao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images2015.cnblogs.com/blog/249993/201706/249993-20170614100608978-1918854040.jpg">
  
  
    <link rel="icon" href="/huanghao.github.io/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/huanghao.github.io/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/huanghao.github.io/atom.xml" title="NK一哥黄大脸" type="application/atom+xml">
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/huanghao.github.io/" title="NK一哥黄大脸" rel="home">NK一哥黄大脸</a>
      </h1>
      
        <h2 <title>谦谦君子 温润如玉</title></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/archives">Archives</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/guestbook">guestbook</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-005.服务实现/存储/redis/redis优缺点和实际场景" class="post-005.服务实现/存储/redis/redis优缺点和实际场景 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF/" data-id="ckhp0x7rx0040932uc54j7w3r" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[TOC]<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/6517544.html">https://www.cnblogs.com/xiaoxi/p/6517544.html</a></p>
<ul>
<li><p>String: 字符串</p>
</li>
<li><p>Hash: 散列</p>
</li>
<li><p>List: 列表</p>
</li>
<li><p>Set: 集合</p>
</li>
<li><p>Sorted Set: 有序集合</p>
<h1 id="五大类型"><a href="#五大类型" class="headerlink" title="五大类型"></a>五大类型</h1><h2 id="string-类型"><a href="#string-类型" class="headerlink" title="string 类型"></a>string 类型</h2><h2 id="list-类型"><a href="#list-类型" class="headerlink" title="list 类型"></a>list 类型</h2><h2 id="hash类型"><a href="#hash类型" class="headerlink" title="hash类型"></a>hash类型</h2><p>我们可以将Redis中的Hash类型看成具有String Key和String Value的map容器。所以该类型非常适合于存储值对象的信息。如Username、Password和Age等。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的磁盘空间。每一个Hash可以存储4294967295个键值对。</p>
<h2 id="set数据类型"><a href="#set数据类型" class="headerlink" title="set数据类型"></a>set数据类型</h2><p>一、概述</p>
<p>在Redis中，我们可以将Set类型看作为没有排序的字符集合，和List类型一样，我们也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。需要说明的是，这些操作的时间复杂度为O(1)，即常量时间内完成次操作。Set可包含的最大元素数量是4294967295。<br>和List类型不同的是，++==Set集合中不允许出现重复的元素==++，这一点和C++标准库中的set容器是完全相同的。换句话说，如果多次添加相同元素，Set中将仅保留该元素的一份拷贝。和List类型相比，Set类型在功能上还存在着一个非常重要的特性，即在服务器端完成多个Sets之间的聚合计算操作，如unions、intersections和differences。由于这些操作均在服务端完成，因此效率极高，而且也节省了大量的网络IO开销</p>
</li>
</ul>
<h2 id="sort-set"><a href="#sort-set" class="headerlink" title="sort set"></a>sort set</h2><p>一、概述：</p>
<pre><code>Sorted Set（有序集合）和Set类型极为相似，它们都是字符串的集合，都不允许重复的成员出现在一个Set中。它们之间的主要差别是Sorted Set中的每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。然而需要额外指出的是，尽管Sorted Set中的成员必须是唯一的，但是分数(score)却是可以重复的。
在Sorted Set中添加、删除或更新一个成员都是非常快速的操作，其时间复杂度为集合中成员数量的对数。由于Sorted Set中的成员在集合中的位置是有序的，因此，即便是访问位于集合中部的成员也仍然是非常高效的。事实上，Redis所具有的这一特征在很多其它类型的数据库中是很难实现的，换句话说，在该点上要想达到和Redis同样的高效，在其它数据库中进行建模是非常困难的。</code></pre>
<h1 id="redis使用场景"><a href="#redis使用场景" class="headerlink" title="redis使用场景"></a>redis使用场景</h1><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaoxi/p/7007695.html">https://www.cnblogs.com/xiaoxi/p/7007695.html</a></p>
<h2 id="一、Redis常用数据类型"><a href="#一、Redis常用数据类型" class="headerlink" title="一、Redis常用数据类型"></a>一、Redis常用数据类型</h2><p>Redis最为常用的数据类型主要有以下五种：</p>
<p>String<br>Hash<br>List<br>Set<br>Sorted set<br>在具体描述这几种数据类型之前，我们先通过一张图了解下Redis内部内存管理中是如何描述这些不同数据类型的：<br><img src="https://images2015.cnblogs.com/blog/249993/201706/249993-20170614100608978-1918854040.jpg" alt="image"></p>
<p>首先Redis内部使用一个redisObject对象来表示所有的key和value，redisObject最主要的信息如上图所示：type代表一个value对象具体是何种数据类型，encoding是不同数据类型在redis内部的存储方式，比如：type=string代表value存储的是一个普通字符串，那么对应的encoding可以是raw或者是int，如果是int则代表实际redis内部是按数值型类存储和表示这个字符串的，当然前提是这个字符串本身可以用数值表示，比如:”123” “456”这样的字符串。</p>
<p>这里需要特殊说明一下vm字段，只有打开了Redis的虚拟内存功能，此字段才会真正的分配内存，该功能默认是关闭状态的。通过上图我们可以发现Redis使用redisObject来表示所有的key/value数据是比较浪费内存的，当然这些内存管理成本的付出主要也是为了给Redis不同数据类型提供一个统一的管理接口，实际作者也提供了多种方法帮助我们尽量节省内存使用，我们随后会具体讨论。</p>
<h2 id="二、各种数据类型应用和实现方式"><a href="#二、各种数据类型应用和实现方式" class="headerlink" title="二、各种数据类型应用和实现方式"></a>二、各种数据类型应用和实现方式</h2><p>下面我们先来逐一的分析下这五种数据类型的使用和内部实现方式：</p>
<h3 id="1、String"><a href="#1、String" class="headerlink" title="1、String"></a>1、String</h3><p>String 数据结构是简单的key-value类型，value其实不仅是String，也可以是数字。</p>
<p>常用命令：get、set、incr、decr、mget等。</p>
<p>应用场景：String是最常用的一种数据类型，普通的key/ value 存储都可以归为此类，即可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受Redis的定时持久化，操作日志及 Replication等功能。除了提供与 Memcached 一样的get、set、incr、decr 等操作外，Redis还提供了下面一些操作： </p>
<p>获取字符串长度<br>往字符串append内容<br>设置和获取字符串的某一段内容<br>设置及获取字符串的某一位（bit）<br>批量设置一系列字符串的内容<br>==使用场景：常规key-value缓存应用。常规计数: 微博数, 粉丝数。==</p>
<p>实现方式：String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。</p>
<h3 id="2-hashMap"><a href="#2-hashMap" class="headerlink" title="2.hashMap"></a>2.hashMap</h3><p>这里同时需要注意，Redis提供了接口(hgetall)可以直接取到全部的属性数据，但是如果内部Map的成员很多，那么涉及到遍历整个内部Map的操作，由于Redis单线程模型的缘故，这个遍历操作可能会比较耗时，而另其它客户端的请求完全不响应，这点需要格外注意。</p>
<p>使用场景：==存储部分变更数据，如用户信息等。==</p>
<p>实现方式：</p>
<p>   上面已经说到Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap，当成员数量增大时会自动转成真正的HashMap，此时encoding为ht。</p>
<h3 id="3、List"><a href="#3、List" class="headerlink" title="3、List"></a>3、List</h3><p>常用命令：lpush,rpush,lpop,rpop,lrange等。</p>
<p>应用场景：</p>
<p>Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表等都可以用Redis的list结构来实现。</p>
<p>List 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用List结构，我们可以轻松地实现最新消息排行等功能。List的另一个应用就是消息队列，<br>可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删除List中某一段的元素。</p>
<p>实现方式：</p>
<p>Redis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。</p>
<p>Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。 </p>
<p>使用场景：<br>消息队列系统<br>使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。</p>
<p>比如：将Redis用作日志收集器</p>
<p>实际上还是一个队列，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。</p>
<p>取最新N个数据的操作<br>记录前N个最新登陆的用户Id列表，超出的范围可以从数据库中获得。</p>
<p>复制代码<br>//把当前登录人添加到链表里<br>ret = r.lpush(“login:last_login_times”, uid)</p>
<p>//保持链表只有N位<br>ret = redis.ltrim(“login:last_login_times”, 0, N-1)</p>
<p>//获得前N个最新登陆的用户Id列表<br>last_login_list = r.lrange(“login:last_login_times”, 0, N-1)<br>复制代码<br>比如sina微博：</p>
<p> 在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。但是我们做了限制不能超过5000个ID，因此我们的获取ID函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。</p>
<p>我们的系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了</p>
<h2 id="4、Set"><a href="#4、Set" class="headerlink" title="4、Set"></a>4、Set</h2><p>常用命令：</p>
<p>sadd,spop,smembers,sunion 等。</p>
<p>应用场景：</p>
<p> Redis set对外提供的功能与list类似是一个列表的功能，==特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供==。</p>
<p>Set 就是一个集合，集合的概念就是一堆不重复值的组合。利用Redis提供的Set数据结构，可以存储一些集合性的数据。</p>
<p>案例：</p>
<p>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p>
<p>==Set是集合，是String类型的无序集合，set是通过hashtable实现的，概念和数学中个的集合基本类似，可以交集，并集，差集等等，set中的元素是没有顺序的。==</p>
<p>实现方式： </p>
<p>==set 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。==</p>
<p>使用场景：<br>获取某段时间所有数据去重值<br>这个使用Redis的set数据结构最合适了，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。</p>
<h2 id="5、Sorted-Set"><a href="#5、Sorted-Set" class="headerlink" title="5、Sorted Set"></a>5、Sorted Set</h2><p>常用命令：</p>
<p>zadd,zrange,zrem,zcard等</p>
<p>使用场景：</p>
<p>Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要==一个有序的并且不重复的集合列表==，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。</p>
<p>==和Set相比，Sorted Set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的Sorted== Set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用Sorted Set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p>
<p>实现方式：</p>
<p>Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</p>
<h1 id="redis的使用优缺点"><a href="#redis的使用优缺点" class="headerlink" title="redis的使用优缺点"></a>redis的使用优缺点</h1><h2 id="redis为什么快"><a href="#redis为什么快" class="headerlink" title="redis为什么快"></a>redis为什么快</h2><h3 id="速度快，完全基于内存；"><a href="#速度快，完全基于内存；" class="headerlink" title="速度快，完全基于内存；"></a>速度快，完全基于内存；</h3><p>理解这个内存和磁盘的区别 服务器 断电丢失</p>
<h3 id="单线程模型避免了不必要的上下文切换及竞争条件；"><a href="#单线程模型避免了不必要的上下文切换及竞争条件；" class="headerlink" title="单线程模型避免了不必要的上下文切换及竞争条件；"></a>单线程模型避免了不必要的上下文切换及竞争条件；</h3><p>什么是上下文切换</p>
<p>即使是单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程时同时执行的，时间片一般是几十毫秒（ms）。</p>
<p>CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态，从任务保存到再加载的过程就是一次上下文切换</p>
<p>这就像我们同时读两本书，当我们在读一本英文的技术书籍时，发现某个单词不认识， 于是便打开中英文词典，但是在放下英文书籍之前，大脑必须先记住这本书读到了多少页的第多少行，等查完单词之后，能够继续读这本书。这样的切换是会影响读 书效率的，同样上下文切换也会影响多线程的执行速度。</p>
<h3 id="使用C语言实现，网络层使用epoll解决高并发问题-采用了非阻塞-I-O-多路复用机制"><a href="#使用C语言实现，网络层使用epoll解决高并发问题-采用了非阻塞-I-O-多路复用机制" class="headerlink" title="使用C语言实现，网络层使用epoll解决高并发问题 采用了非阻塞 I/O 多路复用机制"></a>使用C语言实现，网络层使用epoll解决高并发问题 采用了非阻塞 I/O 多路复用机制</h3><p><img src="https://img-blog.csdn.net/20180623151715786?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5nd2Vpd2VpMjAyMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"><br>简单来说，就是我们的 redis-client 在操作的时候，会产生具有不同事件类型的 Socket。</p>
<p>在服务端，有一段 I/O 多路复用程序，将其置入队列之中。然后，文件事件分派器，依次去队列中取，转发到不同的事件处理器中。</p>
<p>需要说明的是，这个 I/O 多路复用机制，Redis 还提供了 select、epoll、evport、kqueue 等多路复用函数库，大家可以自行去了解。</p>
<p>经营方式一</p>
<p>客户每送来一份快递，小曲就让一个快递员盯着，然后快递员开车去送快递。</p>
<p>慢慢的小曲就发现了这种经营方式存在下述问题：</p>
<p>几十个快递员基本上时间都花在了抢车上了，大部分快递员都处在闲置状态，谁抢到了车，谁就能去送快递。</p>
<p>随着快递的增多，快递员也越来越多，小曲发现快递店里越来越挤，没办法雇佣新的快递员了。</p>
<p>快递员之间的协调很花时间。</p>
<p>综合上述缺点，小曲痛定思痛，提出了下面的经营方式。</p>
<p>经营方式二</p>
<p>小曲只雇佣一个快递员。然后呢，客户送来的快递，小曲按送达地点标注好，然后依次放在一个地方。</p>
<p>最后，那个快递员依次的去取快递，一次拿一个，然后开着车去送快递，送好了就回来拿下一个快递。</p>
<p>上述两种经营方式对比，是不是明显觉得第二种，效率更高，更好呢？</p>
<p>在上述比喻中：</p>
<p>每个快递员→每个线程</p>
<p>每个快递→每个 Socket(I/O 流)</p>
<p>快递的送达地点→Socket 的不同状态</p>
<p>客户送快递请求→来自客户端的请求</p>
<p>小曲的经营方式→服务端运行的代码</p>
<p>一辆车→CPU 的核数</p>
<p>于是我们有如下结论：</p>
<p>经营方式一就是传统的并发模型，每个 I/O 流(快递)都有一个新的线程(快递员)管理。</p>
<p>经营方式二就是 I/O 多路复用。只有单个线程(一个快递员)，通过跟踪每个 I/O 流的状态(每个快递的送达地点)，来管理多个 I/O 流。</p>
<h2 id="redis能做什么"><a href="#redis能做什么" class="headerlink" title="redis能做什么"></a>redis能做什么</h2><ol>
<li><p>缓存，毫无疑问这是Redis当今最为人熟知的使用场景。再提升服务器性能方面非常有效；</p>
</li>
<li><p>排行榜，如果使用传统的关系型数据库来做这个事儿，非常的麻烦，而利用Redis的SortSet数据结构能够非常方便搞定；</p>
</li>
<li><p>计算器/限速器，利用Redis中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等，这类操作如果用MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个API的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；<br>注：限速器也是对请求限流的一种实现方式。</p>
</li>
<li><p>好友关系，利用集合的一些命令，比如求交集、并集、差集等。可以方便搞定一些共同好友、共同爱好之类的功能；</p>
</li>
<li><p>简单消息队列，除了Redis自身的发布/订阅模式，我们也可以利用List来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的DB压力，完全可以用List来完成异步解耦；</p>
</li>
<li><p>Session共享，默认Session是保存在服务器的文件中，即当前服务器，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用Redis保存Session后，无论用户落在那台机器上都能够获取到对应的Session信息。</p>
</li>
<li><p>注：对于基于Redis实现分布式session 笔者会在以后文章接入说明</p>
</li>
</ol>
<h2 id="redis存在什么问题"><a href="#redis存在什么问题" class="headerlink" title="redis存在什么问题"></a>redis存在什么问题</h2><p>Redis不能做什么<br>Redis感觉能干的事情特别多，但它不是万能的，合适的地方用它事半功倍。如果滥用可能导致系统的不稳定、成本增高等问题。</p>
<p>比如，用Redis去保存用户的基本信息，虽然它能够支持持久化，但是它的持久化方案并不能保证数据绝对的落地，并且还可能带来Redis性能下降，因为持久化太过频繁会增大Redis服务的压力。</p>
<p>简单总结就是数据量太大、数据访问频率非常低的业务都不适合使用Redis。</p>
<p>数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。如果不担心浪费资源，那请忽略。</p>
<h2 id="redis-大key-热key-问题"><a href="#redis-大key-热key-问题" class="headerlink" title="redis 大key 热key 问题"></a>redis 大key 热key 问题</h2><h3 id="Redis-和数据库双写一致性问题"><a href="#Redis-和数据库双写一致性问题" class="headerlink" title="Redis 和数据库双写一致性问题"></a>Redis 和数据库双写一致性问题</h3><p>分布式常见问题，还可以再分为最终一致性和强一致性；<br>另外，我们所做的方案从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。</p>
<p>回答：首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。</p>
<h3 id="如何应对缓存穿透和缓存雪崩问题"><a href="#如何应对缓存穿透和缓存雪崩问题" class="headerlink" title="如何应对缓存穿透和缓存雪崩问题"></a>如何应对缓存穿透和缓存雪崩问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。</p>
<ol>
<li>利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试。</li>
<li>采用异步更新策略，无论 Key 是否取到值，都直接返回。Value 值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。</li>
<li>提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的 Key。迅速判断出，请求所携带的 Key 是否合法有效。如果不合法，则直接返回。<br>缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</li>
</ol>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。</p>
<p>缓存雪崩解决方案：</p>
<ol>
<li>给缓存的失效时间，加上一个随机值，避免集体失效。</li>
<li></li>
<li>使用互斥锁，但是该方案吞吐量明显下降了。</li>
<li></li>
<li>双缓存。我们有两个缓存，缓存 A 和缓存 B。缓存 A 的失效时间为 20 分钟，缓存 B 不设失效时间。自己做缓存预热操作。</li>
</ol>
<p>然后细分以下几个小点：从缓存 A 读数据库，有则直接返回；A 没有数据，直接从 B 读数据，直接返回，并且异步启动一个更新线程，更新线程同时更新缓存 A 和缓存 B。</p>
<h3 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h3><h2 id="总结Redis特性"><a href="#总结Redis特性" class="headerlink" title="总结Redis特性"></a>总结Redis特性</h2><h3 id="速度快"><a href="#速度快" class="headerlink" title="速度快"></a>速度快</h3><p>数据存放在内存中；单线程模式，避免了线程上下文切换及多线程竞争访问</p>
<p>；c语言实现，更容易接近系统api；<br>采用epoll非阻塞IO，不在网络上浪费时间；</p>
<h3 id="支持多种数据类型"><a href="#支持多种数据类型" class="headerlink" title="支持多种数据类型"></a>支持多种数据类型</h3><p>支持8种数据类型：String、Hash、List、Set、 SortSet、Bitmaps、HyperLogLog、GEO；</p>
<h3 id="功能丰富"><a href="#功能丰富" class="headerlink" title="功能丰富"></a>功能丰富</h3><p>丰富的API，如可设置键过期，存在即设置（这可以用来解决分布式锁问题），基于发布订阅可实现简单的消息队列，通过Lua创建新命令，具有原子性，管道（pipeline）功能，解决网络开销；</p>
<h3 id="服务器简单"><a href="#服务器简单" class="headerlink" title="服务器简单"></a>服务器简单</h3><p>开源代码优雅，容易阅读源码，采用单线程模型，避免并发问题，redis自己实现了多路复用；</p>
<h3 id="客户端语言版本多"><a href="#客户端语言版本多" class="headerlink" title="客户端语言版本多"></a>客户端语言版本多</h3><p>如Java、Php、Go</p>
<h3 id="支持多种持久化方式"><a href="#支持多种持久化方式" class="headerlink" title="支持多种持久化方式"></a>支持多种持久化方式</h3><p>RDB和AOP，这两种持久化深入分析请看：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u014229282/article/details/81121214">https://blog.csdn.net/u014229282/article/details/81121214</a></p>
<h3 id="支持集群部署"><a href="#支持集群部署" class="headerlink" title="支持集群部署"></a>支持集群部署</h3><h3 id="支持主从复制，高可用集群，内部集群方式与Memcache做集群实现不一样的机制。"><a href="#支持主从复制，高可用集群，内部集群方式与Memcache做集群实现不一样的机制。" class="headerlink" title="支持主从复制，高可用集群，内部集群方式与Memcache做集群实现不一样的机制。"></a>支持主从复制，高可用集群，内部集群方式与Memcache做集群实现不一样的机制。</h3>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF/">
    <time datetime="2020-11-19T16:00:28.834Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/redis/redis%E7%9F%A5%E8%AF%86%E7%82%B9%E8%87%AA%E6%B5%8B/" rel="prev"><span class="meta-nav">←</span> (no title)</a></span>
    
    
        <span class="nav-next"><a href="/huanghao.github.io/2020/11/20/005.%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0/%E5%AD%98%E5%82%A8/Mysql+%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E9%94%81%E5%92%8C%E4%BA%8B%E5%8A%A1+MVCC%EF%BC%88%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%89/mysql%E9%94%81+mvcc/" rel="next">(no title) <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E6%89%80%E8%B0%93%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E4%BD%9C%E7%94%A8%E5%9F%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80%E7%B1%BB%E6%A6%82%E8%AE%BA/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%80%A7%E8%83%BD%E8%B0%83%E6%A0%91+%E9%83%A8%E7%BD%B2+%E6%B5%8B%E8%AF%95/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 huanghao
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/huanghao.github.io/fancybox/jquery.fancybox.css">

  
<script src="/huanghao.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/huanghao.github.io/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>