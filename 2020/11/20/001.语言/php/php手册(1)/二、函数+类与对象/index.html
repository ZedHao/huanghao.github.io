<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="一剑光寒十九州" />
  

  
  
  
  
  
  
  <title>NK一哥黄大脸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[toc] 函数用户自定义函数1234567891011121314151617181920212223242526&lt;?php$makefoo &#x3D; true;&#x2F;* 不能在此处调用foo()函数，   因为它还不存在，但可以调用bar()函数。*&#x2F;bar();if ($makefoo) &amp;#123;  function foo()  &amp;#123;    echo">
<meta property="og:type" content="article">
<meta property="og:title" content="NK一哥黄大脸">
<meta property="og:url" content="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0+%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="NK一哥黄大脸">
<meta property="og:description" content="[toc] 函数用户自定义函数1234567891011121314151617181920212223242526&lt;?php$makefoo &#x3D; true;&#x2F;* 不能在此处调用foo()函数，   因为它还不存在，但可以调用bar()函数。*&#x2F;bar();if ($makefoo) &amp;#123;  function foo()  &amp;#123;    echo">
<meta property="og:locale">
<meta property="article:published_time" content="2020-11-19T16:00:28.859Z">
<meta property="article:modified_time" content="2020-11-19T16:00:28.859Z">
<meta property="article:author" content="huanghao">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/huanghao.github.io/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/huanghao.github.io/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/huanghao.github.io/atom.xml" title="NK一哥黄大脸" type="application/atom+xml">
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/huanghao.github.io/" title="NK一哥黄大脸" rel="home">NK一哥黄大脸</a>
      </h1>
      
        <h2 <title>谦谦君子 温润如玉</title></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/archives">Archives</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/guestbook">guestbook</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-001.语言/php/php手册(1)/二、函数+类与对象" class="post-001.语言/php/php手册(1)/二、函数+类与对象 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0+%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/" data-id="ckhp0x7rx003z932u924aa83a" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[toc]</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$makefoo &#x3D; true;</span><br><span class="line"></span><br><span class="line">&#x2F;* 不能在此处调用foo()函数，</span><br><span class="line">   因为它还不存在，但可以调用bar()函数。*&#x2F;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line">if ($makefoo) &#123;</span><br><span class="line">  function foo()</span><br><span class="line">  &#123;</span><br><span class="line">    echo &quot;I don&#39;t exist until program execution reaches me.\n&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;* 现在可以安全调用函数 foo()了，</span><br><span class="line">   因为 $makefoo 值为真 *&#x2F;</span><br><span class="line"></span><br><span class="line">if ($makefoo) foo();</span><br><span class="line"></span><br><span class="line">function bar()</span><br><span class="line">&#123;</span><br><span class="line">  echo &quot;I exist immediately upon program start.\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h2 id="函数参数-【三种类型传参-传递数组，引用传参，默认参数的值】"><a href="#函数参数-【三种类型传参-传递数组，引用传参，默认参数的值】" class="headerlink" title="函数参数 【三种类型传参 传递数组，引用传参，默认参数的值】"></a>函数参数 【三种类型传参 传递数组，引用传参，默认参数的值】</h2><h2 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function foo() &#123;</span><br><span class="line">    echo &quot;In foo()&lt;br &#x2F;&gt;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar($arg &#x3D; &#39;&#39;) &#123;</span><br><span class="line">    echo &quot;In bar(); argument was &#39;$arg&#39;.&lt;br &#x2F;&gt;\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 echo 的包装函数</span><br><span class="line">function echoit($string)</span><br><span class="line">&#123;</span><br><span class="line">    echo $string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$func &#x3D; &#39;foo&#39;;</span><br><span class="line">$func();        &#x2F;&#x2F; This calls foo()</span><br><span class="line"></span><br><span class="line">$func &#x3D; &#39;bar&#39;;</span><br><span class="line">$func(&#39;test&#39;);  &#x2F;&#x2F; This calls bar()</span><br><span class="line"></span><br><span class="line">$func &#x3D; &#39;echoit&#39;;</span><br><span class="line">$func(&#39;test&#39;);  &#x2F;&#x2F; This calls echoit()</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h2 id="匿名函数-closures-闭包函数"><a href="#匿名函数-closures-闭包函数" class="headerlink" title="匿名函数[closures] 闭包函数"></a>匿名函数[closures] 闭包函数</h2><h3 id="匿名函数-变量赋值-从父作用域继承变量"><a href="#匿名函数-变量赋值-从父作用域继承变量" class="headerlink" title="匿名函数  变量赋值+ 从父作用域继承变量"></a>匿名函数  变量赋值+ 从父作用域继承变量</h3><p><a target="_blank" rel="noopener" href="http://www.php.cn/php-weizijiaocheng-400799.html">http://www.php.cn/php-weizijiaocheng-400799.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">echo preg_replace_callback(&#39;~-([a-z])~&#39;, function ($match) &#123;</span><br><span class="line">&#x2F;&#x2F;例一</span><br><span class="line">&#x2F;&#x2F;在函数里定义一个匿名函数，并且调用它</span><br><span class="line">function printStr() &#123;</span><br><span class="line">  $func &#x3D; function( $str ) &#123;</span><br><span class="line">    echo $str;</span><br><span class="line">  &#125;;</span><br><span class="line">  $func( &#39;some string&#39; );</span><br><span class="line">&#125;</span><br><span class="line">printStr();</span><br><span class="line">&#x2F;&#x2F;例二</span><br><span class="line">&#x2F;&#x2F;在函数中把匿名函数返回，并且调用它</span><br><span class="line">function getPrintStrFunc() &#123;</span><br><span class="line">  $func &#x3D; function( $str ) &#123;</span><br><span class="line">    echo $str;</span><br><span class="line">  &#125;;</span><br><span class="line">  return $func;</span><br><span class="line">&#125;</span><br><span class="line">$printStrFunc &#x3D; getPrintStrFunc();</span><br><span class="line">$printStrFunc( &#39;some string&#39; );</span><br><span class="line">&#x2F;&#x2F;例三</span><br><span class="line">&#x2F;&#x2F;把匿名函数当做参数传递，并且调用它</span><br><span class="line">function callFunc( $func ) &#123;</span><br><span class="line">  $func( &#39;some string&#39; );</span><br><span class="line">&#125;</span><br><span class="line">$printStrFunc &#x3D; function( $str ) &#123;</span><br><span class="line">  echo $str;</span><br><span class="line">&#125;;</span><br><span class="line">callFunc( $printStrFunc );</span><br><span class="line">&#x2F;&#x2F;也可以直接将匿名函数进行传递。如果你了解js，这种写法可能会很熟悉</span><br><span class="line">callFunc( function( $str ) &#123;</span><br><span class="line">  echo $str;</span><br><span class="line">&#125; );</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>


<h3 id="可以看做匿名函数"><a href="#可以看做匿名函数" class="headerlink" title="可以看做匿名函数"></a>可以看做匿名函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$numberPlusOne &#x3D; array_map(function ($number) &#123;</span><br><span class="line">    return $number +&#x3D; 1;</span><br><span class="line">&#125;, [1, 2, 3]);</span><br><span class="line"></span><br><span class="line">print_r($numberPlusOne);</span><br></pre></td></tr></table></figure>
<p>==附加状态==</p>
<p>PHP闭包不会像真正的javascrypt闭包那样自动封装应用的状态，我们必须手动调用闭包对象的 ==bindTo()== 方法或者==使用 use== 关键字，==把状态附加到PHP闭包上==。<br>==使用 use 关键字==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Car ($name)&#123;</span><br><span class="line">  return function($statu)use($name)&#123;</span><br><span class="line">    return sprintf(&quot;Car %s is %s&quot;, $name, $statu); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 将车名封装在闭包中</span><br><span class="line">$car &#x3D; Car(&quot;bmw&quot;);</span><br><span class="line">&#x2F;&#x2F; 调用车的动作</span><br><span class="line">&#x2F;&#x2F; 输出--&gt; &quot;bmw is running&quot;</span><br><span class="line">echo $car(&quot;running&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="闭包的好处"><a href="#闭包的好处" class="headerlink" title="闭包的好处"></a>闭包的好处</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yjf512/archive/2012/10/29/2744702.html">link</a></p>
<h4 id="1-减少foreach的循环的代码"><a href="#1-减少foreach的循环的代码" class="headerlink" title="1 减少foreach的循环的代码"></a>1 减少foreach的循环的代码</h4><p>比如手册<a target="_blank" rel="noopener" href="http://php.net/manual/en/functions.anonymous.php">http://php.net/manual/en/functions.anonymous.php</a> 中的例子Cart</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F; 一个基本的购物车，包括一些已经添加的商品和每种商品的数量。</span><br><span class="line">&#x2F;&#x2F; 其中有一个方法用来计算购物车中所有商品的总价格。该方法使用了一个closure作为回调函数。</span><br><span class="line">class Cart</span><br><span class="line">&#123;</span><br><span class="line">    const PRICE_BUTTER  &#x3D; 1.00;</span><br><span class="line">    const PRICE_MILK    &#x3D; 3.00;</span><br><span class="line">    const PRICE_EGGS    &#x3D; 6.95;</span><br><span class="line"> </span><br><span class="line">    protected   $products &#x3D; array();</span><br><span class="line">     </span><br><span class="line">    public function add($product, $quantity)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;products[$product] &#x3D; $quantity;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public function getQuantity($product)</span><br><span class="line">    &#123;</span><br><span class="line">        return isset($this-&gt;products[$product]) ? $this-&gt;products[$product] :</span><br><span class="line">               FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public function getTotal($tax)</span><br><span class="line">    &#123;</span><br><span class="line">        $total &#x3D; 0.00;</span><br><span class="line">         </span><br><span class="line">        $callback &#x3D;</span><br><span class="line">            function ($quantity, $product) use ($tax, &amp;$total)</span><br><span class="line">            &#123;</span><br><span class="line">                $pricePerItem &#x3D; constant(__CLASS__ . &quot;::PRICE_&quot; .</span><br><span class="line">                    strtoupper($product));</span><br><span class="line">                $total +&#x3D; ($pricePerItem * $quantity) * ($tax + 1.0);</span><br><span class="line">            &#125;;</span><br><span class="line">         </span><br><span class="line">        array_walk($this-&gt;products, $callback); &#x2F;&#x2F;数组中的每个元素应用用户自定义函数：</span><br><span class="line">        return round($total, 2);;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$my_cart &#x3D; new Cart;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 往购物车里添加条目</span><br><span class="line">$my_cart-&gt;add(&#39;butter&#39;, 1);</span><br><span class="line">$my_cart-&gt;add(&#39;milk&#39;, 3);</span><br><span class="line">$my_cart-&gt;add(&#39;eggs&#39;, 6);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 打出出总价格，其中有 5% 的销售税.</span><br><span class="line">print $my_cart-&gt;getTotal(0.05) . &quot;\n&quot;;</span><br><span class="line">&#x2F;&#x2F; The result is 54.29</span><br></pre></td></tr></table></figure>
<h4 id="2-减少函数的参数"><a href="#2-减少函数的参数" class="headerlink" title="2 减少函数的参数"></a>2 减少函数的参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function html ($code , $id&#x3D;&quot;&quot;, $class&#x3D;&quot;&quot;)&#123;</span><br><span class="line"> </span><br><span class="line">if ($id !&#x3D;&#x3D; &quot;&quot;) $id &#x3D; &quot; id &#x3D; \&quot;$id\&quot;&quot; ;</span><br><span class="line"> </span><br><span class="line">$class &#x3D; ($class !&#x3D;&#x3D; &quot;&quot;)? &quot; class &#x3D;\&quot;$class\&quot;&quot;:&quot;&gt;&quot;;</span><br><span class="line"> </span><br><span class="line">$open &#x3D; &quot;&lt;$code$id$class&quot;;</span><br><span class="line"> </span><br><span class="line">$close &#x3D; &quot;&lt;&#x2F;$code&gt;&quot;;</span><br><span class="line"> </span><br><span class="line">return function ($inner &#x3D; &quot;&quot;) use ($open, $close)&#123;</span><br><span class="line"> </span><br><span class="line">return &quot;$open$inner$close&quot;;&#125;;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是使用平时的方法，我们会把inner放到html函数参数中，这样不管是代码阅读还是使用都不如使用闭包</p>
<h4 id="3-解除递归函数"><a href="#3-解除递归函数" class="headerlink" title="3 解除递归函数"></a>3 解除递归函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $fib &#x3D; function($n) use(&amp;$fib) &#123;</span><br><span class="line">        if($n &#x3D;&#x3D; 0 || $n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">        return $fib($n - 1) + $fib($n - 2);</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">   echo $fib(2) . &quot;\n&quot;; &#x2F;&#x2F; 2</span><br><span class="line">   $lie &#x3D; $fib;</span><br><span class="line">   $fib &#x3D; function()&#123;die(&#39;error&#39;);&#125;;&#x2F;&#x2F;rewrite $fib variable </span><br><span class="line">   echo $lie(5); &#x2F;&#x2F; error   because $fib is referenced by closure</span><br></pre></td></tr></table></figure>

<p>注意上题中的use使用了&amp;，这里不使用&amp;会出现错误fib(fib(n-1)是找不到function的（前面没有定义fib的类型）</p>
<p>所以想使用闭包解除循环函数的时候就需要使用</p>
<h4 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h4><p>如果你需要延迟绑定use里面的变量，你就需要使用引用(&amp;)，否则在定义的时候就会做一份拷贝放到use中 //理解use(&amp;$var)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">$result &#x3D; 0; </span><br><span class="line"></span><br><span class="line">$one &#x3D;function() </span><br><span class="line">&#123; var_dump($result); &#125;; </span><br><span class="line"></span><br><span class="line">$two &#x3D;function()use ($result) </span><br><span class="line">&#123; var_dump($result); &#125;; </span><br><span class="line"></span><br><span class="line">$three &#x3D;function()use (&amp;$result) </span><br><span class="line">&#123; var_dump($result); &#125;; </span><br><span class="line"></span><br><span class="line">$result++; </span><br><span class="line"></span><br><span class="line">$one(); &#x2F;&#x2F; outputs NULL: $result is not in scope </span><br><span class="line">$two(); &#x2F;&#x2F; outputs int(0): $result was copied </span><br><span class="line">$three(); &#x2F;&#x2F; outputs int(1)</span><br></pre></td></tr></table></figure>
<h1 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h1><h2 id="伪变量"><a href="#伪变量" class="headerlink" title="伪变量"></a>伪变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">  </span><br><span class="line">class human&#123;  </span><br><span class="line">      </span><br><span class="line">    public $name&#x3D;&quot;李四&quot;;  </span><br><span class="line">      </span><br><span class="line">    public function eat()&#123;  </span><br><span class="line">      </span><br><span class="line">      echo $this-&gt;name,&#39;在吃饭&#39;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    public function test()&#123;  </span><br><span class="line">      </span><br><span class="line">      echo $name,&#39;在吃饭&#39;;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">$li&#x3D;new human();  </span><br><span class="line">echo $li-&gt;name;&#x2F;&#x2F;李四  </span><br><span class="line">$li-&gt;eat();&#x2F;&#x2F;李四在吃饭</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="类的自动加载"><a href="#类的自动加载" class="headerlink" title="类的自动加载"></a>类的自动加载</h2><h3 id="自动加载怎么出现的"><a href="#自动加载怎么出现的" class="headerlink" title="自动加载怎么出现的"></a>自动加载怎么出现的</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_37356656/article/details/78642520">https://blog.csdn.net/weixin_37356656/article/details/78642520</a><br>     少量的类的引用 有 require 即可<br>     __autoload()函数PHP在找不到类的时候会自动执行 但是PHP内部并没有定义这个函数，这个函数需要开发着自己定义，并且编写内部逻辑，</p>
<pre><code>如果项目比较大，加载每个文件都使用同样的规则显然是不现实的，那么我们可能就需要在__autoload()中编写复杂的规则逻辑来满足加载不同文件的需求。这同样会使得__autoload()函数变得复杂臃肿，难以维护管理。

于是，SPL(Standard PHP Library 标准PHP类库)的自动加载机制就应时而生了。</code></pre>
<h3 id="自动加载的分类"><a href="#自动加载的分类" class="headerlink" title="自动加载的分类"></a>自动加载的分类</h3><h4 id="PHP自带的类的自动加载方式-autoload-到-spl-autoload-register"><a href="#PHP自带的类的自动加载方式-autoload-到-spl-autoload-register" class="headerlink" title="PHP自带的类的自动加载方式  __autoload()到 spl_autoload_register"></a>PHP自带的类的自动加载方式  __autoload()到 spl_autoload_register</h4><h5 id="autoload机制（惰性加载）的主要执行过程为："><a href="#autoload机制（惰性加载）的主要执行过程为：" class="headerlink" title="autoload机制（惰性加载）的主要执行过程为："></a>autoload机制（惰性加载）的主要执行过程为：</h5><p>检查执行器全局变量函数指针autoload_func是否是NULL；<br>如果 autoload_func==NULL ,则查找系统是否定义 __autoload() 函数，如果定义了，则执行并返回加载结果。如果没有定义，则报错并退出；<br>如果 autoload_func 不等于NULL，则直接执行 autoload_func 指向的函数加载类，此时并不检查 __autoload() 函数是否定义。</p>
<h5 id="spl-autoload-register（）"><a href="#spl-autoload-register（）" class="headerlink" title="spl_autoload_register（）"></a>spl_autoload_register（）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class A&#123;</span><br><span class="line">    public function test()&#123;</span><br><span class="line">        $b_object &#x3D; new B();</span><br><span class="line">        $b_object-&gt;echo_info();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function __autoload($classname)&#123;</span><br><span class="line">    require $classname.&#39;.php&#39;;&#x2F;&#x2F;include &#39;b.php&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function my_autoload($classname)&#123;</span><br><span class="line">    require $classname.&#39;.php&#39;;&#x2F;&#x2F;include &#39;b.php&#39;;</span><br><span class="line">    echo &#39;my_autoload   &#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spl_autoload_register(&#39;my_autoload&#39;);</span><br><span class="line">$a_object &#x3D; new A();</span><br><span class="line">$a_object-&gt;test();</span><br><span class="line"></span><br><span class="line">结果：my_autoload  我是class B中的方法执行结果</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>


<p>可以看到，通过 spl_autoload_register（’my_autoload’），实现了 当程序执行找不到类B时，会执行 自定义的 my_autoload()函数，加载B类。实际上 spl_autoload_register（’my_autoload’） 的作用就是 把autoload_func 指针指向 my_autoload()。现在，整个PHP 自动加载过程就明白了。<br>因为SPL扩展内部自己定义了一个自动加载函数 spl_autoload(),实现了自动加载的功能，如果我们不定义自己的自动加载函数，并且程序里写了 spl_autoload_register（）（如果不传参数，必须是第一次执行才会有效）或者 spl_autoload_register（’spl_autoload’），那么autoload_func 指针就会指向内部函数 spl_autoload()。程序执行的时候如果找不到相应类就会执行该自动加载函数。</p>
<p>那么，SPL 是怎么实现autoload_func 指针指向不同的函数呢？<br> spl_autoload_functions() //打印autoload_functions列表<br>  spl_autoload_unregister() //注销自动加载函数<br>原来，在SPL内部定义了 一个函数 spl_autoload_call() 和 一个全局变量autoload_functions。autoload_functions本质上是一个HashTable，不过我们可以将其简单的看作一个链表，链表中的每一个元素都是一个函数指针,指向一个具有自动加载类功能的函数。</p>
<p>spl_autoload_call()的作用就是按顺序遍历 autoload_functions，使得autoload_func指向每个自动加载函数，如果加载成功就停止，如果不成功就继续遍历下个自动加载函数，直到加载成功或者遍历完所有的函数。</p>
<p>那么，autoload_functions 这个列表是谁来维护的呢？就是 spl_autoload_register() 这个函数。我们说的自动加载函数的注册，其实就是通过spl_autoload_register()把自动加载函数加入到 autoload_functions 列表。<br>相关SPL自动加载函数：<br>  spl_autoload_functions() //打印autoload_functions列表<br>  spl_autoload_unregister() //注销自动加载函数</p>
<h4 id="composer-自动加载"><a href="#composer-自动加载" class="headerlink" title="composer 自动加载"></a>composer 自动加载</h4><p>你有一个项目依赖于若干个库。<br>其中一些库依赖于其他库。<br>你声明你所依赖的东西。<br>Composer 会找出哪个版本的包需要安装，并安装它们（将它们下载到你的项目中）。</p>
<h4 id="PHP的Yaf框架下的自动加载方式"><a href="#PHP的Yaf框架下的自动加载方式" class="headerlink" title="PHP的Yaf框架下的自动加载方式"></a>PHP的Yaf框架下的自动加载方式</h4><h2 id="访问可见性"><a href="#访问可见性" class="headerlink" title="访问可见性"></a>访问可见性</h2><h3 id="public-protect-private"><a href="#public-protect-private" class="headerlink" title="public protect private"></a>public protect private</h3><p>public的权限最大，既可以让子类使用，也可以支持实例化之后的调用，<br>protected表示的是受保护的，访问的权限是只有在子类和本类中才可以被访问到<br>private 表示的是私有，只能够是在当前的类中可以被访问到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line">* Define MyClass</span><br><span class="line">*&#x2F;</span><br><span class="line">class MyClass</span><br><span class="line">&#123;</span><br><span class="line"> public $public &#x3D; &#39;Public&#39;;</span><br><span class="line"> protected $protected &#x3D; &#39;Protected&#39;;</span><br><span class="line"> private $private &#x3D; &#39;Private&#39;;</span><br><span class="line"> public function printHello()</span><br><span class="line"> &#123;</span><br><span class="line"> echo $this-&gt;public;</span><br><span class="line"> echo $this-&gt;protected;</span><br><span class="line"> echo $this-&gt;private;</span><br><span class="line"> &#125;</span><br><span class="line"> protected function pro_test()&#123;</span><br><span class="line"> var_dump(1);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">$obj &#x3D; new MyClass();</span><br><span class="line">echo $obj-&gt;public; &#x2F;&#x2F; 这行能被正常执行</span><br><span class="line">&#x2F;&#x2F;echo $obj-&gt;protected; &#x2F;&#x2F; 这行会产生一个致命错误</span><br><span class="line">&#x2F;&#x2F;echo $obj-&gt;private; &#x2F;&#x2F; 这行也会产生一个致命错误</span><br><span class="line">$obj-&gt;printHello(); &#x2F;&#x2F; 输出 Public、Protected 和 Private</span><br><span class="line">$obj-&gt;pro_test();&#x2F;&#x2F;直接报错</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>注意 实例化对象 new 相当于外部调用</p>
<h2 id="对象继承-extend"><a href="#对象继承-extend" class="headerlink" title="对象继承 extend"></a>对象继承 extend</h2><p>extends</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extends是继承某个类，继承之后可以使用父类的方法，也可以重写父类的方法，</span><br></pre></td></tr></table></figure>
<p>  ==如果类被声明为final，则不能被继承==</p>
<h2 id="静态关键字-static"><a href="#静态关键字-static" class="headerlink" title="静态关键字 static"></a>静态关键字 static</h2><p> static的作用就是能够实现值或者方法在类中不需实例化的情况下调用，同时static修饰的变量具有与值存储的功能，<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yolo-bean/p/7739265.html">link</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class class1</span><br><span class="line">&#123;</span><br><span class="line">    public static function test()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">class class2</span><br><span class="line">&#123;</span><br><span class="line">    public function test()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">静态方法调用</span><br><span class="line">class1::test(); </span><br><span class="line">非静态方法调用</span><br><span class="line">$c2 &#x3D; new class2(); </span><br><span class="line">$c2-&gt;test();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>静态是随着累的加载而加载的  也就是说类只要存在了，那么静态就存在了，而静态是优先于对象存在的  ，你要访问非静态的东西，也就是非静态的成员（包括变量和方法），非静态的东西还没存在你怎么访问的到</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zealfory/article/details/78913084">https://blog.csdn.net/zealfory/article/details/78913084</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33774822/article/details/61197364">https://blog.csdn.net/qq_33774822/article/details/61197364</a></p>
<h2 id="abstract-抽象类"><a href="#abstract-抽象类" class="headerlink" title="abstract 抽象类"></a>abstract 抽象类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抽象方法是只有方法声明，而没有方法的实现内容。</span><br></pre></td></tr></table></figure>

<p>abstract有以下的这些特征：</p>
<ol>
<li><p>只要类中有至少一个方法使用了abstract关键字，那么这个类是abstract，要加上相应的关键字</p>
</li>
<li><p>抽象方法，只有方法的声明部分，没有方法体。</p>
</li>
</ol>
<p>但是在我看来，abstract在实际的应用中有这样的几种场景</p>
<ol>
<li><p>多人编程的时候规范公共部分的命名规则（不做任何说明，原理跟interface一样）</p>
</li>
<li><p>实现不让父级直接实例化使用</p>
</li>
</ol>
<p>==抽象类不能被实例化==，通常是将抽象方法做为子类方法重写使用的，且要把继承的抽象类里的方法都实现</p>
<h3 id="接口-interface"><a href="#接口-interface" class="headerlink" title="接口 interface"></a>接口 interface</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface即PHP接口，并用关键字implements来实现接口中方法，且必须完全实现。 否则报错 类可以实现多个接口，用逗号来分隔多个接口的名称。</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">#### 抽象类和接口的区别</span><br><span class="line">接口是一个特殊的抽象类，也可以看作是一个模型的规范，接口与抽象类大致区别如下：</span><br><span class="line"></span><br><span class="line">1，一个子类如果implements一个接口，就必须实现接口中的所有方法（不管是否需要）；如果是继承一个抽象类，只需要实现需要的方法即可</span><br><span class="line"></span><br><span class="line">2，如果一个接口中定义的方法名改变了，那么所有市县次接口的子类需要同更新方法名，而抽象类中如果方法名改变了，其子类对应的方法名将不受影响，只是变成了一个新的方法而已</span><br><span class="line"></span><br><span class="line">3，抽象类只能单继承，当一个子类需要实现的功能需要集成多个父类，就必须适用接口</span><br><span class="line">### 性状 trait （类似多继承）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作用有两个：</span><br><span class="line">1. 表明类可以做什么（像是接口）</span><br><span class="line">2. 提供模块化实现（像是类）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<?php


trait Hello 
{
    public function getHello()
    {
        echo "Hello";
    }
}

trait World 
{
    public function getWorld()
    {
        echo "World";
    }
}

class HelloWorld 
{
    use Hello, World;

    public function sayHelloWorld()
    {
        echo "!";
    }
}

$hw = new HelloWorld();
$hw->getHello();
$hw->getWorld();
$hw->sayHelloWorld();
?>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">编写通用根类，实现基本功能，扩展根类</span><br><span class="line">DRY原则（DONNOT Repeat Yourself）</span><br><span class="line">## 匿名类和重载 可以遍历对象（php5）</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<?php

// PHP 7 之前的代码
class Logger
{
    public function log($msg)
    {
        echo $msg;
    }
}

$util->setLogger(new Logger());

// 使用了 PHP 7+ 后的代码
$util->setLogger(new class {
    public function log($msg)
    {
        echo $msg;
    }
});
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">## 魔术方法 __（两个下划线）开头的类方法保留为魔术方法</span><br><span class="line">PHP 将所有以 __（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 __ 为前缀</span><br><span class="line">_construct()， __destruct()，</span><br><span class="line">__call()， 你调用的方法不存在的时候，会解释器会调用__call方法</span><br><span class="line">__callStatic()， 当调用的静态方法不存在或权限不足时，会自动调用__callStatic方法。</span><br><span class="line">__get()，</span><br><span class="line">__set()， </span><br><span class="line">__isset()，</span><br><span class="line">__unset()， </span><br><span class="line">__sleep()， 可以用于清理对象</span><br><span class="line">__wakeup()， 例如重新建立数据库连接，或执行其它初始化操作。</span><br><span class="line">__toString()，</span><br><span class="line">__invoke()，以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用</span><br><span class="line">__set_state()， </span><br><span class="line">__clone()  克隆</span><br><span class="line">__debugInfo() 执行var_dump()方法的时候会调用__debugInfo()方法</span><br><span class="line">## final </span><br><span class="line">Final 关键字</span><br><span class="line">PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。</span><br><span class="line">## 对象复制 clone</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<?php
class a{
    public $v = 1;
}
$obj = new a();
// 1. clone方式
// $copy_obj = clone $obj;
// 2. 标识赋值方式
// $copy_obj = $obj;
// 3. 引用赋值方式
// $copy_obj = &$obj;
$copy_obj->v = 2;
echo '原对象的v属性等于' . $obj1->v;
echo '<br />';
echo '复制对象的v属性等于' . $obj2->v;

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## 类型约束 指定类型</span><br><span class="line">PHP 5 可以使用类型约束。函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组（PHP 5.1 起）或者 callable（PHP 5.4 起）。不过如果使用 NULL 作为参数的默认值，那么在调用函数的时候依然可以使用 NULL 作为实参。</span><br><span class="line"></span><br><span class="line">如果一个类或接口指定了类型约束，则其所有的子类或实现也都如此。</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;函数调用的参数与定义的参数类型不一致时，会抛出一个可捕获的致命错误。&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">类型约束不能用于标量类型如 int 或 string。Traits 也不允许。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<?php
//如下面的类
class MyClass
{
    /**
     * 测试函数
     * 第一个参数必须为 OtherClass 类的一个对象
     */
    public function test(OtherClass $otherclass) {
        echo $otherclass->var;
    }


    /**
     * 另一个测试函数
     * 第一个参数必须为数组 
     */
    public function test_array(array $input_array) {
        print_r($input_array);
    }
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## 后期静态绑定 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<?php
class A {
    public static function foo() {
        static::who();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}

class B extends A {
    public static function test() {
        A::foo();
        parent::foo();
        self::foo();
    }

    public static function who() {
        echo __CLASS__."\n";
    }
}
class C extends B {
    public static function who() {
        echo __CLASS__."\n";
    }
}

C::test();
?>
<p>以上例程会输出：<br>A<br>C<br>C</p>
<p>```</p>
<h2 id="对象和引用-amp-序列化和反序列化"><a href="#对象和引用-amp-序列化和反序列化" class="headerlink" title="对象和引用&amp;  序列化和反序列化"></a>对象和引用&amp;  序列化和反序列化</h2>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0+%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/">
    <time datetime="2020-11-19T16:00:28.859Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%5B%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%5D+%E8%BF%90%E7%AE%97%E7%AC%A6+%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%EF%BC%89/" rel="prev"><span class="meta-nav">←</span> (no title)</a></span>
    
    
        <span class="nav-next"><a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%89%8B%E5%86%8C(1)/%E4%B8%83%E3%80%81%E5%AE%89%E5%85%A8%E8%8C%83%E7%95%B4%EF%BC%88sql%E6%B3%A8%E5%85%A5%20xxs%20crsf%E7%AD%89%EF%BC%89/" rel="next">(no title) <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E6%89%80%E8%B0%93%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E4%BD%9C%E7%94%A8%E5%9F%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80%E7%B1%BB%E6%A6%82%E8%AE%BA/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%80%A7%E8%83%BD%E8%B0%83%E6%A0%91+%E9%83%A8%E7%BD%B2+%E6%B5%8B%E8%AF%95/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 huanghao
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/huanghao.github.io/fancybox/jquery.fancybox.css">

  
<script src="/huanghao.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/huanghao.github.io/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>