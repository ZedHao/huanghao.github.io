<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="一剑光寒十九州" />
  

  
  
  
  
  
  
  <title>NK一哥黄大脸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="[toc]https:&#x2F;&#x2F;www.cnblogs.com&#x2F;peterYong&#x2F;p&#x2F;6556619.html 背景内存是计算机中最重要的资源之一,&#x3D;&#x3D;通常情况下，物理内存无法容纳下所有的进程&#x3D;&#x3D;。虽然物理内存的增长现在达到了N个GB，但比物理内存增长还快的是程序，所以无论物理内存如何增长，都赶不上程序增长的速度，所以操作系统如何有效的管理内存便显得尤为重要。本文讲述操作系统对于内存的管理的过去和现在">
<meta property="og:type" content="article">
<meta property="og:title" content="NK一哥黄大脸">
<meta property="og:url" content="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/index.html">
<meta property="og:site_name" content="NK一哥黄大脸">
<meta property="og:description" content="[toc]https:&#x2F;&#x2F;www.cnblogs.com&#x2F;peterYong&#x2F;p&#x2F;6556619.html 背景内存是计算机中最重要的资源之一,&#x3D;&#x3D;通常情况下，物理内存无法容纳下所有的进程&#x3D;&#x3D;。虽然物理内存的增长现在达到了N个GB，但比物理内存增长还快的是程序，所以无论物理内存如何增长，都赶不上程序增长的速度，所以操作系统如何有效的管理内存便显得尤为重要。本文讲述操作系统对于内存的管理的过去和现在">
<meta property="og:locale">
<meta property="og:image" content="http://img.blog.csdn.net/20150922233833618">
<meta property="og:image" content="https://images.cnblogs.com/cnblogs_com/CareySon/201204/201204251637369621.png">
<meta property="og:image" content="https://images.cnblogs.com/cnblogs_com/CareySon/201204/201204251637421262.png">
<meta property="og:image" content="https://images.cnblogs.com/cnblogs_com/CareySon/201204/201204251637498957.png">
<meta property="og:image" content="https://images.cnblogs.com/cnblogs_com/CareySon/201204/20120425163755141.png">
<meta property="og:image" content="https://images.cnblogs.com/cnblogs_com/CareySon/201204/201204251637589948.png">
<meta property="og:image" content="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/EDA141F869784AFA85400793187C4CB4">
<meta property="article:published_time" content="2020-11-19T16:00:28.791Z">
<meta property="article:modified_time" content="2020-11-19T16:00:28.791Z">
<meta property="article:author" content="huanghao">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://img.blog.csdn.net/20150922233833618">
  
  
    <link rel="icon" href="/huanghao.github.io/css/images/favicon.ico">
  
  
<link rel="stylesheet" href="/huanghao.github.io/css/style.css">

  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
<meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/huanghao.github.io/atom.xml" title="NK一哥黄大脸" type="application/atom+xml">
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/huanghao.github.io/" title="NK一哥黄大脸" rel="home">NK一哥黄大脸</a>
      </h1>
      
        <h2 <title>谦谦君子 温润如玉</title></h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/archives">Archives</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/huanghao.github.io/guestbook">guestbook</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-003.操作系统+计算机原理（linux）/本科操作系统入门/三、内存管理" class="post-003.操作系统+计算机原理（linux）/本科操作系统入门/三、内存管理 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://zedhao.github.io/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" data-id="ckhp0x7qi0014932u8x2rca2e" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>[toc]<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/peterYong/p/6556619.html">https://www.cnblogs.com/peterYong/p/6556619.html</a></p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>内存是计算机中最重要的资源之一,==通常情况下，物理内存无法容纳下所有的进程==。虽然物理内存的增长现在达到了N个GB，但比物理内存增长还快的是程序，所以无论物理内存如何增长，都赶不上程序增长的速度，所以操作系统如何有效的管理内存便显得尤为重要。本文讲述操作系统对于内存的管理的过去和现在，以及一些页替换的算法的介绍。</p>
<h1 id="内存管理的功能有："><a href="#内存管理的功能有：" class="headerlink" title="内存管理的功能有："></a>内存管理的功能有：</h1><ol>
<li>内存空间的分配与回收：由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。</li>
<li>地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。</li>
<li>内存空间的扩充：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。</li>
<li>存储保护：保证各道作业在各自的存储空间内运行，.互不干扰。<h1 id="程序装入和链接"><a href="#程序装入和链接" class="headerlink" title="程序装入和链接"></a>程序装入和链接</h1>创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</li>
</ol>
<ul>
<li>编译：由编译程序将用户源代码编译成若干个目标模块。</li>
<li>链接：由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块。</li>
<li>装入：由装入程序将装入模块装入内存运行。<br><img src="http://img.blog.csdn.net/20150922233833618" alt="image"></li>
</ul>
<h1 id="内存抽象"><a href="#内存抽象" class="headerlink" title="内存抽象"></a>内存抽象</h1><p> 在现代的操作系统中，同一时间运行多个进程是再正常不过的了==。为了解决直接操作内存带来的各种问题，引入的地址空间(Address Space),这允许每个进程拥有自己的地址。==这还需要硬件上存在两个寄存器，基址寄存器(base register)和界址寄存器(limit register),第一个寄存器保存进程的开始地址，第二个寄存器保存上界，防止内存溢出。</p>
<p> 在这种情况下，==任何操作虚拟地址的操作都会被转换为操作物理地址。而每一个进程所拥有的内存地址是完全不同的，因此也使得多进程成为可能。==</p>
<p>通常来说==，内存大小不可能容纳下所有并发执行的进程。因此，交换(Swapping)技术应运而生。==这个交换和前面所讲的交换大同小异,只是现在讲的交换在多进程条件下。交换的基本思想是，将闲置的进程交换出内存，暂存在硬盘中，待执行时再交换回内存，比如下面</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/CareySon/201204/201204251637369621.png" alt="image"><br>经过图，我们还发现一个问题，进程D和C之间的空间由于太小无法另任何进程使用，这也就是所谓的==外部碎片==。、</p>
<p>紧凑技术(Memory Compaction)解决，通过移动进程在内存中的地址，使得这些外部碎片空间被填满。</p>
<p>内存整理软件，原理是申请一块超大的内存，将所有进程置换出内存，然后再释放这块内存，从而使得从新加载进程，使得外部碎片被消除。</p>
<p>上面的理论都是基于进程所占的内存空间是固定的这个假设，但实际情况下，进程往往会动态增长，因此创建进程时分配的内存就是个问题了，如果分配多了，会产生内部碎片，浪费了内存，而分配少了会造成内存溢出。<br><img src="https://images.cnblogs.com/cnblogs_com/CareySon/201204/201204251637421262.png" alt="image"></p>
<h2 id="两种方法-得知内存的使用情况"><a href="#两种方法-得知内存的使用情况" class="headerlink" title="两种方法 得知内存的使用情况"></a>两种方法 得知内存的使用情况</h2><ul>
<li>一个解决方法是在进程创建的时候，比进程实际需要的多分配一点内存空间用于进程的增。</li>
<li>一种是直接多分配一点内存空间用于进程在内存中的增长，</li>
<li>另一种是将增长区分为数据段和栈（用于存放返回地址和局部变量）,如图3所示。<br>当允许进程动态增长时，操作系统必须对内存进行更有效的管理，操作系统使用如下两种方法之一来得知内存的使用情况，分别为1)位图(bitmap) 2)链表</li>
</ul>
<p><img src="https://images.cnblogs.com/cnblogs_com/CareySon/201204/201204251637498957.png" alt="image"><br>使用链表中的P表示进程，从0-2是进程，H表示空闲，从3-4表示是空闲。</p>
<h2 id="对进程创建时的空间进行分配算法"><a href="#对进程创建时的空间进行分配算法" class="headerlink" title="对进程创建时的空间进行分配算法"></a>对进程创建时的空间进行分配算法</h2><ol>
<li><pre><code> 临近适应算法(Next fit)---从当前位置开始，搜索第一个能满足进程要求的内存空间</code></pre>
</li>
<li><pre><code> 最佳适应算法(Best fit)---搜索整个链表，找到能满足进程要求最小内存的内存空间</code></pre>
</li>
<li><pre><code> 最大适应算法(Wrost fit)---找到当前内存中最大的空闲空间</code></pre>
</li>
<li><pre><code> 首次适应算法(First fit) ---从链表的第一个开始，找到第一个能满足进程要求的内存空间</code></pre>
</li>
</ol>
<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h2 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h2><p>虚拟内存是现代操作系统普遍使用的一种技术。前面所讲的抽象满足了多进程的要求，但很多情况下，现有内存无法满足仅仅一个大进程的内存要求(比如很多游戏，都是10G+的级别)。在早期的操作系统曾使用覆盖(overlays)来解决这个问题，将一个程序分为多个块，基本思想是先将块0加入内存，块0执行完后，将块1加入内存。依次往复，这个解决方案最大的问题是需要程序员去程序进行分块，这是一个费时费力让人痛苦不堪的过程。后来这个解决方案的修正版就是虚拟内存。</p>
<h2 id="虚拟内存基本思想"><a href="#虚拟内存基本思想" class="headerlink" title="虚拟内存基本思想"></a>虚拟内存基本思想</h2><p>每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一 页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。</p>
<p>当程序引用到一部分在物理内存中的地址空间时，由硬件立即执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。<br><img src="https://images.cnblogs.com/cnblogs_com/CareySon/201204/20120425163755141.png" alt="image"></p>
<h2 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h2><h3 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h3><p>由上图可以看出，虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2），而如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生==缺页中断==，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。</p>
<p>而虚拟内存和物理内存的匹配是通过页表实现，页表存在MMU中，页表中每个项通常为32位，既4byte,除了存储虚拟地址和页框地址之外，还会存储一些标志位，比如是否缺页，是否修改过，写保护等。可以把MMU想象成一个接收虚拟地址项返回物理地址的方法。</p>
<h3 id="为什么需要页面置换"><a href="#为什么需要页面置换" class="headerlink" title="为什么需要页面置换"></a>为什么需要页面置换</h3><p>  因为在计算机系统中，读取少量数据硬盘通常需要几毫秒，而内存中仅仅需要几纳秒。一条CPU指令也通常是几纳秒，如果在执行CPU指令时，产生几次缺页中断，那性能可想而知，因此尽量减少从硬盘的读取无疑是大大的提升了性能。而前面知道，物理内存是极其有限的，当虚拟内存所求的页不在物理内存中时，将需要将物理内存中的页替换出去，选择哪些页替换出去就显得尤为重要，如果算法不好将未来需要使用的页替换出去，则以后使用时还需要替换进来，这无疑是降低效率的，让我们来看几种页面替换算法</p>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="OPT（Optimal-replacement）最优置换算法："><a href="#OPT（Optimal-replacement）最优置换算法：" class="headerlink" title="OPT（Optimal replacement）最优置换算法："></a>OPT（Optimal replacement）最优置换算法：</h4><p>理论的最优，理论；就是要保证置换出去的是不再被使用的页，或者是在实际内存中最晚使用的算法<br>最佳置换算法是将未来最久不使用的页替换出去，这听起来很简单，但是无法实现。但是这种算法可以作为衡量其它算法的基准。</p>
<h4 id="LRU（Least-recently-use-）最近最少使用算法"><a href="#LRU（Least-recently-use-）最近最少使用算法" class="headerlink" title="LRU（Least recently use ）最近最少使用算法"></a>LRU（Least recently use ）最近最少使用算法</h4><p>种算法给每个页一个标志位，R表示最近被访问过，M表示被修改过。定期对R进行清零。这个算法的思路是首先淘汰那些未被访问过R=0的页，其次是被访问过R=1,未被修改过M=0的页，最后是R=1,M=1的页。</p>
<h4 id="FIFO先进先出算法："><a href="#FIFO先进先出算法：" class="headerlink" title="FIFO先进先出算法："></a>FIFO先进先出算法：</h4><p>这种算法的思想是淘汰在内存中最久的页，这种算法的性能接近于随机淘汰。并不好。<br>在操作系统中经常被用到，比如作业调度（主要实现简单，很容易想到）；</p>
<h4 id="改进型FIFO算法-Second-Chance-Page-Replacement-Algorithm"><a href="#改进型FIFO算法-Second-Chance-Page-Replacement-Algorithm" class="headerlink" title="改进型FIFO算法(Second Chance Page Replacement Algorithm)"></a>改进型FIFO算法(Second Chance Page Replacement Algorithm)</h4><p>这种算法是在FIFO的基础上，为了避免置换出经常使用的页，增加一个标志位R，如果最近使用过将R置1，当页将会淘汰时，如果R为1，则不淘汰页，将R置0.而那些R=0的页将被淘汰时，直接淘汰。这种算法避免了经常被使用的页被淘汰。</p>
<h4 id="LFU（Least-frequently-use）最少使用次数算法：根据使用次数来判断；"><a href="#LFU（Least-frequently-use）最少使用次数算法：根据使用次数来判断；" class="headerlink" title="LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；"></a>LFU（Least frequently use）最少使用次数算法：根据使用次数来判断；</h4><p>最久未使用算法(LRU Page Replacement Algorithm)</p>
<h4 id="时钟替换算法-Clock-Page-Replacement-Algorithm"><a href="#时钟替换算法-Clock-Page-Replacement-Algorithm" class="headerlink" title="时钟替换算法(Clock Page Replacement Algorithm)"></a>时钟替换算法(Clock Page Replacement Algorithm)</h4><p>虽然改进型FIFO算法避免置换出常用的页，但由于需要经常移动页，效率并不高。因此在改进型FIFO算法的基础上，将队列首位相连形成一个环路，当缺页中断产生时，从当前位置开始找R=0的页，而所经过的R=1的页被置0，并不需要移动页。如图6所示。<br><img src="https://images.cnblogs.com/cnblogs_com/CareySon/201204/201204251637589948.png" alt="image"></p>
<p><img src="EDA141F869784AFA85400793187C4CB4" alt="image"></p>
<h2 id="分页和分段有什么区别（内存管理）？"><a href="#分页和分段有什么区别（内存管理）？" class="headerlink" title="分页和分段有什么区别（内存管理）？"></a>分页和分段有什么区别（内存管理）？</h2><p>　　段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p>
<p>　　页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。</p>
<h2 id="两者的不同点："><a href="#两者的不同点：" class="headerlink" title="两者的不同点："></a>两者的不同点：</h2><p>目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；</p>
<p>大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；</p>
<p>地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；</p>
<p>信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；</p>
<p>内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。</p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">
    <time datetime="2020-11-19T16:00:28.791Z" class="entry-date">
        2020-11-20
    </time>
</a>
    
    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B/" rel="prev"><span class="meta-nav">←</span> (no title)</a></span>
    
    
        <span class="nav-next"><a href="/huanghao.github.io/2020/11/20/003.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F+%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88linux%EF%BC%89/%E6%9C%AC%E7%A7%91%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%A5%E9%97%A8/%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6/" rel="next">(no title) <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E6%89%80%E8%B0%93%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E4%BD%9C%E7%94%A8%E5%9F%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/%E8%AF%AD%E8%A8%80%E7%B1%BB%E6%A6%82%E8%AE%BA/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93/">(no title)</a>
          </li>
        
          <li>
            <a href="/huanghao.github.io/2020/11/20/001.%E8%AF%AD%E8%A8%80/php/php%E6%80%A7%E8%83%BD%E8%B0%83%E6%A0%91+%E9%83%A8%E7%BD%B2+%E6%B5%8B%E8%AF%95/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2020 huanghao
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  
<link rel="stylesheet" href="/huanghao.github.io/fancybox/jquery.fancybox.css">

  
<script src="/huanghao.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/huanghao.github.io/js/script.js"></script>


<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>